{"expiry":6014680162,"data":[{"SourceCode":{"language":"Solidity","sources":{"@solidstate/contracts/token/ERC20/metadata/ERC20MetadataInternal.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC20MetadataInternal } from './IERC20MetadataInternal.sol';\nimport { ERC20MetadataStorage } from './ERC20MetadataStorage.sol';\n\n/**\n * @title ERC20Metadata internal functions\n */\nabstract contract ERC20MetadataInternal is IERC20MetadataInternal {\n    /**\n     * @notice return token name\n     * @return token name\n     */\n    function _name() internal view virtual returns (string memory) {\n        return ERC20MetadataStorage.layout().name;\n    }\n\n    /**\n     * @notice return token symbol\n     * @return token symbol\n     */\n    function _symbol() internal view virtual returns (string memory) {\n        return ERC20MetadataStorage.layout().symbol;\n    }\n\n    /**\n     * @notice return token decimals, generally used only for display purposes\n     * @return token decimals\n     */\n    function _decimals() internal view virtual returns (uint8) {\n        return ERC20MetadataStorage.layout().decimals;\n    }\n\n    function _setName(string memory name) internal virtual {\n        ERC20MetadataStorage.layout().name = name;\n    }\n\n    function _setSymbol(string memory symbol) internal virtual {\n        ERC20MetadataStorage.layout().symbol = symbol;\n    }\n\n    function _setDecimals(uint8 decimals) internal virtual {\n        ERC20MetadataStorage.layout().decimals = decimals;\n    }\n}\n"},"@solidstate/contracts/introspection/ERC165/base/ERC165BaseInternal.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC165BaseInternal } from './IERC165BaseInternal.sol';\nimport { ERC165BaseStorage } from './ERC165BaseStorage.sol';\n\n/**\n * @title ERC165 implementation\n */\nabstract contract ERC165BaseInternal is IERC165BaseInternal {\n    /**\n     * @notice indicates whether an interface is already supported based on the interfaceId\n     * @param interfaceId id of interface to check\n     * @return bool indicating whether interface is supported\n     */\n    function _supportsInterface(\n        bytes4 interfaceId\n    ) internal view returns (bool) {\n        return ERC165BaseStorage.layout().supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @notice sets status of interface support\n     * @param interfaceId id of interface to set status for\n     * @param status boolean indicating whether interface will be set as supported\n     */\n    function _setSupportsInterface(bytes4 interfaceId, bool status) internal {\n        if (interfaceId == 0xffffffff) revert ERC165Base__InvalidInterfaceId();\n        ERC165BaseStorage.layout().supportedInterfaces[interfaceId] = status;\n    }\n}\n"},"contracts/layerZero/interfaces/ILayerZeroEndpoint.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport {ILayerZeroUserApplicationConfig} from \"./ILayerZeroUserApplicationConfig.sol\";\r\n\r\ninterface ILayerZeroEndpoint is ILayerZeroUserApplicationConfig {\r\n    /**\r\n     * @notice send a LayerZero message to the specified address at a LayerZero endpoint.\r\n     * @param dstChainId - the destination chain identifier\r\n     * @param destination - the address on destination chain (in bytes). address length/format may vary by chains\r\n     * @param payload - a custom bytes payload to send to the destination contract\r\n     * @param refundAddress - if the source transaction is cheaper than the amount of value passed, refund the additional amount to this address\r\n     * @param zroPaymentAddress - the address of the ZRO token holder who would pay for the transaction\r\n     * @param adapterParams - parameters for custom functionality. e.g. receive airdropped native gas from the relayer on destination\r\n     */\r\n    function send(\r\n        uint16 dstChainId,\r\n        bytes calldata destination,\r\n        bytes calldata payload,\r\n        address payable refundAddress,\r\n        address zroPaymentAddress,\r\n        bytes calldata adapterParams\r\n    ) external payable;\r\n\r\n    /**\r\n     * @notice used by the messaging library to publish verified payload\r\n     * @param srcChainId - the source chain identifier\r\n     * @param srcAddress - the source contract (as bytes) at the source chain\r\n     * @param dstAddress - the address on destination chain\r\n     * @param nonce - the unbound message ordering nonce\r\n     * @param gasLimit - the gas limit for external contract execution\r\n     * @param payload - verified payload to send to the destination contract\r\n     */\r\n    function receivePayload(\r\n        uint16 srcChainId,\r\n        bytes calldata srcAddress,\r\n        address dstAddress,\r\n        uint64 nonce,\r\n        uint256 gasLimit,\r\n        bytes calldata payload\r\n    ) external;\r\n\r\n    /*\r\n     * @notice get the inboundNonce of a lzApp from a source chain which could be EVM or non-EVM chain\r\n     * @param srcChainId - the source chain identifier\r\n     * @param srcAddress - the source chain contract address\r\n     */\r\n    function getInboundNonce(\r\n        uint16 srcChainId,\r\n        bytes calldata srcAddress\r\n    ) external view returns (uint64);\r\n\r\n    /*\r\n     * @notice get the outboundNonce from this source chain which, consequently, is always an EVM\r\n     * @param srcAddress - the source chain contract address\r\n     */\r\n    function getOutboundNonce(\r\n        uint16 dstChainId,\r\n        address srcAddress\r\n    ) external view returns (uint64);\r\n\r\n    /*\r\n     * @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery\r\n     * @param dstChainId - the destination chain identifier\r\n     * @param userApplication - the user app address on this EVM chain\r\n     * @param payload - the custom message to send over LayerZero\r\n     * @param payInZRO - if false, user app pays the protocol fee in native token\r\n     * @param adapterParam - parameters for the adapter service, e.g. send some dust native token to dstChain\r\n     */\r\n    function estimateFees(\r\n        uint16 dstChainId,\r\n        address userApplication,\r\n        bytes calldata payload,\r\n        bool payInZRO,\r\n        bytes calldata adapterParam\r\n    ) external view returns (uint256 nativeFee, uint256 zroFee);\r\n\r\n    /*\r\n     * @notice get this Endpoint's immutable source identifier\r\n     */\r\n    function getChainId() external view returns (uint16);\r\n\r\n    /*\r\n     * @notice the interface to retry failed message on this Endpoint destination\r\n     * @param srcChainId - the source chain identifier\r\n     * @param srcAddress - the source chain contract address\r\n     * @param payload - the payload to be retried\r\n     */\r\n    function retryPayload(\r\n        uint16 srcChainId,\r\n        bytes calldata srcAddress,\r\n        bytes calldata payload\r\n    ) external;\r\n\r\n    /*\r\n     * @notice query if any STORED payload (message blocking) at the endpoint.\r\n     * @param srcChainId - the source chain identifier\r\n     * @param srcAddress - the source chain contract address\r\n     */\r\n    function hasStoredPayload(\r\n        uint16 srcChainId,\r\n        bytes calldata srcAddress\r\n    ) external view returns (bool);\r\n\r\n    /*\r\n     * @notice query if the libraryAddress is valid for sending msgs.\r\n     * @param userApplication - the user app address on this EVM chain\r\n     */\r\n    function getSendLibraryAddress(\r\n        address userApplication\r\n    ) external view returns (address);\r\n\r\n    /*\r\n     * @notice query if the libraryAddress is valid for receiving msgs.\r\n     * @param userApplication - the user app address on this EVM chain\r\n     */\r\n    function getReceiveLibraryAddress(\r\n        address userApplication\r\n    ) external view returns (address);\r\n\r\n    /*\r\n     * @notice query if the non-reentrancy guard for send() is on\r\n     * @return true if the guard is on. false otherwise\r\n     */\r\n    function isSendingPayload() external view returns (bool);\r\n\r\n    /*\r\n     * @notice query if the non-reentrancy guard for receive() is on\r\n     * @return true if the guard is on. false otherwise\r\n     */\r\n    function isReceivingPayload() external view returns (bool);\r\n\r\n    /*\r\n     * @notice get the configuration of the LayerZero messaging library of the specified version\r\n     * @param version - messaging library version\r\n     * @param chainId - the chainId for the pending config change\r\n     * @param userApplication - the contract address of the user application\r\n     * @param configType - type of configuration. every messaging library has its own convention.\r\n     */\r\n    function getConfig(\r\n        uint16 version,\r\n        uint16 chainId,\r\n        address userApplication,\r\n        uint256 configType\r\n    ) external view returns (bytes memory);\r\n\r\n    /*\r\n     * @notice get the send() LayerZero messaging library version\r\n     * @param userApplication - the contract address of the user application\r\n     */\r\n    function getSendVersion(\r\n        address userApplication\r\n    ) external view returns (uint16);\r\n\r\n    /*\r\n     * @notice get the lzReceive() LayerZero messaging library version\r\n     * @param userApplication - the contract address of the user application\r\n     */\r\n    function getReceiveVersion(\r\n        address userApplication\r\n    ) external view returns (uint16);\r\n}\r\n"},"@solidstate/contracts/token/ERC20/extended/ERC20Extended.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC20Extended } from './IERC20Extended.sol';\nimport { ERC20ExtendedInternal } from './ERC20ExtendedInternal.sol';\n\n/**\n * @title ERC20 safe approval extensions\n * @dev mitigations for transaction-ordering vulnerability (see https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729)\n */\nabstract contract ERC20Extended is IERC20Extended, ERC20ExtendedInternal {\n    /**\n     * @inheritdoc IERC20Extended\n     */\n    function increaseAllowance(\n        address spender,\n        uint256 amount\n    ) external returns (bool) {\n        return _increaseAllowance(spender, amount);\n    }\n\n    /**\n     * @inheritdoc IERC20Extended\n     */\n    function decreaseAllowance(\n        address spender,\n        uint256 amount\n    ) external returns (bool) {\n        return _decreaseAllowance(spender, amount);\n    }\n}\n"},"@solidstate/contracts/token/ERC20/metadata/IERC20MetadataInternal.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title ERC20 metadata internal interface\n */\ninterface IERC20MetadataInternal {\n\n}\n"},"@solidstate/contracts/token/ERC20/permit/ERC20PermitInternal.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.8;\n\nimport { ECDSA } from '../../../cryptography/ECDSA.sol';\nimport { ERC20BaseInternal } from '../base/ERC20BaseInternal.sol';\nimport { ERC20MetadataInternal } from '../metadata/ERC20MetadataInternal.sol';\nimport { ERC20PermitStorage } from './ERC20PermitStorage.sol';\nimport { IERC20PermitInternal } from './IERC20PermitInternal.sol';\n\n/**\n * @title ERC20 extension with support for ERC2612 permits\n * @dev derived from https://github.com/soliditylabs/ERC20-Permit (MIT license)\n */\nabstract contract ERC20PermitInternal is\n    ERC20BaseInternal,\n    ERC20MetadataInternal,\n    IERC20PermitInternal\n{\n    using ECDSA for bytes32;\n\n    /**\n     * @notice return the EIP-712 domain separator unique to contract and chain\n     * @return domainSeparator domain separator\n     */\n    function _DOMAIN_SEPARATOR()\n        internal\n        view\n        returns (bytes32 domainSeparator)\n    {\n        domainSeparator = ERC20PermitStorage.layout().domainSeparators[\n            _chainId()\n        ];\n\n        if (domainSeparator == 0x00) {\n            domainSeparator = _calculateDomainSeparator();\n        }\n    }\n\n    /**\n     * @notice get the current ERC2612 nonce for the given address\n     * @return current nonce\n     */\n    function _nonces(address owner) internal view returns (uint256) {\n        return ERC20PermitStorage.layout().nonces[owner];\n    }\n\n    /**\n     * @notice calculate unique EIP-712 domain separator\n     * @return domainSeparator domain separator\n     */\n    function _calculateDomainSeparator()\n        internal\n        view\n        returns (bytes32 domainSeparator)\n    {\n        // no need for assembly, running very rarely\n        domainSeparator = keccak256(\n            abi.encode(\n                keccak256(\n                    'EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'\n                ),\n                keccak256(bytes(_name())), // ERC-20 Name\n                keccak256(bytes('1')), // Version\n                _chainId(),\n                address(this)\n            )\n        );\n    }\n\n    /**\n     * @notice get the current chain ID\n     * @return chainId chain ID\n     */\n    function _chainId() private view returns (uint256 chainId) {\n        assembly {\n            chainId := chainid()\n        }\n    }\n\n    /**\n     * @notice approve spender to transfer tokens held by owner via signature\n     * @dev this function may be vulnerable to approval replay attacks\n     * @param owner holder of tokens and signer of permit\n     * @param spender beneficiary of approval\n     * @param amount quantity of tokens to approve\n     * @param v secp256k1 'v' value\n     * @param r secp256k1 'r' value\n     * @param s secp256k1 's' value\n     * @dev If https://eips.ethereum.org/EIPS/eip-1344[ChainID] ever changes, the\n     * EIP712 Domain Separator is automatically recalculated.\n     */\n    function _permit(\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal virtual {\n        if (block.timestamp > deadline) revert ERC20Permit__ExpiredDeadline();\n\n        // Assembly for more efficiently computing:\n        // bytes32 hashStruct = keccak256(\n        //   abi.encode(\n        //     _PERMIT_TYPEHASH,\n        //     owner,\n        //     spender,\n        //     amount,\n        //     _nonces[owner].current(),\n        //     deadline\n        //   )\n        // );\n\n        ERC20PermitStorage.Layout storage l = ERC20PermitStorage.layout();\n\n        bytes32 hashStruct;\n        uint256 nonce = l.nonces[owner];\n\n        assembly {\n            // Load free memory pointer\n            let pointer := mload(64)\n\n            // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\")\n            mstore(\n                pointer,\n                0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9\n            )\n            mstore(add(pointer, 32), owner)\n            mstore(add(pointer, 64), spender)\n            mstore(add(pointer, 96), amount)\n            mstore(add(pointer, 128), nonce)\n            mstore(add(pointer, 160), deadline)\n\n            hashStruct := keccak256(pointer, 192)\n        }\n\n        bytes32 domainSeparator = l.domainSeparators[_chainId()];\n\n        if (domainSeparator == 0x00) {\n            domainSeparator = _calculateDomainSeparator();\n            l.domainSeparators[_chainId()] = domainSeparator;\n        }\n\n        // Assembly for more efficient computing:\n        // bytes32 hash = keccak256(\n        //   abi.encodePacked(uint16(0x1901), domainSeparator, hashStruct)\n        // );\n\n        bytes32 hash;\n\n        assembly {\n            // Load free memory pointer\n            let pointer := mload(64)\n\n            mstore(\n                pointer,\n                0x1901000000000000000000000000000000000000000000000000000000000000\n            ) // EIP191 header\n            mstore(add(pointer, 2), domainSeparator) // EIP712 domain hash\n            mstore(add(pointer, 34), hashStruct) // Hash of struct\n\n            hash := keccak256(pointer, 66)\n        }\n\n        address signer = hash.recover(v, r, s);\n\n        if (signer != owner) revert ERC20Permit__InvalidSignature();\n\n        l.nonces[owner]++;\n        _approve(owner, spender, amount);\n    }\n}\n"},"@solidstate/contracts/utils/SafeERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC20 } from '../interfaces/IERC20.sol';\nimport { AddressUtils } from './AddressUtils.sol';\n\n/**\n * @title Safe ERC20 interaction library\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts/ (MIT license)\n */\nlibrary SafeERC20 {\n    using AddressUtils for address;\n\n    error SafeERC20__ApproveFromNonZeroToNonZero();\n    error SafeERC20__DecreaseAllowanceBelowZero();\n    error SafeERC20__OperationFailed();\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transfer.selector, to, value)\n        );\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\n        );\n    }\n\n    /**\n     * @dev safeApprove (like approve) should only be called when setting an initial allowance or when resetting it to zero; otherwise prefer safeIncreaseAllowance and safeDecreaseAllowance\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        if ((value != 0) && (token.allowance(address(this), spender) != 0))\n            revert SafeERC20__ApproveFromNonZeroToNonZero();\n\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.approve.selector, spender, value)\n        );\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(\n                token.approve.selector,\n                spender,\n                newAllowance\n            )\n        );\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            if (oldAllowance < value)\n                revert SafeERC20__DecreaseAllowanceBelowZero();\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(\n                token,\n                abi.encodeWithSelector(\n                    token.approve.selector,\n                    spender,\n                    newAllowance\n                )\n            );\n        }\n    }\n\n    /**\n     * @notice send transaction data and check validity of return value, if present\n     * @param token ERC20 token interface\n     * @param data transaction data\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        bytes memory returndata = address(token).functionCall(\n            data,\n            'SafeERC20: low-level call failed'\n        );\n\n        if (returndata.length > 0) {\n            if (!abi.decode(returndata, (bool)))\n                revert SafeERC20__OperationFailed();\n        }\n    }\n}\n"},"contracts/staking/PremiaStaking.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\r\n// For further clarification please see https://license.premia.legal\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport {AddressUtils} from \"@solidstate/contracts/utils/AddressUtils.sol\";\r\nimport {Math} from \"@solidstate/contracts/utils/Math.sol\";\r\nimport {IERC20} from \"@solidstate/contracts/interfaces/IERC20.sol\";\r\nimport {IERC2612} from \"@solidstate/contracts/token/ERC20/permit/IERC2612.sol\";\r\nimport {SafeERC20} from \"@solidstate/contracts/utils/SafeERC20.sol\";\r\nimport {ABDKMath64x64} from \"abdk-libraries-solidity/ABDKMath64x64.sol\";\r\n\r\nimport {IExchangeHelper} from \"../interfaces/IExchangeHelper.sol\";\r\nimport {IPremiaStaking} from \"./IPremiaStaking.sol\";\r\nimport {PremiaStakingStorage} from \"./PremiaStakingStorage.sol\";\r\nimport {OFT} from \"../layerZero/token/oft/OFT.sol\";\r\nimport {OFTCore} from \"../layerZero/token/oft/OFTCore.sol\";\r\nimport {IOFTCore} from \"../layerZero/token/oft/IOFTCore.sol\";\r\nimport {BytesLib} from \"../layerZero/util/BytesLib.sol\";\r\n\r\ncontract PremiaStaking is IPremiaStaking, OFT {\r\n    using SafeERC20 for IERC20;\r\n    using ABDKMath64x64 for int128;\r\n    using AddressUtils for address;\r\n    using BytesLib for bytes;\r\n\r\n    address internal immutable PREMIA;\r\n    address internal immutable REWARD_TOKEN;\r\n    address internal immutable EXCHANGE_HELPER;\r\n\r\n    int128 internal constant ONE_64x64 = 0x10000000000000000;\r\n    int128 internal constant DECAY_RATE_64x64 = 0x487a423b63e; // 2.7e-7 -> Distribute around half of the current balance over a month\r\n    uint256 internal constant INVERSE_BASIS_POINT = 1e4;\r\n    uint64 internal constant MAX_PERIOD = 4 * 365 days;\r\n    uint256 internal constant ACC_REWARD_PRECISION = 1e30;\r\n    uint256 internal constant MAX_CONTRACT_DISCOUNT = 3000; // -30%\r\n    uint256 internal constant WITHDRAWAL_DELAY = 10 days;\r\n\r\n    struct UpdateArgsInternal {\r\n        address user;\r\n        uint256 balance;\r\n        uint256 oldPower;\r\n        uint256 newPower;\r\n        uint256 reward;\r\n        uint256 unstakeReward;\r\n    }\r\n\r\n    constructor(\r\n        address lzEndpoint,\r\n        address premia,\r\n        address rewardToken,\r\n        address exchangeHelper\r\n    ) OFT(lzEndpoint) {\r\n        PREMIA = premia;\r\n        REWARD_TOKEN = rewardToken;\r\n        EXCHANGE_HELPER = exchangeHelper;\r\n    }\r\n\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256\r\n    ) internal virtual override {\r\n        if (from == address(0) || to == address(0)) return;\r\n\r\n        revert PremiaStaking__CantTransfer();\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IPremiaStaking\r\n     */\r\n    function getRewardToken() external view returns (address) {\r\n        return REWARD_TOKEN;\r\n    }\r\n\r\n    function estimateSendFee(\r\n        uint16 dstChainId,\r\n        bytes memory toAddress,\r\n        uint256 amount,\r\n        bool useZro,\r\n        bytes memory adapterParams\r\n    )\r\n        public\r\n        view\r\n        virtual\r\n        override(OFTCore, IOFTCore)\r\n        returns (uint256 nativeFee, uint256 zroFee)\r\n    {\r\n        // Convert bytes to address\r\n        address to;\r\n        assembly {\r\n            to := mload(add(toAddress, 32))\r\n        }\r\n\r\n        PremiaStakingStorage.UserInfo storage u = PremiaStakingStorage\r\n            .layout()\r\n            .userInfo[to];\r\n\r\n        return\r\n            lzEndpoint.estimateFees(\r\n                dstChainId,\r\n                address(this),\r\n                abi.encode(PT_SEND, to, amount, u.stakePeriod, u.lockedUntil),\r\n                useZro,\r\n                adapterParams\r\n            );\r\n    }\r\n\r\n    function _send(\r\n        address from,\r\n        uint16 dstChainId,\r\n        bytes memory,\r\n        uint256 amount,\r\n        address payable refundAddress,\r\n        address zroPaymentAddress,\r\n        bytes memory adapterParams\r\n    ) internal virtual override {\r\n        _updateRewards();\r\n        _beforeUnstake(from, amount);\r\n\r\n        PremiaStakingStorage.Layout storage l = PremiaStakingStorage.layout();\r\n        PremiaStakingStorage.UserInfo storage u = l.userInfo[from];\r\n\r\n        UpdateArgsInternal memory args = _getInitialUpdateArgsInternal(\r\n            l,\r\n            u,\r\n            from\r\n        );\r\n\r\n        bytes memory toAddress = abi.encodePacked(from);\r\n        _debitFrom(from, dstChainId, toAddress, amount);\r\n\r\n        args.newPower = _calculateUserPower(\r\n            args.balance - amount + args.unstakeReward,\r\n            u.stakePeriod\r\n        );\r\n\r\n        _updateUser(l, u, args);\r\n\r\n        _lzSend(\r\n            dstChainId,\r\n            abi.encode(\r\n                PT_SEND,\r\n                toAddress,\r\n                amount,\r\n                u.stakePeriod,\r\n                u.lockedUntil\r\n            ),\r\n            refundAddress,\r\n            zroPaymentAddress,\r\n            adapterParams,\r\n            msg.value\r\n        );\r\n\r\n        emit SendToChain(from, dstChainId, toAddress, amount);\r\n    }\r\n\r\n    function _sendAck(\r\n        uint16 srcChainId,\r\n        bytes memory srcAddress,\r\n        uint64,\r\n        bytes memory payload\r\n    ) internal virtual override {\r\n        (\r\n            ,\r\n            bytes memory toAddressBytes,\r\n            uint256 amount,\r\n            uint64 stakePeriod,\r\n            uint64 lockedUntil\r\n        ) = abi.decode(payload, (uint16, bytes, uint256, uint64, uint64));\r\n\r\n        address to = toAddressBytes.toAddress(0);\r\n\r\n        _creditTo(to, amount, stakePeriod, lockedUntil, true);\r\n        emit ReceiveFromChain(srcChainId, srcAddress, to, amount);\r\n    }\r\n\r\n    function _creditTo(\r\n        address toAddress,\r\n        uint256 amount,\r\n        uint64 stakePeriod,\r\n        uint64 creditLockedUntil,\r\n        bool bridge\r\n    ) internal {\r\n        unchecked {\r\n            _updateRewards();\r\n\r\n            PremiaStakingStorage.Layout storage l = PremiaStakingStorage\r\n                .layout();\r\n            PremiaStakingStorage.UserInfo storage u = l.userInfo[toAddress];\r\n\r\n            UpdateArgsInternal memory args = _getInitialUpdateArgsInternal(\r\n                l,\r\n                u,\r\n                toAddress\r\n            );\r\n\r\n            uint64 lockedUntil = u.lockedUntil;\r\n\r\n            uint64 lockLeft = uint64(\r\n                _calculateWeightedAverage(\r\n                    creditLockedUntil > block.timestamp\r\n                        ? creditLockedUntil - block.timestamp\r\n                        : 0,\r\n                    lockedUntil > block.timestamp\r\n                        ? lockedUntil - block.timestamp\r\n                        : 0,\r\n                    amount + args.unstakeReward,\r\n                    args.balance\r\n                )\r\n            );\r\n\r\n            u.lockedUntil = lockedUntil = uint64(block.timestamp) + lockLeft;\r\n\r\n            u.stakePeriod = uint64(\r\n                _calculateWeightedAverage(\r\n                    stakePeriod,\r\n                    u.stakePeriod,\r\n                    amount + args.unstakeReward,\r\n                    args.balance\r\n                )\r\n            );\r\n\r\n            args.newPower = _calculateUserPower(\r\n                args.balance + amount + args.unstakeReward,\r\n                u.stakePeriod\r\n            );\r\n\r\n            _mint(toAddress, amount);\r\n\r\n            _updateUser(l, u, args);\r\n\r\n            if (bridge) {\r\n                emit BridgeLock(toAddress, u.stakePeriod, lockedUntil);\r\n            } else {\r\n                emit Stake(toAddress, amount, u.stakePeriod, lockedUntil);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IPremiaStaking\r\n     */\r\n    function addRewards(uint256 amount) external {\r\n        _updateRewards();\r\n\r\n        IERC20(REWARD_TOKEN).safeTransferFrom(\r\n            msg.sender,\r\n            address(this),\r\n            amount\r\n        );\r\n        PremiaStakingStorage.layout().availableRewards += amount;\r\n\r\n        emit RewardsAdded(amount);\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IPremiaStaking\r\n     */\r\n    function getAvailableRewards()\r\n        external\r\n        view\r\n        returns (uint256 rewards, uint256 unstakeRewards)\r\n    {\r\n        PremiaStakingStorage.Layout storage l = PremiaStakingStorage.layout();\r\n        unchecked {\r\n            rewards = l.availableRewards - _getPendingRewards();\r\n        }\r\n        unstakeRewards = l.availableUnstakeRewards;\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IPremiaStaking\r\n     */\r\n    function getPendingRewards() external view returns (uint256) {\r\n        return _getPendingRewards();\r\n    }\r\n\r\n    function _getPendingRewards() internal view returns (uint256) {\r\n        PremiaStakingStorage.Layout storage l = PremiaStakingStorage.layout();\r\n        return\r\n            l.availableRewards -\r\n            _decay(l.availableRewards, l.lastRewardUpdate, block.timestamp);\r\n    }\r\n\r\n    function _updateRewards() internal {\r\n        PremiaStakingStorage.Layout storage l = PremiaStakingStorage.layout();\r\n\r\n        if (\r\n            l.lastRewardUpdate == 0 ||\r\n            l.totalPower == 0 ||\r\n            l.availableRewards == 0\r\n        ) {\r\n            l.lastRewardUpdate = block.timestamp;\r\n            return;\r\n        }\r\n\r\n        uint256 pendingRewards = _getPendingRewards();\r\n\r\n        l.accRewardPerShare +=\r\n            (pendingRewards * ACC_REWARD_PRECISION) /\r\n            l.totalPower;\r\n\r\n        unchecked {\r\n            l.availableRewards -= pendingRewards;\r\n        }\r\n\r\n        l.lastRewardUpdate = block.timestamp;\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IPremiaStaking\r\n     */\r\n    function stakeWithPermit(\r\n        uint256 amount,\r\n        uint64 period,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external {\r\n        IERC2612(PREMIA).permit(\r\n            msg.sender,\r\n            address(this),\r\n            amount,\r\n            deadline,\r\n            v,\r\n            r,\r\n            s\r\n        );\r\n\r\n        IERC20(PREMIA).safeTransferFrom(msg.sender, address(this), amount);\r\n\r\n        _stake(msg.sender, amount, period);\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IPremiaStaking\r\n     */\r\n    function stake(uint256 amount, uint64 period) external {\r\n        IERC20(PREMIA).safeTransferFrom(msg.sender, address(this), amount);\r\n        _stake(msg.sender, amount, period);\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IPremiaStaking\r\n     */\r\n    function updateLock(uint64 period) external {\r\n        if (period > MAX_PERIOD) revert PremiaStaking__ExcessiveStakePeriod();\r\n\r\n        _updateRewards();\r\n\r\n        PremiaStakingStorage.Layout storage l = PremiaStakingStorage.layout();\r\n        PremiaStakingStorage.UserInfo storage u = l.userInfo[msg.sender];\r\n\r\n        uint64 oldPeriod = u.stakePeriod;\r\n\r\n        if (period <= oldPeriod) revert PremiaStaking__PeriodTooShort();\r\n\r\n        UpdateArgsInternal memory args = _getInitialUpdateArgsInternal(\r\n            l,\r\n            u,\r\n            msg.sender\r\n        );\r\n\r\n        unchecked {\r\n            uint64 lockToAdd = period - oldPeriod;\r\n            u.lockedUntil =\r\n                uint64(Math.max(u.lockedUntil, block.timestamp)) +\r\n                lockToAdd;\r\n            u.stakePeriod = period;\r\n\r\n            args.newPower = _calculateUserPower(\r\n                args.balance + args.unstakeReward,\r\n                period\r\n            );\r\n        }\r\n\r\n        _updateUser(l, u, args);\r\n\r\n        emit UpdateLock(msg.sender, oldPeriod, period);\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IPremiaStaking\r\n     */\r\n    function harvestAndStake(\r\n        IPremiaStaking.SwapArgs memory s,\r\n        uint64 stakePeriod\r\n    ) external {\r\n        uint256 amountRewardToken = _harvest(msg.sender);\r\n\r\n        if (amountRewardToken == 0) return;\r\n\r\n        IERC20(REWARD_TOKEN).safeTransfer(EXCHANGE_HELPER, amountRewardToken);\r\n\r\n        uint256 amountPremia = IExchangeHelper(EXCHANGE_HELPER).swapWithToken(\r\n            REWARD_TOKEN,\r\n            PREMIA,\r\n            amountRewardToken,\r\n            s.callee,\r\n            s.allowanceTarget,\r\n            s.data,\r\n            s.refundAddress\r\n        );\r\n\r\n        if (amountPremia < s.amountOutMin)\r\n            revert PremiaStaking__InsufficientSwapOutput();\r\n\r\n        _stake(msg.sender, amountPremia, stakePeriod);\r\n    }\r\n\r\n    function _calculateWeightedAverage(\r\n        uint256 A,\r\n        uint256 B,\r\n        uint256 weightA,\r\n        uint256 weightB\r\n    ) internal pure returns (uint256) {\r\n        return (A * weightA + B * weightB) / (weightA + weightB);\r\n    }\r\n\r\n    function _stake(\r\n        address toAddress,\r\n        uint256 amount,\r\n        uint64 stakePeriod\r\n    ) internal {\r\n        if (stakePeriod > MAX_PERIOD)\r\n            revert PremiaStaking__ExcessiveStakePeriod();\r\n\r\n        unchecked {\r\n            _creditTo(\r\n                toAddress,\r\n                amount,\r\n                stakePeriod,\r\n                uint64(block.timestamp) + stakePeriod,\r\n                false\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IPremiaStaking\r\n     */\r\n    function getPendingUserRewards(\r\n        address user\r\n    ) external view returns (uint256 reward, uint256 unstakeReward) {\r\n        PremiaStakingStorage.Layout storage l = PremiaStakingStorage.layout();\r\n        PremiaStakingStorage.UserInfo storage u = l.userInfo[user];\r\n\r\n        uint256 accRewardPerShare = l.accRewardPerShare;\r\n        if (l.lastRewardUpdate > 0 && l.availableRewards > 0) {\r\n            accRewardPerShare +=\r\n                (_getPendingRewards() * ACC_REWARD_PRECISION) /\r\n                l.totalPower;\r\n        }\r\n\r\n        uint256 power = _calculateUserPower(_balanceOf(user), u.stakePeriod);\r\n\r\n        reward =\r\n            u.reward +\r\n            _calculateReward(accRewardPerShare, power, u.rewardDebt);\r\n\r\n        unstakeReward = _calculateReward(\r\n            l.accUnstakeRewardPerShare,\r\n            power,\r\n            u.unstakeRewardDebt\r\n        );\r\n    }\r\n\r\n    function harvest() external {\r\n        uint256 amount = _harvest(msg.sender);\r\n        IERC20(REWARD_TOKEN).safeTransfer(msg.sender, amount);\r\n    }\r\n\r\n    function _harvest(address account) internal returns (uint256 amount) {\r\n        _updateRewards();\r\n\r\n        PremiaStakingStorage.Layout storage l = PremiaStakingStorage.layout();\r\n        PremiaStakingStorage.UserInfo storage u = l.userInfo[account];\r\n\r\n        UpdateArgsInternal memory args = _getInitialUpdateArgsInternal(\r\n            l,\r\n            u,\r\n            account\r\n        );\r\n\r\n        if (args.unstakeReward > 0) {\r\n            args.newPower = _calculateUserPower(\r\n                args.balance + args.unstakeReward,\r\n                u.stakePeriod\r\n            );\r\n        } else {\r\n            args.newPower = args.oldPower;\r\n        }\r\n\r\n        _updateUser(l, u, args);\r\n\r\n        amount = u.reward;\r\n        u.reward = 0;\r\n\r\n        emit Harvest(account, amount);\r\n    }\r\n\r\n    function _updateTotalPower(\r\n        PremiaStakingStorage.Layout storage l,\r\n        uint256 oldUserPower,\r\n        uint256 newUserPower\r\n    ) internal {\r\n        if (newUserPower > oldUserPower) {\r\n            l.totalPower += newUserPower - oldUserPower;\r\n        } else if (newUserPower < oldUserPower) {\r\n            l.totalPower -= oldUserPower - newUserPower;\r\n        }\r\n    }\r\n\r\n    function _beforeUnstake(address user, uint256 amount) internal virtual {}\r\n\r\n    /**\r\n     * @inheritdoc IPremiaStaking\r\n     */\r\n    function earlyUnstake(uint256 amount) external {\r\n        PremiaStakingStorage.Layout storage l = PremiaStakingStorage.layout();\r\n\r\n        _startWithdraw(\r\n            l,\r\n            l.userInfo[msg.sender],\r\n            amount,\r\n            (amount * _getEarlyUnstakeFeeBPS(msg.sender)) / INVERSE_BASIS_POINT\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IPremiaStaking\r\n     */\r\n    function getEarlyUnstakeFeeBPS(\r\n        address user\r\n    ) external view returns (uint256 feePercentage) {\r\n        return _getEarlyUnstakeFeeBPS(user);\r\n    }\r\n\r\n    function _getEarlyUnstakeFeeBPS(\r\n        address user\r\n    ) internal view returns (uint256 feePercentageBPS) {\r\n        uint256 lockedUntil = PremiaStakingStorage\r\n            .layout()\r\n            .userInfo[user]\r\n            .lockedUntil;\r\n\r\n        if (lockedUntil <= block.timestamp)\r\n            revert PremiaStaking__StakeNotLocked();\r\n\r\n        uint256 lockLeft;\r\n\r\n        unchecked {\r\n            lockLeft = lockedUntil - block.timestamp;\r\n            feePercentageBPS = (lockLeft * 2500) / 365 days; // 25% fee per year left\r\n        }\r\n\r\n        if (feePercentageBPS > 7500) {\r\n            feePercentageBPS = 7500; // Capped at 75%\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IPremiaStaking\r\n     */\r\n    function startWithdraw(uint256 amount) external {\r\n        PremiaStakingStorage.Layout storage l = PremiaStakingStorage.layout();\r\n        PremiaStakingStorage.UserInfo storage u = l.userInfo[msg.sender];\r\n\r\n        if (u.lockedUntil > block.timestamp)\r\n            revert PremiaStaking__StakeLocked();\r\n\r\n        _startWithdraw(l, u, amount, 0);\r\n    }\r\n\r\n    function _startWithdraw(\r\n        PremiaStakingStorage.Layout storage l,\r\n        PremiaStakingStorage.UserInfo storage u,\r\n        uint256 amount,\r\n        uint256 fee\r\n    ) internal {\r\n        uint256 amountMinusFee;\r\n        unchecked {\r\n            amountMinusFee = amount - fee;\r\n        }\r\n\r\n        if (_getAvailablePremiaAmount() < amountMinusFee)\r\n            revert PremiaStaking__NotEnoughLiquidity();\r\n\r\n        _updateRewards();\r\n        _beforeUnstake(msg.sender, amount);\r\n\r\n        UpdateArgsInternal memory args = _getInitialUpdateArgsInternal(\r\n            l,\r\n            u,\r\n            msg.sender\r\n        );\r\n\r\n        _burn(msg.sender, amount);\r\n        l.pendingWithdrawal += amountMinusFee;\r\n\r\n        if (fee > 0) {\r\n            l.accUnstakeRewardPerShare +=\r\n                (fee * ACC_REWARD_PRECISION) /\r\n                (l.totalPower - args.oldPower); // User who early unstake doesnt collect any of the fee\r\n\r\n            l.availableUnstakeRewards += fee;\r\n        }\r\n\r\n        args.newPower = _calculateUserPower(\r\n            args.balance - amount + args.unstakeReward,\r\n            u.stakePeriod\r\n        );\r\n\r\n        _updateUser(l, u, args);\r\n\r\n        l.withdrawals[msg.sender].amount += amountMinusFee;\r\n        l.withdrawals[msg.sender].startDate = block.timestamp;\r\n\r\n        emit Unstake(msg.sender, amount, fee, block.timestamp);\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IPremiaStaking\r\n     */\r\n    function withdraw() external {\r\n        _updateRewards();\r\n\r\n        PremiaStakingStorage.Layout storage l = PremiaStakingStorage.layout();\r\n\r\n        uint256 startDate = l.withdrawals[msg.sender].startDate;\r\n\r\n        if (startDate == 0) revert PremiaStaking__NoPendingWithdrawal();\r\n\r\n        unchecked {\r\n            if (block.timestamp <= startDate + WITHDRAWAL_DELAY)\r\n                revert PremiaStaking__WithdrawalStillPending();\r\n        }\r\n\r\n        uint256 amount = l.withdrawals[msg.sender].amount;\r\n        l.pendingWithdrawal -= amount;\r\n        delete l.withdrawals[msg.sender];\r\n\r\n        IERC20(PREMIA).safeTransfer(msg.sender, amount);\r\n\r\n        emit Withdraw(msg.sender, amount);\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IPremiaStaking\r\n     */\r\n    function getTotalPower() external view returns (uint256) {\r\n        return PremiaStakingStorage.layout().totalPower;\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IPremiaStaking\r\n     */\r\n    function getUserPower(address user) external view returns (uint256) {\r\n        return\r\n            _calculateUserPower(\r\n                _balanceOf(user),\r\n                PremiaStakingStorage.layout().userInfo[user].stakePeriod\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IPremiaStaking\r\n     */\r\n    function getDiscountBPS(address user) external view returns (uint256) {\r\n        PremiaStakingStorage.Layout storage l = PremiaStakingStorage.layout();\r\n\r\n        uint256 userPower = _calculateUserPower(\r\n            _balanceOf(user),\r\n            l.userInfo[user].stakePeriod\r\n        );\r\n\r\n        // If user is a contract, we use a different formula based on % of total power owned by the contract\r\n        if (user.isContract()) {\r\n            // Require 50% of overall staked power for contract to have max discount\r\n            if (userPower >= l.totalPower >> 1) {\r\n                return MAX_CONTRACT_DISCOUNT;\r\n            } else {\r\n                return\r\n                    (userPower * MAX_CONTRACT_DISCOUNT) / (l.totalPower >> 1);\r\n            }\r\n        }\r\n\r\n        IPremiaStaking.StakeLevel[] memory stakeLevels = _getStakeLevels();\r\n\r\n        uint256 length = stakeLevels.length;\r\n\r\n        unchecked {\r\n            for (uint256 i = 0; i < length; i++) {\r\n                IPremiaStaking.StakeLevel memory level = stakeLevels[i];\r\n\r\n                if (userPower < level.amount) {\r\n                    uint256 amountPrevLevel;\r\n                    uint256 discountPrevLevelBPS;\r\n\r\n                    // If stake is lower, user is in this level, and we need to LERP with prev level to get discount value\r\n                    if (i > 0) {\r\n                        amountPrevLevel = stakeLevels[i - 1].amount;\r\n                        discountPrevLevelBPS = stakeLevels[i - 1].discountBPS;\r\n                    } else {\r\n                        // If this is the first level, prev level is 0 / 0\r\n                        amountPrevLevel = 0;\r\n                        discountPrevLevelBPS = 0;\r\n                    }\r\n\r\n                    uint256 remappedDiscountBPS = level.discountBPS -\r\n                        discountPrevLevelBPS;\r\n\r\n                    uint256 remappedAmount = level.amount - amountPrevLevel;\r\n                    uint256 remappedPower = userPower - amountPrevLevel;\r\n                    uint256 levelProgressBPS = (remappedPower *\r\n                        INVERSE_BASIS_POINT) / remappedAmount;\r\n\r\n                    return\r\n                        discountPrevLevelBPS +\r\n                        ((remappedDiscountBPS * levelProgressBPS) /\r\n                            INVERSE_BASIS_POINT);\r\n                }\r\n            }\r\n\r\n            // If no match found it means user is >= max possible stake, and therefore has max discount possible\r\n            return stakeLevels[length - 1].discountBPS;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IPremiaStaking\r\n     */\r\n    function getStakeLevels()\r\n        external\r\n        pure\r\n        returns (IPremiaStaking.StakeLevel[] memory stakeLevels)\r\n    {\r\n        return _getStakeLevels();\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IPremiaStaking\r\n     */\r\n    function getStakePeriodMultiplierBPS(\r\n        uint256 period\r\n    ) external pure returns (uint256) {\r\n        return _getStakePeriodMultiplierBPS(period);\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IPremiaStaking\r\n     */\r\n    function getUserInfo(\r\n        address user\r\n    ) external view returns (PremiaStakingStorage.UserInfo memory) {\r\n        return PremiaStakingStorage.layout().userInfo[user];\r\n    }\r\n\r\n    function getPendingWithdrawals() external view returns (uint256) {\r\n        return PremiaStakingStorage.layout().pendingWithdrawal;\r\n    }\r\n\r\n    function getPendingWithdrawal(\r\n        address user\r\n    )\r\n        external\r\n        view\r\n        returns (uint256 amount, uint256 startDate, uint256 unlockDate)\r\n    {\r\n        PremiaStakingStorage.Layout storage l = PremiaStakingStorage.layout();\r\n        amount = l.withdrawals[user].amount;\r\n        startDate = l.withdrawals[user].startDate;\r\n\r\n        unchecked {\r\n            if (startDate > 0) {\r\n                unlockDate = startDate + WITHDRAWAL_DELAY;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _decay(\r\n        uint256 pendingRewards,\r\n        uint256 oldTimestamp,\r\n        uint256 newTimestamp\r\n    ) internal pure returns (uint256) {\r\n        return\r\n            ONE_64x64\r\n                .sub(DECAY_RATE_64x64)\r\n                .pow(newTimestamp - oldTimestamp)\r\n                .mulu(pendingRewards);\r\n    }\r\n\r\n    function _getStakeLevels()\r\n        internal\r\n        pure\r\n        returns (IPremiaStaking.StakeLevel[] memory stakeLevels)\r\n    {\r\n        stakeLevels = new IPremiaStaking.StakeLevel[](4);\r\n\r\n        stakeLevels[0] = IPremiaStaking.StakeLevel(5000 * 1e18, 1000); // -10%\r\n        stakeLevels[1] = IPremiaStaking.StakeLevel(50000 * 1e18, 2500); // -25%\r\n        stakeLevels[2] = IPremiaStaking.StakeLevel(500000 * 1e18, 3500); // -35%\r\n        stakeLevels[3] = IPremiaStaking.StakeLevel(2500000 * 1e18, 6000); // -60%\r\n    }\r\n\r\n    function _getStakePeriodMultiplierBPS(\r\n        uint256 period\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 oneYear = 365 days;\r\n\r\n            if (period == 0) return 2500; // x0.25\r\n            if (period >= 4 * oneYear) return 42500; // x4.25\r\n\r\n            return 2500 + (period * 1e4) / oneYear; // 0.25x + 1.0x per year lockup\r\n        }\r\n    }\r\n\r\n    function _calculateUserPower(\r\n        uint256 balance,\r\n        uint64 stakePeriod\r\n    ) internal pure returns (uint256) {\r\n        return\r\n            (balance * _getStakePeriodMultiplierBPS(stakePeriod)) /\r\n            INVERSE_BASIS_POINT;\r\n    }\r\n\r\n    function _calculateReward(\r\n        uint256 accRewardPerShare,\r\n        uint256 power,\r\n        uint256 rewardDebt\r\n    ) internal pure returns (uint256) {\r\n        return\r\n            ((accRewardPerShare * power) / ACC_REWARD_PRECISION) - rewardDebt;\r\n    }\r\n\r\n    function _creditRewards(\r\n        PremiaStakingStorage.Layout storage l,\r\n        PremiaStakingStorage.UserInfo storage u,\r\n        address user,\r\n        uint256 reward,\r\n        uint256 unstakeReward\r\n    ) internal {\r\n        u.reward += reward;\r\n\r\n        if (unstakeReward > 0) {\r\n            l.availableUnstakeRewards -= unstakeReward;\r\n            _mint(user, unstakeReward);\r\n            emit EarlyUnstakeRewardCollected(user, unstakeReward);\r\n        }\r\n    }\r\n\r\n    function _getInitialUpdateArgsInternal(\r\n        PremiaStakingStorage.Layout storage l,\r\n        PremiaStakingStorage.UserInfo storage u,\r\n        address user\r\n    ) internal view returns (UpdateArgsInternal memory) {\r\n        UpdateArgsInternal memory args;\r\n        args.user = user;\r\n        args.balance = _balanceOf(user);\r\n\r\n        if (args.balance > 0) {\r\n            args.oldPower = _calculateUserPower(args.balance, u.stakePeriod);\r\n        }\r\n\r\n        args.reward = _calculateReward(\r\n            l.accRewardPerShare,\r\n            args.oldPower,\r\n            u.rewardDebt\r\n        );\r\n        args.unstakeReward = _calculateReward(\r\n            l.accUnstakeRewardPerShare,\r\n            args.oldPower,\r\n            u.unstakeRewardDebt\r\n        );\r\n\r\n        return args;\r\n    }\r\n\r\n    function _calculateRewardDebt(\r\n        uint256 accRewardPerShare,\r\n        uint256 power\r\n    ) internal pure returns (uint256) {\r\n        return (power * accRewardPerShare) / ACC_REWARD_PRECISION;\r\n    }\r\n\r\n    function _updateUser(\r\n        PremiaStakingStorage.Layout storage l,\r\n        PremiaStakingStorage.UserInfo storage u,\r\n        UpdateArgsInternal memory args\r\n    ) internal {\r\n        // Update reward debt\r\n        u.rewardDebt = _calculateRewardDebt(l.accRewardPerShare, args.newPower);\r\n        u.unstakeRewardDebt = _calculateRewardDebt(\r\n            l.accUnstakeRewardPerShare,\r\n            args.newPower\r\n        );\r\n\r\n        _creditRewards(l, u, args.user, args.reward, args.unstakeReward);\r\n        _updateTotalPower(l, args.oldPower, args.newPower);\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IPremiaStaking\r\n     */\r\n    function getAvailablePremiaAmount() external view returns (uint256) {\r\n        return _getAvailablePremiaAmount();\r\n    }\r\n\r\n    function _getAvailablePremiaAmount() internal view returns (uint256) {\r\n        return\r\n            IERC20(PREMIA).balanceOf(address(this)) -\r\n            PremiaStakingStorage.layout().pendingWithdrawal;\r\n    }\r\n}\r\n"},"contracts/staking/PremiaStakingStorage.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\r\n// For further clarification please see https://license.premia.legal\r\n\r\npragma solidity ^0.8.0;\r\n\r\nlibrary PremiaStakingStorage {\r\n    bytes32 internal constant STORAGE_SLOT =\r\n        keccak256(\"premia.contracts.staking.PremiaStaking\");\r\n\r\n    struct Withdrawal {\r\n        uint256 amount; // Premia amount\r\n        uint256 startDate; // Will unlock at startDate + withdrawalDelay\r\n    }\r\n\r\n    struct UserInfo {\r\n        uint256 reward; // Amount of rewards accrued which havent been claimed yet\r\n        uint256 rewardDebt; // Debt to subtract from reward calculation\r\n        uint256 unstakeRewardDebt; // Debt to subtract from reward calculation from early unstake fee\r\n        uint64 stakePeriod; // Stake period selected by user\r\n        uint64 lockedUntil; // Timestamp at which the lock ends\r\n    }\r\n\r\n    struct Layout {\r\n        uint256 pendingWithdrawal;\r\n        uint256 _deprecated_withdrawalDelay;\r\n        mapping(address => Withdrawal) withdrawals;\r\n        uint256 availableRewards;\r\n        uint256 lastRewardUpdate; // Timestamp of last reward distribution update\r\n        uint256 totalPower; // Total power of all staked tokens (underlying amount with multiplier applied)\r\n        mapping(address => UserInfo) userInfo;\r\n        uint256 accRewardPerShare;\r\n        uint256 accUnstakeRewardPerShare;\r\n        uint256 availableUnstakeRewards;\r\n    }\r\n\r\n    function layout() internal pure returns (Layout storage l) {\r\n        bytes32 slot = STORAGE_SLOT;\r\n        assembly {\r\n            l.slot := slot\r\n        }\r\n    }\r\n}\r\n"},"@solidstate/contracts/access/ownable/IOwnableInternal.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC173Internal } from '../../interfaces/IERC173Internal.sol';\n\ninterface IOwnableInternal is IERC173Internal {\n    error Ownable__NotOwner();\n    error Ownable__NotTransitiveOwner();\n}\n"},"@solidstate/contracts/token/ERC20/metadata/ERC20Metadata.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC20Metadata } from './IERC20Metadata.sol';\nimport { ERC20MetadataInternal } from './ERC20MetadataInternal.sol';\n\n/**\n * @title ERC20 metadata extensions\n */\nabstract contract ERC20Metadata is IERC20Metadata, ERC20MetadataInternal {\n    /**\n     * @inheritdoc IERC20Metadata\n     */\n    function name() external view returns (string memory) {\n        return _name();\n    }\n\n    /**\n     * @inheritdoc IERC20Metadata\n     */\n    function symbol() external view returns (string memory) {\n        return _symbol();\n    }\n\n    /**\n     * @inheritdoc IERC20Metadata\n     */\n    function decimals() external view returns (uint8) {\n        return _decimals();\n    }\n}\n"},"@solidstate/contracts/interfaces/IERC20Internal.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title Partial ERC20 interface needed by internal functions\n */\ninterface IERC20Internal {\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n"},"contracts/layerZero/token/oft/IOFT.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport {IOFTCore} from \"./IOFTCore.sol\";\r\nimport {ISolidStateERC20} from \"@solidstate/contracts/token/ERC20/ISolidStateERC20.sol\";\r\n\r\n/**\r\n * @dev Interface of the OFT standard\r\n */\r\ninterface IOFT is IOFTCore, ISolidStateERC20 {\r\n    error OFT_InsufficientAllowance();\r\n}\r\n"},"@solidstate/contracts/token/ERC20/permit/IERC2612.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC2612Internal } from './IERC2612Internal.sol';\n\n/**\n * @title ERC2612 interface\n * @dev see https://eips.ethereum.org/EIPS/eip-2612.\n */\ninterface IERC2612 is IERC2612Internal {\n    /**\n     * @notice return the EIP-712 domain separator unique to contract and chain\n     * @return domainSeparator domain separator\n     */\n    function DOMAIN_SEPARATOR() external view returns (bytes32 domainSeparator);\n\n    /**\n     * @notice get the current ERC2612 nonce for the given address\n     * @return current nonce\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @notice approve spender to transfer tokens held by owner via signature\n     * @dev this function may be vulnerable to approval replay attacks\n     * @param owner holder of tokens and signer of permit\n     * @param spender beneficiary of approval\n     * @param amount quantity of tokens to approve\n     * @param v secp256k1 'v' value\n     * @param r secp256k1 'r' value\n     * @param s secp256k1 's' value\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"},"@solidstate/contracts/access/ownable/OwnableInternal.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC173 } from '../../interfaces/IERC173.sol';\nimport { AddressUtils } from '../../utils/AddressUtils.sol';\nimport { IOwnableInternal } from './IOwnableInternal.sol';\nimport { OwnableStorage } from './OwnableStorage.sol';\n\nabstract contract OwnableInternal is IOwnableInternal {\n    using AddressUtils for address;\n\n    modifier onlyOwner() {\n        if (msg.sender != _owner()) revert Ownable__NotOwner();\n        _;\n    }\n\n    modifier onlyTransitiveOwner() {\n        if (msg.sender != _transitiveOwner())\n            revert Ownable__NotTransitiveOwner();\n        _;\n    }\n\n    function _owner() internal view virtual returns (address) {\n        return OwnableStorage.layout().owner;\n    }\n\n    function _transitiveOwner() internal view virtual returns (address owner) {\n        owner = _owner();\n\n        while (owner.isContract()) {\n            try IERC173(owner).owner() returns (address transitiveOwner) {\n                owner = transitiveOwner;\n            } catch {\n                break;\n            }\n        }\n    }\n\n    function _transferOwnership(address account) internal virtual {\n        _setOwner(account);\n    }\n\n    function _setOwner(address account) internal virtual {\n        OwnableStorage.Layout storage l = OwnableStorage.layout();\n        emit OwnershipTransferred(l.owner, account);\n        l.owner = account;\n    }\n}\n"},"@solidstate/contracts/access/ownable/OwnableStorage.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nlibrary OwnableStorage {\n    struct Layout {\n        address owner;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.Ownable');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"},"contracts/core/IProxyManager.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-or-later\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IProxyManager {\r\n    function getPoolList() external view returns (address[] memory);\r\n}\r\n"},"contracts/layerZero/interfaces/ILayerZeroUserApplicationConfig.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface ILayerZeroUserApplicationConfig {\r\n    /*\r\n     * @notice set the configuration of the LayerZero messaging library of the specified version\r\n     * @param version - messaging library version\r\n     * @param chainId - the chainId for the pending config change\r\n     * @param configType - type of configuration. every messaging library has its own convention.\r\n     * @param config - configuration in the bytes. can encode arbitrary content.\r\n     */\r\n    function setConfig(\r\n        uint16 version,\r\n        uint16 chainId,\r\n        uint256 configType,\r\n        bytes calldata config\r\n    ) external;\r\n\r\n    /*\r\n     * @notice set the send() LayerZero messaging library version to version\r\n     * @param version - new messaging library version\r\n     */\r\n    function setSendVersion(uint16 version) external;\r\n\r\n    /*\r\n     * @notice set the lzReceive() LayerZero messaging library version to version\r\n     * @param version - new messaging library version\r\n     */\r\n    function setReceiveVersion(uint16 version) external;\r\n\r\n    /*\r\n     * @notice Only when the UA needs to resume the message flow in blocking mode and clear the stored payload\r\n     * @param srcChainId - the chainId of the source chain\r\n     * @param srcAddress - the contract address of the source contract at the source chain\r\n     */\r\n    function forceResumeReceive(\r\n        uint16 srcChainId,\r\n        bytes calldata srcAddress\r\n    ) external;\r\n}\r\n"},"contracts/staking/IVxPremia.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-or-later\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport {VxPremiaStorage} from \"./VxPremiaStorage.sol\";\r\nimport {IPremiaStaking} from \"./IPremiaStaking.sol\";\r\n\r\ninterface IVxPremia is IPremiaStaking {\r\n    error VxPremia__InvalidPoolAddress();\r\n    error VxPremia__InvalidVoteTarget();\r\n    error VxPremia__NotEnoughVotingPower();\r\n\r\n    event AddVote(\r\n        address indexed voter,\r\n        VxPremiaStorage.VoteVersion indexed version,\r\n        bytes target,\r\n        uint256 amount\r\n    );\r\n    event RemoveVote(\r\n        address indexed voter,\r\n        VxPremiaStorage.VoteVersion indexed version,\r\n        bytes target,\r\n        uint256 amount\r\n    );\r\n\r\n    /**\r\n     * @notice get total votes for specific pools\r\n     * @param version version of target (used to know how to decode data)\r\n     * @param target ABI encoded target of the votes\r\n     * @return total votes for specific pool\r\n     */\r\n    function getPoolVotes(\r\n        VxPremiaStorage.VoteVersion version,\r\n        bytes memory target\r\n    ) external view returns (uint256);\r\n\r\n    /**\r\n     * @notice get votes of user\r\n     * @param user user from which to get votes\r\n     * @return votes of user\r\n     */\r\n    function getUserVotes(\r\n        address user\r\n    ) external view returns (VxPremiaStorage.Vote[] memory);\r\n\r\n    /**\r\n     * @notice add or remove votes, in the limit of the user voting power\r\n     * @param votes votes to cast\r\n     */\r\n    function castVotes(VxPremiaStorage.Vote[] memory votes) external;\r\n}\r\n"},"@solidstate/contracts/token/ERC20/base/ERC20BaseStorage.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nlibrary ERC20BaseStorage {\n    struct Layout {\n        mapping(address => uint256) balances;\n        mapping(address => mapping(address => uint256)) allowances;\n        uint256 totalSupply;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.ERC20Base');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"},"abdk-libraries-solidity/ABDKMath64x64.sol":{"content":"// SPDX-License-Identifier: BSD-4-Clause\n/*\n * ABDK Math 64.64 Smart Contract Library.  Copyright  2019 by ABDK Consulting.\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\n */\npragma solidity ^0.8.0;\n\n/**\n * Smart contract library of mathematical functions operating with signed\n * 64.64-bit fixed point numbers.  Signed 64.64-bit fixed point number is\n * basically a simple fraction whose numerator is signed 128-bit integer and\n * denominator is 2^64.  As long as denominator is always the same, there is no\n * need to store it, thus in Solidity signed 64.64-bit fixed point numbers are\n * represented by int128 type holding only the numerator.\n */\nlibrary ABDKMath64x64 {\n  /*\n   * Minimum value signed 64.64-bit fixed point number may have. \n   */\n  int128 private constant MIN_64x64 = -0x80000000000000000000000000000000;\n\n  /*\n   * Maximum value signed 64.64-bit fixed point number may have. \n   */\n  int128 private constant MAX_64x64 = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n  /**\n   * Convert signed 256-bit integer number into signed 64.64-bit fixed point\n   * number.  Revert on overflow.\n   *\n   * @param x signed 256-bit integer number\n   * @return signed 64.64-bit fixed point number\n   */\n  function fromInt (int256 x) internal pure returns (int128) {\n    unchecked {\n      require (x >= -0x8000000000000000 && x <= 0x7FFFFFFFFFFFFFFF);\n      return int128 (x << 64);\n    }\n  }\n\n  /**\n   * Convert signed 64.64 fixed point number into signed 64-bit integer number\n   * rounding down.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64-bit integer number\n   */\n  function toInt (int128 x) internal pure returns (int64) {\n    unchecked {\n      return int64 (x >> 64);\n    }\n  }\n\n  /**\n   * Convert unsigned 256-bit integer number into signed 64.64-bit fixed point\n   * number.  Revert on overflow.\n   *\n   * @param x unsigned 256-bit integer number\n   * @return signed 64.64-bit fixed point number\n   */\n  function fromUInt (uint256 x) internal pure returns (int128) {\n    unchecked {\n      require (x <= 0x7FFFFFFFFFFFFFFF);\n      return int128 (int256 (x << 64));\n    }\n  }\n\n  /**\n   * Convert signed 64.64 fixed point number into unsigned 64-bit integer\n   * number rounding down.  Revert on underflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return unsigned 64-bit integer number\n   */\n  function toUInt (int128 x) internal pure returns (uint64) {\n    unchecked {\n      require (x >= 0);\n      return uint64 (uint128 (x >> 64));\n    }\n  }\n\n  /**\n   * Convert signed 128.128 fixed point number into signed 64.64-bit fixed point\n   * number rounding down.  Revert on overflow.\n   *\n   * @param x signed 128.128-bin fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function from128x128 (int256 x) internal pure returns (int128) {\n    unchecked {\n      int256 result = x >> 64;\n      require (result >= MIN_64x64 && result <= MAX_64x64);\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Convert signed 64.64 fixed point number into signed 128.128 fixed point\n   * number.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 128.128 fixed point number\n   */\n  function to128x128 (int128 x) internal pure returns (int256) {\n    unchecked {\n      return int256 (x) << 64;\n    }\n  }\n\n  /**\n   * Calculate x + y.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function add (int128 x, int128 y) internal pure returns (int128) {\n    unchecked {\n      int256 result = int256(x) + y;\n      require (result >= MIN_64x64 && result <= MAX_64x64);\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate x - y.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function sub (int128 x, int128 y) internal pure returns (int128) {\n    unchecked {\n      int256 result = int256(x) - y;\n      require (result >= MIN_64x64 && result <= MAX_64x64);\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate x * y rounding down.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function mul (int128 x, int128 y) internal pure returns (int128) {\n    unchecked {\n      int256 result = int256(x) * y >> 64;\n      require (result >= MIN_64x64 && result <= MAX_64x64);\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate x * y rounding towards zero, where x is signed 64.64 fixed point\n   * number and y is signed 256-bit integer number.  Revert on overflow.\n   *\n   * @param x signed 64.64 fixed point number\n   * @param y signed 256-bit integer number\n   * @return signed 256-bit integer number\n   */\n  function muli (int128 x, int256 y) internal pure returns (int256) {\n    unchecked {\n      if (x == MIN_64x64) {\n        require (y >= -0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF &&\n          y <= 0x1000000000000000000000000000000000000000000000000);\n        return -y << 63;\n      } else {\n        bool negativeResult = false;\n        if (x < 0) {\n          x = -x;\n          negativeResult = true;\n        }\n        if (y < 0) {\n          y = -y; // We rely on overflow behavior here\n          negativeResult = !negativeResult;\n        }\n        uint256 absoluteResult = mulu (x, uint256 (y));\n        if (negativeResult) {\n          require (absoluteResult <=\n            0x8000000000000000000000000000000000000000000000000000000000000000);\n          return -int256 (absoluteResult); // We rely on overflow behavior here\n        } else {\n          require (absoluteResult <=\n            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n          return int256 (absoluteResult);\n        }\n      }\n    }\n  }\n\n  /**\n   * Calculate x * y rounding down, where x is signed 64.64 fixed point number\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\n   *\n   * @param x signed 64.64 fixed point number\n   * @param y unsigned 256-bit integer number\n   * @return unsigned 256-bit integer number\n   */\n  function mulu (int128 x, uint256 y) internal pure returns (uint256) {\n    unchecked {\n      if (y == 0) return 0;\n\n      require (x >= 0);\n\n      uint256 lo = (uint256 (int256 (x)) * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) >> 64;\n      uint256 hi = uint256 (int256 (x)) * (y >> 128);\n\n      require (hi <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n      hi <<= 64;\n\n      require (hi <=\n        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - lo);\n      return hi + lo;\n    }\n  }\n\n  /**\n   * Calculate x / y rounding towards zero.  Revert on overflow or when y is\n   * zero.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function div (int128 x, int128 y) internal pure returns (int128) {\n    unchecked {\n      require (y != 0);\n      int256 result = (int256 (x) << 64) / y;\n      require (result >= MIN_64x64 && result <= MAX_64x64);\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate x / y rounding towards zero, where x and y are signed 256-bit\n   * integer numbers.  Revert on overflow or when y is zero.\n   *\n   * @param x signed 256-bit integer number\n   * @param y signed 256-bit integer number\n   * @return signed 64.64-bit fixed point number\n   */\n  function divi (int256 x, int256 y) internal pure returns (int128) {\n    unchecked {\n      require (y != 0);\n\n      bool negativeResult = false;\n      if (x < 0) {\n        x = -x; // We rely on overflow behavior here\n        negativeResult = true;\n      }\n      if (y < 0) {\n        y = -y; // We rely on overflow behavior here\n        negativeResult = !negativeResult;\n      }\n      uint128 absoluteResult = divuu (uint256 (x), uint256 (y));\n      if (negativeResult) {\n        require (absoluteResult <= 0x80000000000000000000000000000000);\n        return -int128 (absoluteResult); // We rely on overflow behavior here\n      } else {\n        require (absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n        return int128 (absoluteResult); // We rely on overflow behavior here\n      }\n    }\n  }\n\n  /**\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\n   * integer numbers.  Revert on overflow or when y is zero.\n   *\n   * @param x unsigned 256-bit integer number\n   * @param y unsigned 256-bit integer number\n   * @return signed 64.64-bit fixed point number\n   */\n  function divu (uint256 x, uint256 y) internal pure returns (int128) {\n    unchecked {\n      require (y != 0);\n      uint128 result = divuu (x, y);\n      require (result <= uint128 (MAX_64x64));\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate -x.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function neg (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x != MIN_64x64);\n      return -x;\n    }\n  }\n\n  /**\n   * Calculate |x|.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function abs (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x != MIN_64x64);\n      return x < 0 ? -x : x;\n    }\n  }\n\n  /**\n   * Calculate 1 / x rounding towards zero.  Revert on overflow or when x is\n   * zero.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function inv (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x != 0);\n      int256 result = int256 (0x100000000000000000000000000000000) / x;\n      require (result >= MIN_64x64 && result <= MAX_64x64);\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate arithmetics average of x and y, i.e. (x + y) / 2 rounding down.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function avg (int128 x, int128 y) internal pure returns (int128) {\n    unchecked {\n      return int128 ((int256 (x) + int256 (y)) >> 1);\n    }\n  }\n\n  /**\n   * Calculate geometric average of x and y, i.e. sqrt (x * y) rounding down.\n   * Revert on overflow or in case x * y is negative.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function gavg (int128 x, int128 y) internal pure returns (int128) {\n    unchecked {\n      int256 m = int256 (x) * int256 (y);\n      require (m >= 0);\n      require (m <\n          0x4000000000000000000000000000000000000000000000000000000000000000);\n      return int128 (sqrtu (uint256 (m)));\n    }\n  }\n\n  /**\n   * Calculate x^y assuming 0^0 is 1, where x is signed 64.64 fixed point number\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y uint256 value\n   * @return signed 64.64-bit fixed point number\n   */\n  function pow (int128 x, uint256 y) internal pure returns (int128) {\n    unchecked {\n      bool negative = x < 0 && y & 1 == 1;\n\n      uint256 absX = uint128 (x < 0 ? -x : x);\n      uint256 absResult;\n      absResult = 0x100000000000000000000000000000000;\n\n      if (absX <= 0x10000000000000000) {\n        absX <<= 63;\n        while (y != 0) {\n          if (y & 0x1 != 0) {\n            absResult = absResult * absX >> 127;\n          }\n          absX = absX * absX >> 127;\n\n          if (y & 0x2 != 0) {\n            absResult = absResult * absX >> 127;\n          }\n          absX = absX * absX >> 127;\n\n          if (y & 0x4 != 0) {\n            absResult = absResult * absX >> 127;\n          }\n          absX = absX * absX >> 127;\n\n          if (y & 0x8 != 0) {\n            absResult = absResult * absX >> 127;\n          }\n          absX = absX * absX >> 127;\n\n          y >>= 4;\n        }\n\n        absResult >>= 64;\n      } else {\n        uint256 absXShift = 63;\n        if (absX < 0x1000000000000000000000000) { absX <<= 32; absXShift -= 32; }\n        if (absX < 0x10000000000000000000000000000) { absX <<= 16; absXShift -= 16; }\n        if (absX < 0x1000000000000000000000000000000) { absX <<= 8; absXShift -= 8; }\n        if (absX < 0x10000000000000000000000000000000) { absX <<= 4; absXShift -= 4; }\n        if (absX < 0x40000000000000000000000000000000) { absX <<= 2; absXShift -= 2; }\n        if (absX < 0x80000000000000000000000000000000) { absX <<= 1; absXShift -= 1; }\n\n        uint256 resultShift = 0;\n        while (y != 0) {\n          require (absXShift < 64);\n\n          if (y & 0x1 != 0) {\n            absResult = absResult * absX >> 127;\n            resultShift += absXShift;\n            if (absResult > 0x100000000000000000000000000000000) {\n              absResult >>= 1;\n              resultShift += 1;\n            }\n          }\n          absX = absX * absX >> 127;\n          absXShift <<= 1;\n          if (absX >= 0x100000000000000000000000000000000) {\n              absX >>= 1;\n              absXShift += 1;\n          }\n\n          y >>= 1;\n        }\n\n        require (resultShift < 64);\n        absResult >>= 64 - resultShift;\n      }\n      int256 result = negative ? -int256 (absResult) : int256 (absResult);\n      require (result >= MIN_64x64 && result <= MAX_64x64);\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate sqrt (x) rounding down.  Revert if x < 0.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function sqrt (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x >= 0);\n      return int128 (sqrtu (uint256 (int256 (x)) << 64));\n    }\n  }\n\n  /**\n   * Calculate binary logarithm of x.  Revert if x <= 0.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function log_2 (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x > 0);\n\n      int256 msb = 0;\n      int256 xc = x;\n      if (xc >= 0x10000000000000000) { xc >>= 64; msb += 64; }\n      if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\n      if (xc >= 0x10000) { xc >>= 16; msb += 16; }\n      if (xc >= 0x100) { xc >>= 8; msb += 8; }\n      if (xc >= 0x10) { xc >>= 4; msb += 4; }\n      if (xc >= 0x4) { xc >>= 2; msb += 2; }\n      if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\n\n      int256 result = msb - 64 << 64;\n      uint256 ux = uint256 (int256 (x)) << uint256 (127 - msb);\n      for (int256 bit = 0x8000000000000000; bit > 0; bit >>= 1) {\n        ux *= ux;\n        uint256 b = ux >> 255;\n        ux >>= 127 + b;\n        result += bit * int256 (b);\n      }\n\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate natural logarithm of x.  Revert if x <= 0.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function ln (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x > 0);\n\n      return int128 (int256 (\n          uint256 (int256 (log_2 (x))) * 0xB17217F7D1CF79ABC9E3B39803F2F6AF >> 128));\n    }\n  }\n\n  /**\n   * Calculate binary exponent of x.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function exp_2 (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x < 0x400000000000000000); // Overflow\n\n      if (x < -0x400000000000000000) return 0; // Underflow\n\n      uint256 result = 0x80000000000000000000000000000000;\n\n      if (x & 0x8000000000000000 > 0)\n        result = result * 0x16A09E667F3BCC908B2FB1366EA957D3E >> 128;\n      if (x & 0x4000000000000000 > 0)\n        result = result * 0x1306FE0A31B7152DE8D5A46305C85EDEC >> 128;\n      if (x & 0x2000000000000000 > 0)\n        result = result * 0x1172B83C7D517ADCDF7C8C50EB14A791F >> 128;\n      if (x & 0x1000000000000000 > 0)\n        result = result * 0x10B5586CF9890F6298B92B71842A98363 >> 128;\n      if (x & 0x800000000000000 > 0)\n        result = result * 0x1059B0D31585743AE7C548EB68CA417FD >> 128;\n      if (x & 0x400000000000000 > 0)\n        result = result * 0x102C9A3E778060EE6F7CACA4F7A29BDE8 >> 128;\n      if (x & 0x200000000000000 > 0)\n        result = result * 0x10163DA9FB33356D84A66AE336DCDFA3F >> 128;\n      if (x & 0x100000000000000 > 0)\n        result = result * 0x100B1AFA5ABCBED6129AB13EC11DC9543 >> 128;\n      if (x & 0x80000000000000 > 0)\n        result = result * 0x10058C86DA1C09EA1FF19D294CF2F679B >> 128;\n      if (x & 0x40000000000000 > 0)\n        result = result * 0x1002C605E2E8CEC506D21BFC89A23A00F >> 128;\n      if (x & 0x20000000000000 > 0)\n        result = result * 0x100162F3904051FA128BCA9C55C31E5DF >> 128;\n      if (x & 0x10000000000000 > 0)\n        result = result * 0x1000B175EFFDC76BA38E31671CA939725 >> 128;\n      if (x & 0x8000000000000 > 0)\n        result = result * 0x100058BA01FB9F96D6CACD4B180917C3D >> 128;\n      if (x & 0x4000000000000 > 0)\n        result = result * 0x10002C5CC37DA9491D0985C348C68E7B3 >> 128;\n      if (x & 0x2000000000000 > 0)\n        result = result * 0x1000162E525EE054754457D5995292026 >> 128;\n      if (x & 0x1000000000000 > 0)\n        result = result * 0x10000B17255775C040618BF4A4ADE83FC >> 128;\n      if (x & 0x800000000000 > 0)\n        result = result * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB >> 128;\n      if (x & 0x400000000000 > 0)\n        result = result * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9 >> 128;\n      if (x & 0x200000000000 > 0)\n        result = result * 0x10000162E43F4F831060E02D839A9D16D >> 128;\n      if (x & 0x100000000000 > 0)\n        result = result * 0x100000B1721BCFC99D9F890EA06911763 >> 128;\n      if (x & 0x80000000000 > 0)\n        result = result * 0x10000058B90CF1E6D97F9CA14DBCC1628 >> 128;\n      if (x & 0x40000000000 > 0)\n        result = result * 0x1000002C5C863B73F016468F6BAC5CA2B >> 128;\n      if (x & 0x20000000000 > 0)\n        result = result * 0x100000162E430E5A18F6119E3C02282A5 >> 128;\n      if (x & 0x10000000000 > 0)\n        result = result * 0x1000000B1721835514B86E6D96EFD1BFE >> 128;\n      if (x & 0x8000000000 > 0)\n        result = result * 0x100000058B90C0B48C6BE5DF846C5B2EF >> 128;\n      if (x & 0x4000000000 > 0)\n        result = result * 0x10000002C5C8601CC6B9E94213C72737A >> 128;\n      if (x & 0x2000000000 > 0)\n        result = result * 0x1000000162E42FFF037DF38AA2B219F06 >> 128;\n      if (x & 0x1000000000 > 0)\n        result = result * 0x10000000B17217FBA9C739AA5819F44F9 >> 128;\n      if (x & 0x800000000 > 0)\n        result = result * 0x1000000058B90BFCDEE5ACD3C1CEDC823 >> 128;\n      if (x & 0x400000000 > 0)\n        result = result * 0x100000002C5C85FE31F35A6A30DA1BE50 >> 128;\n      if (x & 0x200000000 > 0)\n        result = result * 0x10000000162E42FF0999CE3541B9FFFCF >> 128;\n      if (x & 0x100000000 > 0)\n        result = result * 0x100000000B17217F80F4EF5AADDA45554 >> 128;\n      if (x & 0x80000000 > 0)\n        result = result * 0x10000000058B90BFBF8479BD5A81B51AD >> 128;\n      if (x & 0x40000000 > 0)\n        result = result * 0x1000000002C5C85FDF84BD62AE30A74CC >> 128;\n      if (x & 0x20000000 > 0)\n        result = result * 0x100000000162E42FEFB2FED257559BDAA >> 128;\n      if (x & 0x10000000 > 0)\n        result = result * 0x1000000000B17217F7D5A7716BBA4A9AE >> 128;\n      if (x & 0x8000000 > 0)\n        result = result * 0x100000000058B90BFBE9DDBAC5E109CCE >> 128;\n      if (x & 0x4000000 > 0)\n        result = result * 0x10000000002C5C85FDF4B15DE6F17EB0D >> 128;\n      if (x & 0x2000000 > 0)\n        result = result * 0x1000000000162E42FEFA494F1478FDE05 >> 128;\n      if (x & 0x1000000 > 0)\n        result = result * 0x10000000000B17217F7D20CF927C8E94C >> 128;\n      if (x & 0x800000 > 0)\n        result = result * 0x1000000000058B90BFBE8F71CB4E4B33D >> 128;\n      if (x & 0x400000 > 0)\n        result = result * 0x100000000002C5C85FDF477B662B26945 >> 128;\n      if (x & 0x200000 > 0)\n        result = result * 0x10000000000162E42FEFA3AE53369388C >> 128;\n      if (x & 0x100000 > 0)\n        result = result * 0x100000000000B17217F7D1D351A389D40 >> 128;\n      if (x & 0x80000 > 0)\n        result = result * 0x10000000000058B90BFBE8E8B2D3D4EDE >> 128;\n      if (x & 0x40000 > 0)\n        result = result * 0x1000000000002C5C85FDF4741BEA6E77E >> 128;\n      if (x & 0x20000 > 0)\n        result = result * 0x100000000000162E42FEFA39FE95583C2 >> 128;\n      if (x & 0x10000 > 0)\n        result = result * 0x1000000000000B17217F7D1CFB72B45E1 >> 128;\n      if (x & 0x8000 > 0)\n        result = result * 0x100000000000058B90BFBE8E7CC35C3F0 >> 128;\n      if (x & 0x4000 > 0)\n        result = result * 0x10000000000002C5C85FDF473E242EA38 >> 128;\n      if (x & 0x2000 > 0)\n        result = result * 0x1000000000000162E42FEFA39F02B772C >> 128;\n      if (x & 0x1000 > 0)\n        result = result * 0x10000000000000B17217F7D1CF7D83C1A >> 128;\n      if (x & 0x800 > 0)\n        result = result * 0x1000000000000058B90BFBE8E7BDCBE2E >> 128;\n      if (x & 0x400 > 0)\n        result = result * 0x100000000000002C5C85FDF473DEA871F >> 128;\n      if (x & 0x200 > 0)\n        result = result * 0x10000000000000162E42FEFA39EF44D91 >> 128;\n      if (x & 0x100 > 0)\n        result = result * 0x100000000000000B17217F7D1CF79E949 >> 128;\n      if (x & 0x80 > 0)\n        result = result * 0x10000000000000058B90BFBE8E7BCE544 >> 128;\n      if (x & 0x40 > 0)\n        result = result * 0x1000000000000002C5C85FDF473DE6ECA >> 128;\n      if (x & 0x20 > 0)\n        result = result * 0x100000000000000162E42FEFA39EF366F >> 128;\n      if (x & 0x10 > 0)\n        result = result * 0x1000000000000000B17217F7D1CF79AFA >> 128;\n      if (x & 0x8 > 0)\n        result = result * 0x100000000000000058B90BFBE8E7BCD6D >> 128;\n      if (x & 0x4 > 0)\n        result = result * 0x10000000000000002C5C85FDF473DE6B2 >> 128;\n      if (x & 0x2 > 0)\n        result = result * 0x1000000000000000162E42FEFA39EF358 >> 128;\n      if (x & 0x1 > 0)\n        result = result * 0x10000000000000000B17217F7D1CF79AB >> 128;\n\n      result >>= uint256 (int256 (63 - (x >> 64)));\n      require (result <= uint256 (int256 (MAX_64x64)));\n\n      return int128 (int256 (result));\n    }\n  }\n\n  /**\n   * Calculate natural exponent of x.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function exp (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x < 0x400000000000000000); // Overflow\n\n      if (x < -0x400000000000000000) return 0; // Underflow\n\n      return exp_2 (\n          int128 (int256 (x) * 0x171547652B82FE1777D0FFDA0D23A7D12 >> 128));\n    }\n  }\n\n  /**\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\n   * integer numbers.  Revert on overflow or when y is zero.\n   *\n   * @param x unsigned 256-bit integer number\n   * @param y unsigned 256-bit integer number\n   * @return unsigned 64.64-bit fixed point number\n   */\n  function divuu (uint256 x, uint256 y) private pure returns (uint128) {\n    unchecked {\n      require (y != 0);\n\n      uint256 result;\n\n      if (x <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n        result = (x << 64) / y;\n      else {\n        uint256 msb = 192;\n        uint256 xc = x >> 192;\n        if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\n        if (xc >= 0x10000) { xc >>= 16; msb += 16; }\n        if (xc >= 0x100) { xc >>= 8; msb += 8; }\n        if (xc >= 0x10) { xc >>= 4; msb += 4; }\n        if (xc >= 0x4) { xc >>= 2; msb += 2; }\n        if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\n\n        result = (x << 255 - msb) / ((y - 1 >> msb - 191) + 1);\n        require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n\n        uint256 hi = result * (y >> 128);\n        uint256 lo = result * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n\n        uint256 xh = x >> 192;\n        uint256 xl = x << 64;\n\n        if (xl < lo) xh -= 1;\n        xl -= lo; // We rely on overflow behavior here\n        lo = hi << 128;\n        if (xl < lo) xh -= 1;\n        xl -= lo; // We rely on overflow behavior here\n\n        assert (xh == hi >> 128);\n\n        result += xl / y;\n      }\n\n      require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n      return uint128 (result);\n    }\n  }\n\n  /**\n   * Calculate sqrt (x) rounding down, where x is unsigned 256-bit integer\n   * number.\n   *\n   * @param x unsigned 256-bit integer number\n   * @return unsigned 128-bit integer number\n   */\n  function sqrtu (uint256 x) private pure returns (uint128) {\n    unchecked {\n      if (x == 0) return 0;\n      else {\n        uint256 xx = x;\n        uint256 r = 1;\n        if (xx >= 0x100000000000000000000000000000000) { xx >>= 128; r <<= 64; }\n        if (xx >= 0x10000000000000000) { xx >>= 64; r <<= 32; }\n        if (xx >= 0x100000000) { xx >>= 32; r <<= 16; }\n        if (xx >= 0x10000) { xx >>= 16; r <<= 8; }\n        if (xx >= 0x100) { xx >>= 8; r <<= 4; }\n        if (xx >= 0x10) { xx >>= 4; r <<= 2; }\n        if (xx >= 0x4) { r <<= 1; }\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1; // Seven iterations should be enough\n        uint256 r1 = x / r;\n        return uint128 (r < r1 ? r : r1);\n      }\n    }\n  }\n}\n"},"contracts/layerZero/token/oft/OFTCore.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport {NonblockingLzApp} from \"../../lzApp/NonblockingLzApp.sol\";\r\nimport {IOFTCore} from \"./IOFTCore.sol\";\r\nimport {ERC165Base, IERC165} from \"@solidstate/contracts/introspection/ERC165/base/ERC165Base.sol\";\r\nimport {BytesLib} from \"../../util/BytesLib.sol\";\r\n\r\nabstract contract OFTCore is NonblockingLzApp, ERC165Base, IOFTCore {\r\n    using BytesLib for bytes;\r\n\r\n    // packet type\r\n    uint16 public constant PT_SEND = 0;\r\n\r\n    constructor(address lzEndpoint) NonblockingLzApp(lzEndpoint) {}\r\n\r\n    function estimateSendFee(\r\n        uint16 dstChainId,\r\n        bytes memory toAddress,\r\n        uint256 amount,\r\n        bool useZro,\r\n        bytes memory adapterParams\r\n    ) public view virtual override returns (uint256 nativeFee, uint256 zroFee) {\r\n        // mock the payload for send()\r\n        bytes memory payload = abi.encode(\r\n            PT_SEND,\r\n            abi.encodePacked(msg.sender),\r\n            toAddress,\r\n            amount\r\n        );\r\n        return\r\n            lzEndpoint.estimateFees(\r\n                dstChainId,\r\n                address(this),\r\n                payload,\r\n                useZro,\r\n                adapterParams\r\n            );\r\n    }\r\n\r\n    function sendFrom(\r\n        address from,\r\n        uint16 dstChainId,\r\n        bytes memory toAddress,\r\n        uint256 amount,\r\n        address payable refundAddress,\r\n        address zroPaymentAddress,\r\n        bytes memory adapterParams\r\n    ) public payable virtual override {\r\n        _send(\r\n            from,\r\n            dstChainId,\r\n            toAddress,\r\n            amount,\r\n            refundAddress,\r\n            zroPaymentAddress,\r\n            adapterParams\r\n        );\r\n    }\r\n\r\n    function _nonblockingLzReceive(\r\n        uint16 srcChainId,\r\n        bytes memory srcAddress,\r\n        uint64 nonce,\r\n        bytes memory payload\r\n    ) internal virtual override {\r\n        uint16 packetType;\r\n        assembly {\r\n            packetType := mload(add(payload, 32))\r\n        }\r\n\r\n        if (packetType == PT_SEND) {\r\n            _sendAck(srcChainId, srcAddress, nonce, payload);\r\n        } else {\r\n            revert(\"OFTCore: unknown packet type\");\r\n        }\r\n    }\r\n\r\n    function _send(\r\n        address from,\r\n        uint16 dstChainId,\r\n        bytes memory toAddress,\r\n        uint256 amount,\r\n        address payable refundAddress,\r\n        address zroPaymentAddress,\r\n        bytes memory adapterParams\r\n    ) internal virtual {\r\n        _debitFrom(from, dstChainId, toAddress, amount);\r\n\r\n        bytes memory payload = abi.encode(\r\n            PT_SEND,\r\n            abi.encodePacked(from),\r\n            toAddress,\r\n            amount\r\n        );\r\n\r\n        _lzSend(\r\n            dstChainId,\r\n            payload,\r\n            refundAddress,\r\n            zroPaymentAddress,\r\n            adapterParams,\r\n            msg.value\r\n        );\r\n\r\n        emit SendToChain(from, dstChainId, toAddress, amount);\r\n    }\r\n\r\n    function _sendAck(\r\n        uint16 srcChainId,\r\n        bytes memory,\r\n        uint64,\r\n        bytes memory payload\r\n    ) internal virtual {\r\n        (, bytes memory from, bytes memory toAddressBytes, uint256 amount) = abi\r\n            .decode(payload, (uint16, bytes, bytes, uint256));\r\n\r\n        address to = toAddressBytes.toAddress(0);\r\n\r\n        _creditTo(srcChainId, to, amount);\r\n        emit ReceiveFromChain(srcChainId, from, to, amount);\r\n    }\r\n\r\n    function _debitFrom(\r\n        address from,\r\n        uint16 dstChainId,\r\n        bytes memory toAddress,\r\n        uint256 amount\r\n    ) internal virtual;\r\n\r\n    function _creditTo(\r\n        uint16 srcChainId,\r\n        address toAddress,\r\n        uint256 amount\r\n    ) internal virtual;\r\n}\r\n"},"@solidstate/contracts/token/ERC20/SolidStateERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { ISolidStateERC20 } from './ISolidStateERC20.sol';\nimport { ERC20Base } from './base/ERC20Base.sol';\nimport { ERC20Extended } from './extended/ERC20Extended.sol';\nimport { ERC20Metadata } from './metadata/ERC20Metadata.sol';\nimport { ERC20Permit } from './permit/ERC20Permit.sol';\n\n/**\n * @title SolidState ERC20 implementation, including recommended extensions\n */\nabstract contract SolidStateERC20 is\n    ISolidStateERC20,\n    ERC20Base,\n    ERC20Extended,\n    ERC20Metadata,\n    ERC20Permit\n{\n\n}\n"},"@solidstate/contracts/token/ERC20/metadata/ERC20MetadataStorage.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nlibrary ERC20MetadataStorage {\n    struct Layout {\n        string name;\n        string symbol;\n        uint8 decimals;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.ERC20Metadata');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"},"@solidstate/contracts/token/ERC20/extended/IERC20ExtendedInternal.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC20BaseInternal } from '../base/IERC20BaseInternal.sol';\n\n/**\n * @title ERC20 extended internal interface\n */\ninterface IERC20ExtendedInternal is IERC20BaseInternal {\n    error ERC20Extended__ExcessiveAllowance();\n    error ERC20Extended__InsufficientAllowance();\n}\n"},"@solidstate/contracts/interfaces/IERC173Internal.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title Partial ERC173 interface needed by internal functions\n */\ninterface IERC173Internal {\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n}\n"},"@solidstate/contracts/token/ERC20/base/ERC20Base.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC20 } from '../../../interfaces/IERC20.sol';\nimport { IERC20Base } from './IERC20Base.sol';\nimport { ERC20BaseInternal } from './ERC20BaseInternal.sol';\nimport { ERC20BaseStorage } from './ERC20BaseStorage.sol';\n\n/**\n * @title Base ERC20 implementation, excluding optional extensions\n */\nabstract contract ERC20Base is IERC20Base, ERC20BaseInternal {\n    /**\n     * @inheritdoc IERC20\n     */\n    function totalSupply() external view returns (uint256) {\n        return _totalSupply();\n    }\n\n    /**\n     * @inheritdoc IERC20\n     */\n    function balanceOf(address account) external view returns (uint256) {\n        return _balanceOf(account);\n    }\n\n    /**\n     * @inheritdoc IERC20\n     */\n    function allowance(\n        address holder,\n        address spender\n    ) external view returns (uint256) {\n        return _allowance(holder, spender);\n    }\n\n    /**\n     * @inheritdoc IERC20\n     */\n    function approve(address spender, uint256 amount) external returns (bool) {\n        return _approve(msg.sender, spender, amount);\n    }\n\n    /**\n     * @inheritdoc IERC20\n     */\n    function transfer(\n        address recipient,\n        uint256 amount\n    ) external returns (bool) {\n        return _transfer(msg.sender, recipient, amount);\n    }\n\n    /**\n     * @inheritdoc IERC20\n     */\n    function transferFrom(\n        address holder,\n        address recipient,\n        uint256 amount\n    ) external returns (bool) {\n        return _transferFrom(holder, recipient, amount);\n    }\n}\n"},"@solidstate/contracts/token/ERC20/extended/IERC20Extended.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC20ExtendedInternal } from './IERC20ExtendedInternal.sol';\n\n/**\n * @title ERC20 extended interface\n */\ninterface IERC20Extended is IERC20ExtendedInternal {\n    /**\n     * @notice increase spend amount granted to spender\n     * @param spender address whose allowance to increase\n     * @param amount quantity by which to increase allowance\n     * @return success status (always true; otherwise function will revert)\n     */\n    function increaseAllowance(\n        address spender,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @notice decrease spend amount granted to spender\n     * @param spender address whose allowance to decrease\n     * @param amount quantity by which to decrease allowance\n     * @return success status (always true; otherwise function will revert)\n     */\n    function decreaseAllowance(\n        address spender,\n        uint256 amount\n    ) external returns (bool);\n}\n"},"@solidstate/contracts/token/ERC20/permit/ERC20PermitStorage.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nlibrary ERC20PermitStorage {\n    struct Layout {\n        mapping(address => uint256) nonces;\n        // Mapping of ChainID to domain separators. This is a very gas efficient way\n        // to not recalculate the domain separator on every call, while still\n        // automatically detecting ChainID changes.\n        mapping(uint256 => bytes32) domainSeparators;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.ERC20Permit');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"},"contracts/layerZero/interfaces/ILayerZeroReceiver.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface ILayerZeroReceiver {\r\n    /*\r\n     * @notice LayerZero endpoint will invoke this function to deliver the message on the destination\r\n     * @param srcChainId - the source endpoint identifier\r\n     * @param srcAddress - the source sending contract address from the source chain\r\n     * @param nonce - the ordered message nonce\r\n     * @param payload - the signed payload is the UA bytes has encoded to be sent\r\n     */\r\n    function lzReceive(\r\n        uint16 srcChainId,\r\n        bytes calldata srcAddress,\r\n        uint64 nonce,\r\n        bytes calldata payload\r\n    ) external;\r\n}\r\n"},"@solidstate/contracts/cryptography/ECDSA.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title Elliptic Curve Digital Signature Algorithm (ECDSA) operations\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\n */\nlibrary ECDSA {\n    error ECDSA__InvalidS();\n    error ECDSA__InvalidSignature();\n    error ECDSA__InvalidSignatureLength();\n    error ECDSA__InvalidV();\n\n    /**\n     * @notice recover signer of hashed message from signature\n     * @param hash hashed data payload\n     * @param signature signed data payload\n     * @return recovered message signer\n     */\n    function recover(\n        bytes32 hash,\n        bytes memory signature\n    ) internal pure returns (address) {\n        if (signature.length != 65) revert ECDSA__InvalidSignatureLength();\n\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n\n        return recover(hash, v, r, s);\n    }\n\n    /**\n     * @notice recover signer of hashed message from signature v, r, and s values\n     * @param hash hashed data payload\n     * @param v signature \"v\" value\n     * @param r signature \"r\" value\n     * @param s signature \"s\" value\n     * @return recovered message signer\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n  2 + 1, and for v in (282): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (\n            uint256(s) >\n            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0\n        ) revert ECDSA__InvalidS();\n        if (v != 27 && v != 28) revert ECDSA__InvalidV();\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) revert ECDSA__InvalidSignature();\n\n        return signer;\n    }\n\n    /**\n     * @notice generate an \"Ethereum Signed Message\" in the format returned by the eth_sign JSON-RPC method\n     * @param hash hashed data payload\n     * @return signed message hash\n     */\n    function toEthSignedMessageHash(\n        bytes32 hash\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked('\\x19Ethereum Signed Message:\\n32', hash)\n            );\n    }\n}\n"},"@solidstate/contracts/token/ERC20/base/IERC20BaseInternal.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC20Internal } from '../../../interfaces/IERC20Internal.sol';\n\n/**\n * @title ERC20 base interface\n */\ninterface IERC20BaseInternal is IERC20Internal {\n    error ERC20Base__ApproveFromZeroAddress();\n    error ERC20Base__ApproveToZeroAddress();\n    error ERC20Base__BurnExceedsBalance();\n    error ERC20Base__BurnFromZeroAddress();\n    error ERC20Base__InsufficientAllowance();\n    error ERC20Base__MintToZeroAddress();\n    error ERC20Base__TransferExceedsBalance();\n    error ERC20Base__TransferFromZeroAddress();\n    error ERC20Base__TransferToZeroAddress();\n}\n"},"contracts/layerZero/lzApp/LzApp.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport {OwnableInternal} from \"@solidstate/contracts/access/ownable/OwnableInternal.sol\";\r\n\r\nimport {ILayerZeroReceiver} from \"../interfaces/ILayerZeroReceiver.sol\";\r\nimport {ILayerZeroUserApplicationConfig} from \"../interfaces/ILayerZeroUserApplicationConfig.sol\";\r\nimport {ILayerZeroEndpoint} from \"../interfaces/ILayerZeroEndpoint.sol\";\r\nimport {LzAppStorage} from \"./LzAppStorage.sol\";\r\nimport {BytesLib} from \"../util/BytesLib.sol\";\r\n\r\n/*\r\n * a generic LzReceiver implementation\r\n */\r\nabstract contract LzApp is\r\n    OwnableInternal,\r\n    ILayerZeroReceiver,\r\n    ILayerZeroUserApplicationConfig\r\n{\r\n    using BytesLib for bytes;\r\n\r\n    ILayerZeroEndpoint public immutable lzEndpoint;\r\n\r\n    //    event SetPrecrime(address precrime);\r\n    event SetTrustedRemoteAddress(uint16 _remoteChainId, bytes _remoteAddress);\r\n\r\n    error LzApp__InvalidEndpointCaller();\r\n    error LzApp__InvalidSource();\r\n    error LzApp__NotTrustedSource();\r\n    error LzApp__NoTrustedPathRecord();\r\n\r\n    constructor(address endpoint) {\r\n        lzEndpoint = ILayerZeroEndpoint(endpoint);\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc ILayerZeroReceiver\r\n     */\r\n    function lzReceive(\r\n        uint16 srcChainId,\r\n        bytes memory srcAddress,\r\n        uint64 nonce,\r\n        bytes memory payload\r\n    ) public virtual {\r\n        // lzReceive must be called by the endpoint for security\r\n        if (msg.sender != address(lzEndpoint))\r\n            revert LzApp__InvalidEndpointCaller();\r\n\r\n        // if will still block the message pathway from (srcChainId, srcAddress). should not receive message from untrusted remote.\r\n        if (!_isTrustedRemote(srcChainId, srcAddress))\r\n            revert LzApp__InvalidSource();\r\n\r\n        _blockingLzReceive(srcChainId, srcAddress, nonce, payload);\r\n    }\r\n\r\n    // abstract function - the default behaviour of LayerZero is blocking. See: NonblockingLzApp if you dont need to enforce ordered messaging\r\n    function _blockingLzReceive(\r\n        uint16 srcChainId,\r\n        bytes memory srcAddress,\r\n        uint64 nonce,\r\n        bytes memory payload\r\n    ) internal virtual;\r\n\r\n    function _lzSend(\r\n        uint16 dstChainId,\r\n        bytes memory payload,\r\n        address payable refundAddress,\r\n        address zroPaymentAddress,\r\n        bytes memory adapterParams,\r\n        uint256 nativeFee\r\n    ) internal virtual {\r\n        bytes memory trustedRemote = LzAppStorage.layout().trustedRemote[\r\n            dstChainId\r\n        ];\r\n        if (trustedRemote.length == 0) revert LzApp__NotTrustedSource();\r\n        lzEndpoint.send{value: nativeFee}(\r\n            dstChainId,\r\n            trustedRemote,\r\n            payload,\r\n            refundAddress,\r\n            zroPaymentAddress,\r\n            adapterParams\r\n        );\r\n    }\r\n\r\n    //---------------------------UserApplication config----------------------------------------\r\n    function getConfig(\r\n        uint16 version,\r\n        uint16 chainId,\r\n        address,\r\n        uint256 configType\r\n    ) external view returns (bytes memory) {\r\n        return\r\n            lzEndpoint.getConfig(version, chainId, address(this), configType);\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc ILayerZeroUserApplicationConfig\r\n     */\r\n    function setConfig(\r\n        uint16 version,\r\n        uint16 chainId,\r\n        uint256 configType,\r\n        bytes calldata config\r\n    ) external onlyOwner {\r\n        lzEndpoint.setConfig(version, chainId, configType, config);\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc ILayerZeroUserApplicationConfig\r\n     */\r\n    function setSendVersion(uint16 version) external onlyOwner {\r\n        lzEndpoint.setSendVersion(version);\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc ILayerZeroUserApplicationConfig\r\n     */\r\n    function setReceiveVersion(uint16 version) external onlyOwner {\r\n        lzEndpoint.setReceiveVersion(version);\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc ILayerZeroUserApplicationConfig\r\n     */\r\n    function forceResumeReceive(\r\n        uint16 srcChainId,\r\n        bytes calldata srcAddress\r\n    ) external onlyOwner {\r\n        lzEndpoint.forceResumeReceive(srcChainId, srcAddress);\r\n    }\r\n\r\n    function setTrustedRemoteAddress(\r\n        uint16 remoteChainId,\r\n        bytes calldata remoteAddress\r\n    ) external onlyOwner {\r\n        LzAppStorage.layout().trustedRemote[remoteChainId] = abi.encodePacked(\r\n            remoteAddress,\r\n            address(this)\r\n        );\r\n        emit SetTrustedRemoteAddress(remoteChainId, remoteAddress);\r\n    }\r\n\r\n    function getTrustedRemoteAddress(\r\n        uint16 _remoteChainId\r\n    ) external view returns (bytes memory) {\r\n        bytes memory path = LzAppStorage.layout().trustedRemote[_remoteChainId];\r\n        if (path.length == 0) revert LzApp__NoTrustedPathRecord();\r\n        return path.slice(0, path.length - 20); // the last 20 bytes should be address(this)\r\n    }\r\n\r\n    //    function setPrecrime(address _precrime) external onlyOwner {\r\n    //        LzAppStorage.layout().precrime = _precrime;\r\n    //        emit SetPrecrime(_precrime);\r\n    //    }\r\n\r\n    //--------------------------- VIEW FUNCTION ----------------------------------------\r\n\r\n    function isTrustedRemote(\r\n        uint16 srcChainId,\r\n        bytes memory srcAddress\r\n    ) external view returns (bool) {\r\n        return _isTrustedRemote(srcChainId, srcAddress);\r\n    }\r\n\r\n    function _isTrustedRemote(\r\n        uint16 srcChainId,\r\n        bytes memory srcAddress\r\n    ) internal view returns (bool) {\r\n        bytes memory trustedRemote = LzAppStorage.layout().trustedRemote[\r\n            srcChainId\r\n        ];\r\n\r\n        return\r\n            srcAddress.length == trustedRemote.length &&\r\n            trustedRemote.length > 0 &&\r\n            keccak256(trustedRemote) == keccak256(srcAddress);\r\n    }\r\n}\r\n"},"@solidstate/contracts/token/ERC20/permit/ERC20Permit.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.8;\n\nimport { ERC20Base } from '../base/ERC20Base.sol';\nimport { ERC20Metadata } from '../metadata/ERC20Metadata.sol';\nimport { ERC20PermitInternal } from './ERC20PermitInternal.sol';\nimport { ERC20PermitStorage } from './ERC20PermitStorage.sol';\nimport { IERC2612 } from './IERC2612.sol';\nimport { IERC20Permit } from './IERC20Permit.sol';\n\n/**\n * @title ERC20 extension with support for ERC2612 permits\n * @dev derived from https://github.com/soliditylabs/ERC20-Permit (MIT license)\n */\nabstract contract ERC20Permit is IERC20Permit, ERC20PermitInternal {\n    /**\n     * @inheritdoc IERC2612\n     */\n    function DOMAIN_SEPARATOR()\n        external\n        view\n        returns (bytes32 domainSeparator)\n    {\n        return _DOMAIN_SEPARATOR();\n    }\n\n    /**\n     * @inheritdoc IERC2612\n     */\n    function nonces(address owner) public view returns (uint256) {\n        return _nonces(owner);\n    }\n\n    /**\n     * @inheritdoc IERC2612\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        _permit(owner, spender, amount, deadline, v, r, s);\n    }\n}\n"},"@solidstate/contracts/token/ERC20/base/ERC20BaseInternal.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC20BaseInternal } from './IERC20BaseInternal.sol';\nimport { ERC20BaseStorage } from './ERC20BaseStorage.sol';\n\n/**\n * @title Base ERC20 internal functions, excluding optional extensions\n */\nabstract contract ERC20BaseInternal is IERC20BaseInternal {\n    /**\n     * @notice query the total minted token supply\n     * @return token supply\n     */\n    function _totalSupply() internal view virtual returns (uint256) {\n        return ERC20BaseStorage.layout().totalSupply;\n    }\n\n    /**\n     * @notice query the token balance of given account\n     * @param account address to query\n     * @return token balance\n     */\n    function _balanceOf(\n        address account\n    ) internal view virtual returns (uint256) {\n        return ERC20BaseStorage.layout().balances[account];\n    }\n\n    /**\n     * @notice query the allowance granted from given holder to given spender\n     * @param holder approver of allowance\n     * @param spender recipient of allowance\n     * @return token allowance\n     */\n    function _allowance(\n        address holder,\n        address spender\n    ) internal view virtual returns (uint256) {\n        return ERC20BaseStorage.layout().allowances[holder][spender];\n    }\n\n    /**\n     * @notice enable spender to spend tokens on behalf of holder\n     * @param holder address on whose behalf tokens may be spent\n     * @param spender recipient of allowance\n     * @param amount quantity of tokens approved for spending\n     * @return success status (always true; otherwise function should revert)\n     */\n    function _approve(\n        address holder,\n        address spender,\n        uint256 amount\n    ) internal virtual returns (bool) {\n        if (holder == address(0)) revert ERC20Base__ApproveFromZeroAddress();\n        if (spender == address(0)) revert ERC20Base__ApproveToZeroAddress();\n\n        ERC20BaseStorage.layout().allowances[holder][spender] = amount;\n\n        emit Approval(holder, spender, amount);\n\n        return true;\n    }\n\n    /**\n     * @notice decrease spend amount granted by holder to spender\n     * @param holder address on whose behalf tokens may be spent\n     * @param spender address whose allowance to decrease\n     * @param amount quantity by which to decrease allowance\n     */\n    function _decreaseAllowance(\n        address holder,\n        address spender,\n        uint256 amount\n    ) internal {\n        uint256 allowance = _allowance(holder, spender);\n\n        if (amount > allowance) revert ERC20Base__InsufficientAllowance();\n\n        unchecked {\n            _approve(holder, spender, allowance - amount);\n        }\n    }\n\n    /**\n     * @notice mint tokens for given account\n     * @param account recipient of minted tokens\n     * @param amount quantity of tokens minted\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        if (account == address(0)) revert ERC20Base__MintToZeroAddress();\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        ERC20BaseStorage.Layout storage l = ERC20BaseStorage.layout();\n        l.totalSupply += amount;\n        l.balances[account] += amount;\n\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @notice burn tokens held by given account\n     * @param account holder of burned tokens\n     * @param amount quantity of tokens burned\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        if (account == address(0)) revert ERC20Base__BurnFromZeroAddress();\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        ERC20BaseStorage.Layout storage l = ERC20BaseStorage.layout();\n        uint256 balance = l.balances[account];\n        if (amount > balance) revert ERC20Base__BurnExceedsBalance();\n        unchecked {\n            l.balances[account] = balance - amount;\n        }\n        l.totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @notice transfer tokens from holder to recipient\n     * @param holder owner of tokens to be transferred\n     * @param recipient beneficiary of transfer\n     * @param amount quantity of tokens transferred\n     * @return success status (always true; otherwise function should revert)\n     */\n    function _transfer(\n        address holder,\n        address recipient,\n        uint256 amount\n    ) internal virtual returns (bool) {\n        if (holder == address(0)) revert ERC20Base__TransferFromZeroAddress();\n        if (recipient == address(0)) revert ERC20Base__TransferToZeroAddress();\n\n        _beforeTokenTransfer(holder, recipient, amount);\n\n        ERC20BaseStorage.Layout storage l = ERC20BaseStorage.layout();\n        uint256 holderBalance = l.balances[holder];\n        if (amount > holderBalance) revert ERC20Base__TransferExceedsBalance();\n        unchecked {\n            l.balances[holder] = holderBalance - amount;\n        }\n        l.balances[recipient] += amount;\n\n        emit Transfer(holder, recipient, amount);\n\n        return true;\n    }\n\n    /**\n     * @notice transfer tokens to given recipient on behalf of given holder\n     * @param holder holder of tokens prior to transfer\n     * @param recipient beneficiary of token transfer\n     * @param amount quantity of tokens to transfer\n     * @return success status (always true; otherwise function should revert)\n     */\n    function _transferFrom(\n        address holder,\n        address recipient,\n        uint256 amount\n    ) internal virtual returns (bool) {\n        _decreaseAllowance(holder, msg.sender, amount);\n\n        _transfer(holder, recipient, amount);\n\n        return true;\n    }\n\n    /**\n     * @notice ERC20 hook, called before all transfers including mint and burn\n     * @dev function should be overridden and new implementation must call super\n     * @param from sender of tokens\n     * @param to receiver of tokens\n     * @param amount quantity of tokens transferred\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"},"@solidstate/contracts/interfaces/IERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC165Internal } from './IERC165Internal.sol';\n\n/**\n * @title ERC165 interface registration interface\n * @dev see https://eips.ethereum.org/EIPS/eip-165\n */\ninterface IERC165 is IERC165Internal {\n    /**\n     * @notice query whether contract has registered support for given interface\n     * @param interfaceId interface id\n     * @return bool whether interface is supported\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"},"contracts/layerZero/util/ExcessivelySafeCall.sol":{"content":"// SPDX-License-Identifier: MIT OR Apache-2.0\r\npragma solidity >=0.7.6;\r\n\r\nlibrary ExcessivelySafeCall {\r\n    uint256 constant LOW_28_MASK =\r\n        0x00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\r\n\r\n    /// @notice Use when you _really_ really _really_ don't trust the called\r\n    /// contract. This prevents the called contract from causing reversion of\r\n    /// the caller in as many ways as we can.\r\n    /// @dev The main difference between this and a solidity low-level call is\r\n    /// that we limit the number of bytes that the callee can cause to be\r\n    /// copied to caller memory. This prevents stupid things like malicious\r\n    /// contracts returning 10,000,000 bytes causing a local OOG when copying\r\n    /// to memory.\r\n    /// @param _target The address to call\r\n    /// @param _gas The amount of gas to forward to the remote contract\r\n    /// @param _maxCopy The maximum number of bytes of returndata to copy\r\n    /// to memory.\r\n    /// @param _calldata The data to send to the remote contract\r\n    /// @return success and returndata, as `.call()`. Returndata is capped to\r\n    /// `_maxCopy` bytes.\r\n    function excessivelySafeCall(\r\n        address _target,\r\n        uint256 _gas,\r\n        uint16 _maxCopy,\r\n        bytes memory _calldata\r\n    ) internal returns (bool, bytes memory) {\r\n        // set up for assembly call\r\n        uint256 _toCopy;\r\n        bool _success;\r\n        bytes memory _returnData = new bytes(_maxCopy);\r\n        // dispatch message to recipient\r\n        // by assembly calling \"handle\" function\r\n        // we call via assembly to avoid memcopying a very large returndata\r\n        // returned by a malicious contract\r\n        assembly {\r\n            _success := call(\r\n                _gas, // gas\r\n                _target, // recipient\r\n                0, // ether value\r\n                add(_calldata, 0x20), // inloc\r\n                mload(_calldata), // inlen\r\n                0, // outloc\r\n                0 // outlen\r\n            )\r\n            // limit our copy to 256 bytes\r\n            _toCopy := returndatasize()\r\n            if gt(_toCopy, _maxCopy) {\r\n                _toCopy := _maxCopy\r\n            }\r\n            // Store the length of the copied bytes\r\n            mstore(_returnData, _toCopy)\r\n            // copy the bytes from returndata[0:_toCopy]\r\n            returndatacopy(add(_returnData, 0x20), 0, _toCopy)\r\n        }\r\n        return (_success, _returnData);\r\n    }\r\n\r\n    /// @notice Use when you _really_ really _really_ don't trust the called\r\n    /// contract. This prevents the called contract from causing reversion of\r\n    /// the caller in as many ways as we can.\r\n    /// @dev The main difference between this and a solidity low-level call is\r\n    /// that we limit the number of bytes that the callee can cause to be\r\n    /// copied to caller memory. This prevents stupid things like malicious\r\n    /// contracts returning 10,000,000 bytes causing a local OOG when copying\r\n    /// to memory.\r\n    /// @param _target The address to call\r\n    /// @param _gas The amount of gas to forward to the remote contract\r\n    /// @param _maxCopy The maximum number of bytes of returndata to copy\r\n    /// to memory.\r\n    /// @param _calldata The data to send to the remote contract\r\n    /// @return success and returndata, as `.call()`. Returndata is capped to\r\n    /// `_maxCopy` bytes.\r\n    function excessivelySafeStaticCall(\r\n        address _target,\r\n        uint256 _gas,\r\n        uint16 _maxCopy,\r\n        bytes memory _calldata\r\n    ) internal view returns (bool, bytes memory) {\r\n        // set up for assembly call\r\n        uint256 _toCopy;\r\n        bool _success;\r\n        bytes memory _returnData = new bytes(_maxCopy);\r\n        // dispatch message to recipient\r\n        // by assembly calling \"handle\" function\r\n        // we call via assembly to avoid memcopying a very large returndata\r\n        // returned by a malicious contract\r\n        assembly {\r\n            _success := staticcall(\r\n                _gas, // gas\r\n                _target, // recipient\r\n                add(_calldata, 0x20), // inloc\r\n                mload(_calldata), // inlen\r\n                0, // outloc\r\n                0 // outlen\r\n            )\r\n            // limit our copy to 256 bytes\r\n            _toCopy := returndatasize()\r\n            if gt(_toCopy, _maxCopy) {\r\n                _toCopy := _maxCopy\r\n            }\r\n            // Store the length of the copied bytes\r\n            mstore(_returnData, _toCopy)\r\n            // copy the bytes from returndata[0:_toCopy]\r\n            returndatacopy(add(_returnData, 0x20), 0, _toCopy)\r\n        }\r\n        return (_success, _returnData);\r\n    }\r\n\r\n    /**\r\n     * @notice Swaps function selectors in encoded contract calls\r\n     * @dev Allows reuse of encoded calldata for functions with identical\r\n     * argument types but different names. It simply swaps out the first 4 bytes\r\n     * for the new selector. This function modifies memory in place, and should\r\n     * only be used with caution.\r\n     * @param _newSelector The new 4-byte selector\r\n     * @param _buf The encoded contract args\r\n     */\r\n    function swapSelector(\r\n        bytes4 _newSelector,\r\n        bytes memory _buf\r\n    ) internal pure {\r\n        require(_buf.length >= 4);\r\n        uint256 _mask = LOW_28_MASK;\r\n        assembly {\r\n            // load the first word of\r\n            let _word := mload(add(_buf, 0x20))\r\n            // mask out the top 4 bytes\r\n            // /x\r\n            _word := and(_word, _mask)\r\n            _word := or(_newSelector, _word)\r\n            mstore(add(_buf, 0x20), _word)\r\n        }\r\n    }\r\n}\r\n"},"@solidstate/contracts/introspection/ERC165/base/ERC165Base.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC165 } from '../../../interfaces/IERC165.sol';\nimport { IERC165Base } from './IERC165Base.sol';\nimport { ERC165BaseInternal } from './ERC165BaseInternal.sol';\nimport { ERC165BaseStorage } from './ERC165BaseStorage.sol';\n\n/**\n * @title ERC165 implementation\n */\nabstract contract ERC165Base is IERC165Base, ERC165BaseInternal {\n    /**\n     * @inheritdoc IERC165\n     */\n    function supportsInterface(bytes4 interfaceId) public view returns (bool) {\n        return _supportsInterface(interfaceId);\n    }\n}\n"},"contracts/layerZero/token/oft/OFT.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {ERC20Base, ERC20BaseStorage} from \"@solidstate/contracts/token/ERC20/base/ERC20Base.sol\";\nimport {SolidStateERC20} from \"@solidstate/contracts/token/ERC20/SolidStateERC20.sol\";\nimport {IERC20} from \"@solidstate/contracts/interfaces/IERC20.sol\";\nimport {IERC165} from \"@solidstate/contracts/interfaces/IERC165.sol\";\n\nimport {OFTCore} from \"./OFTCore.sol\";\nimport {IOFT} from \"./IOFT.sol\";\n\n// override decimal() function is needed\ncontract OFT is OFTCore, SolidStateERC20, IOFT {\n    constructor(address lzEndpoint) OFTCore(lzEndpoint) {}\n\n    function circulatingSupply()\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _totalSupply();\n    }\n\n    function _debitFrom(\n        address from,\n        uint16,\n        bytes memory,\n        uint256 amount\n    ) internal virtual override {\n        address spender = msg.sender;\n\n        if (from != spender) {\n            unchecked {\n                mapping(address => uint256)\n                    storage allowances = ERC20BaseStorage.layout().allowances[\n                        from\n                    ];\n\n                uint256 allowance = allowances[spender];\n                if (amount > allowance) revert OFT_InsufficientAllowance();\n\n                _approve(\n                    from,\n                    spender,\n                    allowances[spender] = allowance - amount\n                );\n            }\n        }\n\n        _burn(from, amount);\n    }\n\n    function _creditTo(\n        uint16,\n        address toAddress,\n        uint256 amount\n    ) internal virtual override {\n        _mint(toAddress, amount);\n    }\n}\n"},"contracts/staking/VxPremiaStorage.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\r\n// For further clarification please see https://license.premia.legal\r\n\r\npragma solidity ^0.8.0;\r\n\r\nlibrary VxPremiaStorage {\r\n    bytes32 internal constant STORAGE_SLOT =\r\n        keccak256(\"premia.contracts.staking.VxPremia\");\r\n\r\n    enum VoteVersion {\r\n        V2 // poolAddress : 20 bytes / isCallPool : 2 bytes\r\n    }\r\n\r\n    struct Vote {\r\n        uint256 amount;\r\n        VoteVersion version;\r\n        bytes target;\r\n    }\r\n\r\n    struct Layout {\r\n        mapping(address => Vote[]) userVotes;\r\n        // Vote version -> Pool identifier -> Vote amount\r\n        mapping(VoteVersion => mapping(bytes => uint256)) votes;\r\n    }\r\n\r\n    function layout() internal pure returns (Layout storage l) {\r\n        bytes32 slot = STORAGE_SLOT;\r\n        assembly {\r\n            l.slot := slot\r\n        }\r\n    }\r\n}\r\n"},"contracts/layerZero/token/oft/IOFTCore.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport {IERC20} from \"@solidstate/contracts/interfaces/IERC20.sol\";\r\nimport {IERC165} from \"@solidstate/contracts/interfaces/IERC165.sol\";\r\n\r\n/**\r\n * @dev Interface of the IOFT core standard\r\n */\r\ninterface IOFTCore is IERC165 {\r\n    /**\r\n     * @dev estimate send token `tokenId` to (`dstChainId`, `toAddress`)\r\n     * dstChainId - L0 defined chain id to send tokens too\r\n     * toAddress - dynamic bytes array which contains the address to whom you are sending tokens to on the dstChain\r\n     * amount - amount of the tokens to transfer\r\n     * useZro - indicates to use zro to pay L0 fees\r\n     * adapterParam - flexible bytes array to indicate messaging adapter services in L0\r\n     */\r\n    function estimateSendFee(\r\n        uint16 dstChainId,\r\n        bytes calldata toAddress,\r\n        uint256 amount,\r\n        bool useZro,\r\n        bytes calldata adapterParams\r\n    ) external view returns (uint256 nativeFee, uint256 zroFee);\r\n\r\n    /**\r\n     * @dev send `amount` amount of token to (`dstChainId`, `toAddress`) from `from`\r\n     * `from` the owner of token\r\n     * `dstChainId` the destination chain identifier\r\n     * `toAddress` can be any size depending on the `dstChainId`.\r\n     * `amount` the quantity of tokens in wei\r\n     * `refundAddress` the address LayerZero refunds if too much message fee is sent\r\n     * `zroPaymentAddress` set to address(0x0) if not paying in ZRO (LayerZero Token)\r\n     * `adapterParams` is a flexible bytes array to indicate messaging adapter services\r\n     */\r\n    function sendFrom(\r\n        address from,\r\n        uint16 dstChainId,\r\n        bytes calldata toAddress,\r\n        uint256 amount,\r\n        address payable refundAddress,\r\n        address zroPaymentAddress,\r\n        bytes calldata adapterParams\r\n    ) external payable;\r\n\r\n    /**\r\n     * @dev returns the circulating amount of tokens on current chain\r\n     */\r\n    function circulatingSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Emitted when `amount` tokens are moved from the `sender` to (`dstChainId`, `toAddress`)\r\n     * `nonce` is the outbound nonce\r\n     */\r\n    event SendToChain(\r\n        address indexed sender,\r\n        uint16 indexed dstChainId,\r\n        bytes indexed toAddress,\r\n        uint256 amount\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when `amount` tokens are received from `srcChainId` into the `toAddress` on the local chain.\r\n     * `nonce` is the inbound nonce.\r\n     */\r\n    event ReceiveFromChain(\r\n        uint16 indexed srcChainId,\r\n        bytes indexed srcAddress,\r\n        address indexed toAddress,\r\n        uint256 amount\r\n    );\r\n\r\n    event SetUseCustomAdapterParams(bool _useCustomAdapterParams);\r\n}\r\n"},"@solidstate/contracts/token/ERC20/extended/ERC20ExtendedInternal.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { ERC20BaseInternal, ERC20BaseStorage } from '../base/ERC20Base.sol';\nimport { IERC20ExtendedInternal } from './IERC20ExtendedInternal.sol';\n\n/**\n * @title ERC20 safe approval extensions\n * @dev mitigations for transaction-ordering vulnerability (see https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729)\n */\nabstract contract ERC20ExtendedInternal is\n    ERC20BaseInternal,\n    IERC20ExtendedInternal\n{\n    /**\n     * @notice increase spend amount granted to spender\n     * @param spender address whose allowance to increase\n     * @param amount quantity by which to increase allowance\n     * @return success status (always true; otherwise function will revert)\n     */\n    function _increaseAllowance(\n        address spender,\n        uint256 amount\n    ) internal virtual returns (bool) {\n        uint256 allowance = _allowance(msg.sender, spender);\n\n        unchecked {\n            if (allowance > allowance + amount)\n                revert ERC20Extended__ExcessiveAllowance();\n\n            return _approve(msg.sender, spender, allowance + amount);\n        }\n    }\n\n    /**\n     * @notice decrease spend amount granted to spender\n     * @param spender address whose allowance to decrease\n     * @param amount quantity by which to decrease allowance\n     * @return success status (always true; otherwise function will revert)\n     */\n    function _decreaseAllowance(\n        address spender,\n        uint256 amount\n    ) internal virtual returns (bool) {\n        _decreaseAllowance(msg.sender, spender, amount);\n\n        return true;\n    }\n}\n"},"@solidstate/contracts/introspection/ERC165/base/IERC165BaseInternal.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC165Internal } from '../../../interfaces/IERC165Internal.sol';\n\ninterface IERC165BaseInternal is IERC165Internal {\n    error ERC165Base__InvalidInterfaceId();\n}\n"},"contracts/staking/VxPremia.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\r\n// For further clarification please see https://license.premia.legal\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport {PremiaStaking} from \"./PremiaStaking.sol\";\r\nimport {PremiaStakingStorage} from \"./PremiaStakingStorage.sol\";\r\nimport {VxPremiaStorage} from \"./VxPremiaStorage.sol\";\r\nimport {IVxPremia} from \"./IVxPremia.sol\";\r\n\r\nimport {IProxyManager} from \"../core/IProxyManager.sol\";\r\n\r\n/**\r\n * @author Premia\r\n * @title A contract allowing you to use your locked Premia as voting power for mining weights\r\n */\r\ncontract VxPremia is IVxPremia, PremiaStaking {\r\n    address private immutable PROXY_MANAGER;\r\n\r\n    constructor(\r\n        address proxyManager,\r\n        address lzEndpoint,\r\n        address premia,\r\n        address rewardToken,\r\n        address exchangeHelper\r\n    ) PremiaStaking(lzEndpoint, premia, rewardToken, exchangeHelper) {\r\n        PROXY_MANAGER = proxyManager;\r\n    }\r\n\r\n    function _beforeUnstake(address user, uint256 amount) internal override {\r\n        uint256 votingPowerUnstaked = _calculateUserPower(\r\n            amount,\r\n            PremiaStakingStorage.layout().userInfo[user].stakePeriod\r\n        );\r\n\r\n        _subtractExtraUserVotes(\r\n            VxPremiaStorage.layout(),\r\n            user,\r\n            votingPowerUnstaked\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice subtract user votes, starting from the end of the list, if not enough voting power is left after amountUnstaked is unstaked\r\n     */\r\n    function _subtractExtraUserVotes(\r\n        VxPremiaStorage.Layout storage l,\r\n        address user,\r\n        uint256 amountUnstaked\r\n    ) internal {\r\n        uint256 votingPower = _calculateUserPower(\r\n            _balanceOf(user),\r\n            PremiaStakingStorage.layout().userInfo[user].stakePeriod\r\n        );\r\n        uint256 votingPowerUsed = _calculateUserVotingPowerUsed(user);\r\n        uint256 votingPowerLeftAfterUnstake = votingPower - amountUnstaked;\r\n\r\n        unchecked {\r\n            if (votingPowerUsed > votingPowerLeftAfterUnstake) {\r\n                _subtractUserVotes(\r\n                    l,\r\n                    user,\r\n                    votingPowerUsed - votingPowerLeftAfterUnstake\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice subtract user votes, starting from the end of the list\r\n     */\r\n    function _subtractUserVotes(\r\n        VxPremiaStorage.Layout storage l,\r\n        address user,\r\n        uint256 amount\r\n    ) internal {\r\n        VxPremiaStorage.Vote[] storage userVotes = l.userVotes[user];\r\n\r\n        unchecked {\r\n            for (uint256 i = userVotes.length; i > 0; ) {\r\n                VxPremiaStorage.Vote memory vote = userVotes[--i];\r\n\r\n                uint256 votesRemoved;\r\n\r\n                if (amount < vote.amount) {\r\n                    votesRemoved = amount;\r\n                    userVotes[i].amount -= amount;\r\n                } else {\r\n                    votesRemoved = vote.amount;\r\n                    userVotes.pop();\r\n                }\r\n\r\n                amount -= votesRemoved;\r\n\r\n                l.votes[vote.version][vote.target] -= votesRemoved;\r\n                emit RemoveVote(user, vote.version, vote.target, votesRemoved);\r\n\r\n                if (amount == 0) break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _calculateUserVotingPowerUsed(\r\n        address user\r\n    ) internal view returns (uint256 votingPowerUsed) {\r\n        VxPremiaStorage.Vote[] memory userVotes = VxPremiaStorage\r\n            .layout()\r\n            .userVotes[user];\r\n\r\n        unchecked {\r\n            for (uint256 i = 0; i < userVotes.length; i++) {\r\n                votingPowerUsed += userVotes[i].amount;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IVxPremia\r\n     */\r\n    function getPoolVotes(\r\n        VxPremiaStorage.VoteVersion version,\r\n        bytes memory target\r\n    ) external view returns (uint256) {\r\n        return VxPremiaStorage.layout().votes[version][target];\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IVxPremia\r\n     */\r\n    function getUserVotes(\r\n        address user\r\n    ) external view returns (VxPremiaStorage.Vote[] memory) {\r\n        return VxPremiaStorage.layout().userVotes[user];\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IVxPremia\r\n     */\r\n    function castVotes(VxPremiaStorage.Vote[] memory votes) external {\r\n        VxPremiaStorage.Layout storage l = VxPremiaStorage.layout();\r\n\r\n        uint256 userVotingPower = _calculateUserPower(\r\n            _balanceOf(msg.sender),\r\n            PremiaStakingStorage.layout().userInfo[msg.sender].stakePeriod\r\n        );\r\n\r\n        VxPremiaStorage.Vote[] storage userVotes = l.userVotes[msg.sender];\r\n\r\n        // Remove previous votes\r\n        _resetUserVotes(l, userVotes, msg.sender);\r\n\r\n        address[] memory poolList = IProxyManager(PROXY_MANAGER).getPoolList();\r\n\r\n        // Cast new votes\r\n        uint256 votingPowerUsed = 0;\r\n        for (uint256 i = 0; i < votes.length; i++) {\r\n            VxPremiaStorage.Vote memory vote = votes[i];\r\n\r\n            votingPowerUsed += vote.amount;\r\n            if (votingPowerUsed > userVotingPower)\r\n                revert VxPremia__NotEnoughVotingPower();\r\n\r\n            // abi.encodePacked on [address, bool] uses 20 bytes for the address and 1 byte for the bool\r\n            if (\r\n                vote.version != VxPremiaStorage.VoteVersion.V2 ||\r\n                vote.target.length != 21\r\n            ) revert VxPremia__InvalidVoteTarget();\r\n\r\n            // Check that the pool address is valid\r\n            address contractAddress = address(\r\n                uint160(uint256(bytes32(vote.target)) >> 96) // We need to shift by 96, as we want the 160 most significant bits, which are the pool address\r\n            );\r\n\r\n            bool isValid = false;\r\n            for (uint256 j = 0; j < poolList.length; j++) {\r\n                if (contractAddress == poolList[j]) {\r\n                    isValid = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (isValid == false) revert VxPremia__InvalidPoolAddress();\r\n\r\n            userVotes.push(vote);\r\n            l.votes[vote.version][vote.target] += vote.amount;\r\n\r\n            emit AddVote(msg.sender, vote.version, vote.target, vote.amount);\r\n        }\r\n    }\r\n\r\n    function _resetUserVotes(\r\n        VxPremiaStorage.Layout storage l,\r\n        VxPremiaStorage.Vote[] storage userVotes,\r\n        address user\r\n    ) internal {\r\n        for (uint256 i = userVotes.length; i > 0; ) {\r\n            VxPremiaStorage.Vote memory vote = userVotes[--i];\r\n\r\n            l.votes[vote.version][vote.target] -= vote.amount;\r\n            emit RemoveVote(user, vote.version, vote.target, vote.amount);\r\n\r\n            userVotes.pop();\r\n        }\r\n    }\r\n\r\n    function resetUserVotes(address user) external onlyOwner {\r\n        VxPremiaStorage.Layout storage l = VxPremiaStorage.layout();\r\n        VxPremiaStorage.Vote[] storage userVotes = l.userVotes[user];\r\n        _resetUserVotes(l, userVotes, user);\r\n    }\r\n}\r\n"},"contracts/layerZero/lzApp/NonblockingLzAppStorage.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nlibrary NonblockingLzAppStorage {\r\n    bytes32 internal constant STORAGE_SLOT =\r\n        keccak256(\"premia.contracts.storage.NonblockingLzApp\");\r\n\r\n    struct Layout {\r\n        mapping(uint16 => mapping(bytes => mapping(uint64 => bytes32))) failedMessages;\r\n    }\r\n\r\n    function layout() internal pure returns (Layout storage l) {\r\n        bytes32 slot = STORAGE_SLOT;\r\n        assembly {\r\n            l.slot := slot\r\n        }\r\n    }\r\n}\r\n"},"contracts/layerZero/lzApp/LzAppStorage.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nlibrary LzAppStorage {\r\n    bytes32 internal constant STORAGE_SLOT =\r\n        keccak256(\"premia.contracts.storage.LzApp\");\r\n\r\n    struct Layout {\r\n        mapping(uint16 => bytes) trustedRemote;\r\n        address precrime;\r\n    }\r\n\r\n    function layout() internal pure returns (Layout storage l) {\r\n        bytes32 slot = STORAGE_SLOT;\r\n        assembly {\r\n            l.slot := slot\r\n        }\r\n    }\r\n}\r\n"},"@solidstate/contracts/utils/Math.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nlibrary Math {\n    /**\n     * @notice calculate the absolute value of a number\n     * @param a number whose absoluve value to calculate\n     * @return absolute value\n     */\n    function abs(int256 a) internal pure returns (uint256) {\n        return uint256(a < 0 ? -a : a);\n    }\n\n    /**\n     * @notice select the greater of two numbers\n     * @param a first number\n     * @param b second number\n     * @return greater number\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @notice select the lesser of two numbers\n     * @param a first number\n     * @param b second number\n     * @return lesser number\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? b : a;\n    }\n\n    /**\n     * @notice calculate the average of two numbers, rounded down\n     * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\n     * @param a first number\n     * @param b second number\n     * @return mean value\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            return (a & b) + ((a ^ b) >> 1);\n        }\n    }\n\n    /**\n     * @notice estimate square root of number\n     * @dev uses Babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\n     * @param x input number\n     * @return y square root\n     */\n    function sqrt(uint256 x) internal pure returns (uint256 y) {\n        uint256 z = (x + 1) >> 1;\n        y = x;\n        while (z < y) {\n            y = z;\n            z = (x / z + z) >> 1;\n        }\n    }\n}\n"},"contracts/interfaces/IExchangeHelper.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-or-later\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title Premia Exchange Helper\r\n * @dev deployed standalone and referenced by internal functions\r\n * @dev do NOT set approval to this contract!\r\n */\r\ninterface IExchangeHelper {\r\n    /**\r\n     * @notice perform arbitrary swap transaction\r\n     * @param sourceToken source token to pull into this address\r\n     * @param targetToken target token to buy\r\n     * @param sourceTokenAmount amount of source token to start the trade\r\n     * @param callee exchange address to call to execute the trade.\r\n     * @param allowanceTarget address for which to set allowance for the trade\r\n     * @param data calldata to execute the trade\r\n     * @param refundAddress address that un-used source token goes to\r\n     * @return amountOut quantity of targetToken yielded by swap\r\n     */\r\n    function swapWithToken(\r\n        address sourceToken,\r\n        address targetToken,\r\n        uint256 sourceTokenAmount,\r\n        address callee,\r\n        address allowanceTarget,\r\n        bytes calldata data,\r\n        address refundAddress\r\n    ) external returns (uint256 amountOut);\r\n}\r\n"},"@solidstate/contracts/interfaces/IERC165Internal.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC165Internal } from './IERC165Internal.sol';\n\n/**\n * @title ERC165 interface registration interface\n */\ninterface IERC165Internal {\n\n}\n"},"@solidstate/contracts/interfaces/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC20Internal } from './IERC20Internal.sol';\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ninterface IERC20 is IERC20Internal {\n    /**\n     * @notice query the total minted token supply\n     * @return token supply\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @notice query the token balance of given account\n     * @param account address to query\n     * @return token balance\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @notice query the allowance granted from given holder to given spender\n     * @param holder approver of allowance\n     * @param spender recipient of allowance\n     * @return token allowance\n     */\n    function allowance(\n        address holder,\n        address spender\n    ) external view returns (uint256);\n\n    /**\n     * @notice grant approval to spender to spend tokens\n     * @dev prefer ERC20Extended functions to avoid transaction-ordering vulnerability (see https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729)\n     * @param spender recipient of allowance\n     * @param amount quantity of tokens approved for spending\n     * @return success status (always true; otherwise function should revert)\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @notice transfer tokens to given recipient\n     * @param recipient beneficiary of token transfer\n     * @param amount quantity of tokens to transfer\n     * @return success status (always true; otherwise function should revert)\n     */\n    function transfer(\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @notice transfer tokens to given recipient on behalf of given holder\n     * @param holder holder of tokens prior to transfer\n     * @param recipient beneficiary of token transfer\n     * @param amount quantity of tokens to transfer\n     * @return success status (always true; otherwise function should revert)\n     */\n    function transferFrom(\n        address holder,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n}\n"},"@solidstate/contracts/token/ERC20/permit/IERC20PermitInternal.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC2612Internal } from './IERC2612Internal.sol';\n\ninterface IERC20PermitInternal is IERC2612Internal {\n    error ERC20Permit__ExpiredDeadline();\n    error ERC20Permit__InvalidSignature();\n}\n"},"@solidstate/contracts/interfaces/IERC173.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC173Internal } from './IERC173Internal.sol';\n\n/**\n * @title Contract ownership standard interface\n * @dev see https://eips.ethereum.org/EIPS/eip-173\n */\ninterface IERC173 is IERC173Internal {\n    /**\n     * @notice get the ERC173 contract owner\n     * @return conrtact owner\n     */\n    function owner() external view returns (address);\n\n    /**\n     * @notice transfer contract ownership to new account\n     * @param account address of new owner\n     */\n    function transferOwnership(address account) external;\n}\n"},"@solidstate/contracts/token/ERC20/base/IERC20Base.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC20 } from '../../../interfaces/IERC20.sol';\nimport { IERC20BaseInternal } from './IERC20BaseInternal.sol';\n\n/**\n * @title ERC20 base interface\n */\ninterface IERC20Base is IERC20BaseInternal, IERC20 {\n\n}\n"},"@solidstate/contracts/token/ERC20/permit/IERC2612Internal.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\ninterface IERC2612Internal {}\n"},"contracts/layerZero/lzApp/NonblockingLzApp.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport {LzApp} from \"./LzApp.sol\";\r\nimport {NonblockingLzAppStorage} from \"./NonblockingLzAppStorage.sol\";\r\nimport {ExcessivelySafeCall} from \"../util/ExcessivelySafeCall.sol\";\r\n\r\n/*\r\n * the default LayerZero messaging behaviour is blocking, i.e. any failed message will block the channel\r\n * this abstract class try-catch all fail messages and store locally for future retry. hence, non-blocking\r\n * NOTE: if the srcAddress is not configured properly, it will still block the message pathway from (srcChainId, srcAddress)\r\n */\r\nabstract contract NonblockingLzApp is LzApp {\r\n    using ExcessivelySafeCall for address;\r\n\r\n    error NonblockingLzApp__CallerNotLzApp();\r\n    error NonblockingLzApp__InvalidPayload();\r\n    error NonblockingLzApp__NoStoredMessage();\r\n\r\n    constructor(address endpoint) LzApp(endpoint) {}\r\n\r\n    event MessageFailed(\r\n        uint16 srcChainId,\r\n        bytes srcAddress,\r\n        uint64 nonce,\r\n        bytes payload,\r\n        bytes reason\r\n    );\r\n    event RetryMessageSuccess(\r\n        uint16 srcChainId,\r\n        bytes srcAddress,\r\n        uint64 nonce,\r\n        bytes32 payloadHash\r\n    );\r\n\r\n    // overriding the virtual function in LzReceiver\r\n    function _blockingLzReceive(\r\n        uint16 srcChainId,\r\n        bytes memory srcAddress,\r\n        uint64 nonce,\r\n        bytes memory payload\r\n    ) internal virtual override {\r\n        (bool success, bytes memory reason) = address(this).excessivelySafeCall(\r\n            gasleft(),\r\n            150,\r\n            abi.encodeWithSelector(\r\n                this.nonblockingLzReceive.selector,\r\n                srcChainId,\r\n                srcAddress,\r\n                nonce,\r\n                payload\r\n            )\r\n        );\r\n        // try-catch all errors/exceptions\r\n        if (!success) {\r\n            NonblockingLzAppStorage.layout().failedMessages[srcChainId][\r\n                srcAddress\r\n            ][nonce] = keccak256(payload);\r\n            emit MessageFailed(srcChainId, srcAddress, nonce, payload, reason);\r\n        }\r\n    }\r\n\r\n    function nonblockingLzReceive(\r\n        uint16 srcChainId,\r\n        bytes memory srcAddress,\r\n        uint64 nonce,\r\n        bytes memory payload\r\n    ) public virtual {\r\n        // only internal transaction\r\n        if (msg.sender != address(this))\r\n            revert NonblockingLzApp__CallerNotLzApp();\r\n        _nonblockingLzReceive(srcChainId, srcAddress, nonce, payload);\r\n    }\r\n\r\n    // override this function\r\n    function _nonblockingLzReceive(\r\n        uint16 srcChainId,\r\n        bytes memory srcAddress,\r\n        uint64 nonce,\r\n        bytes memory payload\r\n    ) internal virtual;\r\n\r\n    function retryMessage(\r\n        uint16 srcChainId,\r\n        bytes memory srcAddress,\r\n        uint64 nonce,\r\n        bytes memory payload\r\n    ) public payable virtual {\r\n        NonblockingLzAppStorage.Layout storage l = NonblockingLzAppStorage\r\n            .layout();\r\n\r\n        // assert there is message to retry\r\n        bytes32 payloadHash = l.failedMessages[srcChainId][srcAddress][nonce];\r\n\r\n        if (payloadHash == bytes32(0))\r\n            revert NonblockingLzApp__NoStoredMessage();\r\n\r\n        if (keccak256(payload) != payloadHash)\r\n            revert NonblockingLzApp__InvalidPayload();\r\n\r\n        // clear the stored message\r\n        delete l.failedMessages[srcChainId][srcAddress][nonce];\r\n        // execute the message. revert if it fails again\r\n        _nonblockingLzReceive(srcChainId, srcAddress, nonce, payload);\r\n        emit RetryMessageSuccess(srcChainId, srcAddress, nonce, payloadHash);\r\n    }\r\n\r\n    function failedMessages(\r\n        uint16 srcChainId,\r\n        bytes memory srcAddress,\r\n        uint64 nonce\r\n    ) external view returns (bytes32) {\r\n        return\r\n            NonblockingLzAppStorage.layout().failedMessages[srcChainId][\r\n                srcAddress\r\n            ][nonce];\r\n    }\r\n}\r\n"},"@solidstate/contracts/token/ERC20/permit/IERC20Permit.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC20Metadata } from '../metadata/IERC20Metadata.sol';\nimport { IERC2612 } from './IERC2612.sol';\nimport { IERC20PermitInternal } from './IERC20PermitInternal.sol';\n\n// TODO: note that IERC20Metadata is needed for eth-permit library\n\ninterface IERC20Permit is IERC20PermitInternal, IERC2612 {\n\n}\n"},"@solidstate/contracts/token/ERC20/metadata/IERC20Metadata.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC20MetadataInternal } from './IERC20MetadataInternal.sol';\n\n/**\n * @title ERC20 metadata interface\n */\ninterface IERC20Metadata is IERC20MetadataInternal {\n    /**\n     * @notice return token name\n     * @return token name\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @notice return token symbol\n     * @return token symbol\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @notice return token decimals, generally used only for display purposes\n     * @return token decimals\n     */\n    function decimals() external view returns (uint8);\n}\n"},"@solidstate/contracts/utils/AddressUtils.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { UintUtils } from './UintUtils.sol';\n\nlibrary AddressUtils {\n    using UintUtils for uint256;\n\n    error AddressUtils__InsufficientBalance();\n    error AddressUtils__NotContract();\n    error AddressUtils__SendValueFailed();\n\n    function toString(address account) internal pure returns (string memory) {\n        return uint256(uint160(account)).toHexString(20);\n    }\n\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    function sendValue(address payable account, uint256 amount) internal {\n        (bool success, ) = account.call{ value: amount }('');\n        if (!success) revert AddressUtils__SendValueFailed();\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data\n    ) internal returns (bytes memory) {\n        return\n            functionCall(target, data, 'AddressUtils: failed low-level call');\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory error\n    ) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, error);\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return\n            functionCallWithValue(\n                target,\n                data,\n                value,\n                'AddressUtils: failed low-level call with value'\n            );\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory error\n    ) internal returns (bytes memory) {\n        if (value > address(this).balance)\n            revert AddressUtils__InsufficientBalance();\n        return _functionCallWithValue(target, data, value, error);\n    }\n\n    /**\n     * @notice execute arbitrary external call with limited gas usage and amount of copied return data\n     * @dev derived from https://github.com/nomad-xyz/ExcessivelySafeCall (MIT License)\n     * @param target recipient of call\n     * @param gasAmount gas allowance for call\n     * @param value native token value to include in call\n     * @param maxCopy maximum number of bytes to copy from return data\n     * @param data encoded call data\n     * @return success whether call is successful\n     * @return returnData copied return data\n     */\n    function excessivelySafeCall(\n        address target,\n        uint256 gasAmount,\n        uint256 value,\n        uint16 maxCopy,\n        bytes memory data\n    ) internal returns (bool success, bytes memory returnData) {\n        returnData = new bytes(maxCopy);\n\n        assembly {\n            // execute external call via assembly to avoid automatic copying of return data\n            success := call(\n                gasAmount,\n                target,\n                value,\n                add(data, 0x20),\n                mload(data),\n                0,\n                0\n            )\n\n            // determine whether to limit amount of data to copy\n            let toCopy := returndatasize()\n\n            if gt(toCopy, maxCopy) {\n                toCopy := maxCopy\n            }\n\n            // store the length of the copied bytes\n            mstore(returnData, toCopy)\n\n            // copy the bytes from returndata[0:toCopy]\n            returndatacopy(add(returnData, 0x20), 0, toCopy)\n        }\n    }\n\n    function _functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory error\n    ) private returns (bytes memory) {\n        if (!isContract(target)) revert AddressUtils__NotContract();\n\n        (bool success, bytes memory returnData) = target.call{ value: value }(\n            data\n        );\n\n        if (success) {\n            return returnData;\n        } else if (returnData.length > 0) {\n            assembly {\n                let returnData_size := mload(returnData)\n                revert(add(32, returnData), returnData_size)\n            }\n        } else {\n            revert(error);\n        }\n    }\n}\n"},"@solidstate/contracts/introspection/ERC165/base/ERC165BaseStorage.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nlibrary ERC165BaseStorage {\n    struct Layout {\n        mapping(bytes4 => bool) supportedInterfaces;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.ERC165Base');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"},"contracts/layerZero/util/BytesLib.sol":{"content":"// SPDX-License-Identifier: Unlicense\r\n/*\r\n * @title Solidity Bytes Arrays Utils\r\n * @author Gonalo S <goncalo.sa@consensys.net>\r\n *\r\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\r\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\r\n */\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\nlibrary BytesLib {\r\n    error BytesLib__Overflow();\r\n    error BytesLib__OutOfBounds();\r\n\r\n    function concat(\r\n        bytes memory _preBytes,\r\n        bytes memory _postBytes\r\n    ) internal pure returns (bytes memory) {\r\n        bytes memory tempBytes;\r\n\r\n        assembly {\r\n            // Get a location of some free memory and store it in tempBytes as\r\n            // Solidity does for memory variables.\r\n            tempBytes := mload(0x40)\r\n\r\n            // Store the length of the first bytes array at the beginning of\r\n            // the memory for tempBytes.\r\n            let length := mload(_preBytes)\r\n            mstore(tempBytes, length)\r\n\r\n            // Maintain a memory counter for the current write location in the\r\n            // temp bytes array by adding the 32 bytes for the array length to\r\n            // the starting location.\r\n            let mc := add(tempBytes, 0x20)\r\n            // Stop copying when the memory counter reaches the length of the\r\n            // first bytes array.\r\n            let end := add(mc, length)\r\n\r\n            for {\r\n                // Initialize a copy counter to the start of the _preBytes data,\r\n                // 32 bytes into its memory.\r\n                let cc := add(_preBytes, 0x20)\r\n            } lt(mc, end) {\r\n                // Increase both counters by 32 bytes each iteration.\r\n                mc := add(mc, 0x20)\r\n                cc := add(cc, 0x20)\r\n            } {\r\n                // Write the _preBytes data into the tempBytes memory 32 bytes\r\n                // at a time.\r\n                mstore(mc, mload(cc))\r\n            }\r\n\r\n            // Add the length of _postBytes to the current length of tempBytes\r\n            // and store it as the new length in the first 32 bytes of the\r\n            // tempBytes memory.\r\n            length := mload(_postBytes)\r\n            mstore(tempBytes, add(length, mload(tempBytes)))\r\n\r\n            // Move the memory counter back from a multiple of 0x20 to the\r\n            // actual end of the _preBytes data.\r\n            mc := end\r\n            // Stop copying when the memory counter reaches the new combined\r\n            // length of the arrays.\r\n            end := add(mc, length)\r\n\r\n            for {\r\n                let cc := add(_postBytes, 0x20)\r\n            } lt(mc, end) {\r\n                mc := add(mc, 0x20)\r\n                cc := add(cc, 0x20)\r\n            } {\r\n                mstore(mc, mload(cc))\r\n            }\r\n\r\n            // Update the free-memory pointer by padding our last write location\r\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\r\n            // next 32 byte block, then round down to the nearest multiple of\r\n            // 32. If the sum of the length of the two arrays is zero then add\r\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\r\n            mstore(\r\n                0x40,\r\n                and(\r\n                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),\r\n                    not(31) // Round down to the nearest 32 bytes.\r\n                )\r\n            )\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n\r\n    function concatStorage(\r\n        bytes storage _preBytes,\r\n        bytes memory _postBytes\r\n    ) internal {\r\n        assembly {\r\n            // Read the first 32 bytes of _preBytes storage, which is the length\r\n            // of the array. (We don't need to use the offset into the slot\r\n            // because arrays use the entire slot.)\r\n            let fslot := sload(_preBytes.slot)\r\n            // Arrays of 31 bytes or less have an even value in their slot,\r\n            // while longer arrays have an odd value. The actual length is\r\n            // the slot divided by two for odd values, and the lowest order\r\n            // byte divided by two for even values.\r\n            // If the slot is even, bitwise and the slot with 255 and divide by\r\n            // two to get the length. If the slot is odd, bitwise and the slot\r\n            // with -1 and divide by two.\r\n            let slength := div(\r\n                and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)),\r\n                2\r\n            )\r\n            let mlength := mload(_postBytes)\r\n            let newlength := add(slength, mlength)\r\n            // slength can contain both the length and contents of the array\r\n            // if length < 32 bytes so let's prepare for that\r\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\r\n            switch add(lt(slength, 32), lt(newlength, 32))\r\n            case 2 {\r\n                // Since the new array still fits in the slot, we just need to\r\n                // update the contents of the slot.\r\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\r\n                sstore(\r\n                    _preBytes.slot,\r\n                    // all the modifications to the slot are inside this\r\n                    // next block\r\n                    add(\r\n                        // we can just add to the slot contents because the\r\n                        // bytes we want to change are the LSBs\r\n                        fslot,\r\n                        add(\r\n                            mul(\r\n                                div(\r\n                                    // load the bytes from memory\r\n                                    mload(add(_postBytes, 0x20)),\r\n                                    // zero all bytes to the right\r\n                                    exp(0x100, sub(32, mlength))\r\n                                ),\r\n                                // and now shift left the number of bytes to\r\n                                // leave space for the length in the slot\r\n                                exp(0x100, sub(32, newlength))\r\n                            ),\r\n                            // increase length by the double of the memory\r\n                            // bytes length\r\n                            mul(mlength, 2)\r\n                        )\r\n                    )\r\n                )\r\n            }\r\n            case 1 {\r\n                // The stored value fits in the slot, but the combined value\r\n                // will exceed it.\r\n                // get the keccak hash to get the contents of the array\r\n                mstore(0x0, _preBytes.slot)\r\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\r\n\r\n                // save new length\r\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\r\n\r\n                // The contents of the _postBytes array start 32 bytes into\r\n                // the structure. Our first read should obtain the `submod`\r\n                // bytes that can fit into the unused space in the last word\r\n                // of the stored array. To get this, we read 32 bytes starting\r\n                // from `submod`, so the data we read overlaps with the array\r\n                // contents by `submod` bytes. Masking the lowest-order\r\n                // `submod` bytes allows us to add that value directly to the\r\n                // stored value.\r\n\r\n                let submod := sub(32, slength)\r\n                let mc := add(_postBytes, submod)\r\n                let end := add(_postBytes, mlength)\r\n                let mask := sub(exp(0x100, submod), 1)\r\n\r\n                sstore(\r\n                    sc,\r\n                    add(\r\n                        and(\r\n                            fslot,\r\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\r\n                        ),\r\n                        and(mload(mc), mask)\r\n                    )\r\n                )\r\n\r\n                for {\r\n                    mc := add(mc, 0x20)\r\n                    sc := add(sc, 1)\r\n                } lt(mc, end) {\r\n                    sc := add(sc, 1)\r\n                    mc := add(mc, 0x20)\r\n                } {\r\n                    sstore(sc, mload(mc))\r\n                }\r\n\r\n                mask := exp(0x100, sub(mc, end))\r\n\r\n                sstore(sc, mul(div(mload(mc), mask), mask))\r\n            }\r\n            default {\r\n                // get the keccak hash to get the contents of the array\r\n                mstore(0x0, _preBytes.slot)\r\n                // Start copying to the last used word of the stored array.\r\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\r\n\r\n                // save new length\r\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\r\n\r\n                // Copy over the first `submod` bytes of the new data as in\r\n                // case 1 above.\r\n                let slengthmod := mod(slength, 32)\r\n                let mlengthmod := mod(mlength, 32)\r\n                let submod := sub(32, slengthmod)\r\n                let mc := add(_postBytes, submod)\r\n                let end := add(_postBytes, mlength)\r\n                let mask := sub(exp(0x100, submod), 1)\r\n\r\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\r\n\r\n                for {\r\n                    sc := add(sc, 1)\r\n                    mc := add(mc, 0x20)\r\n                } lt(mc, end) {\r\n                    sc := add(sc, 1)\r\n                    mc := add(mc, 0x20)\r\n                } {\r\n                    sstore(sc, mload(mc))\r\n                }\r\n\r\n                mask := exp(0x100, sub(mc, end))\r\n\r\n                sstore(sc, mul(div(mload(mc), mask), mask))\r\n            }\r\n        }\r\n    }\r\n\r\n    function slice(\r\n        bytes memory _bytes,\r\n        uint256 _start,\r\n        uint256 _length\r\n    ) internal pure returns (bytes memory) {\r\n        if (_length + 31 < _length) revert BytesLib__Overflow();\r\n        if (_bytes.length < _start + _length) revert BytesLib__OutOfBounds();\r\n\r\n        bytes memory tempBytes;\r\n\r\n        assembly {\r\n            switch iszero(_length)\r\n            case 0 {\r\n                // Get a location of some free memory and store it in tempBytes as\r\n                // Solidity does for memory variables.\r\n                tempBytes := mload(0x40)\r\n\r\n                // The first word of the slice result is potentially a partial\r\n                // word read from the original array. To read it, we calculate\r\n                // the length of that partial word and start copying that many\r\n                // bytes into the array. The first word we copy will start with\r\n                // data we don't care about, but the last `lengthmod` bytes will\r\n                // land at the beginning of the contents of the new array. When\r\n                // we're done copying, we overwrite the full first word with\r\n                // the actual length of the slice.\r\n                let lengthmod := and(_length, 31)\r\n\r\n                // The multiplication in the next line is necessary\r\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\r\n                // the following copy loop was copying the origin's length\r\n                // and then ending prematurely not copying everything it should.\r\n                let mc := add(\r\n                    add(tempBytes, lengthmod),\r\n                    mul(0x20, iszero(lengthmod))\r\n                )\r\n                let end := add(mc, _length)\r\n\r\n                for {\r\n                    // The multiplication in the next line has the same exact purpose\r\n                    // as the one above.\r\n                    let cc := add(\r\n                        add(\r\n                            add(_bytes, lengthmod),\r\n                            mul(0x20, iszero(lengthmod))\r\n                        ),\r\n                        _start\r\n                    )\r\n                } lt(mc, end) {\r\n                    mc := add(mc, 0x20)\r\n                    cc := add(cc, 0x20)\r\n                } {\r\n                    mstore(mc, mload(cc))\r\n                }\r\n\r\n                mstore(tempBytes, _length)\r\n\r\n                //update free-memory pointer\r\n                //allocating the array padded to 32 bytes like the compiler does now\r\n                mstore(0x40, and(add(mc, 31), not(31)))\r\n            }\r\n            //if we want a zero-length slice let's just return a zero-length array\r\n            default {\r\n                tempBytes := mload(0x40)\r\n                //zero out the 32 bytes slice we are about to return\r\n                //we need to do it because Solidity does not garbage collect\r\n                mstore(tempBytes, 0)\r\n\r\n                mstore(0x40, add(tempBytes, 0x20))\r\n            }\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n\r\n    function toAddress(\r\n        bytes memory _bytes,\r\n        uint256 _start\r\n    ) internal pure returns (address) {\r\n        if (_bytes.length < _start + 20) revert BytesLib__OutOfBounds();\r\n        address tempAddress;\r\n\r\n        assembly {\r\n            tempAddress := div(\r\n                mload(add(add(_bytes, 0x20), _start)),\r\n                0x1000000000000000000000000\r\n            )\r\n        }\r\n\r\n        return tempAddress;\r\n    }\r\n\r\n    function toUint8(\r\n        bytes memory _bytes,\r\n        uint256 _start\r\n    ) internal pure returns (uint8) {\r\n        if (_bytes.length < _start + 1) revert BytesLib__OutOfBounds();\r\n        uint8 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x1), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint16(\r\n        bytes memory _bytes,\r\n        uint256 _start\r\n    ) internal pure returns (uint16) {\r\n        if (_bytes.length < _start + 2) revert BytesLib__OutOfBounds();\r\n        uint16 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x2), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint32(\r\n        bytes memory _bytes,\r\n        uint256 _start\r\n    ) internal pure returns (uint32) {\r\n        if (_bytes.length < _start + 4) revert BytesLib__OutOfBounds();\r\n        uint32 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x4), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint64(\r\n        bytes memory _bytes,\r\n        uint256 _start\r\n    ) internal pure returns (uint64) {\r\n        if (_bytes.length < _start + 8) revert BytesLib__OutOfBounds();\r\n        uint64 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x8), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint96(\r\n        bytes memory _bytes,\r\n        uint256 _start\r\n    ) internal pure returns (uint96) {\r\n        if (_bytes.length < _start + 12) revert BytesLib__OutOfBounds();\r\n        uint96 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0xc), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint128(\r\n        bytes memory _bytes,\r\n        uint256 _start\r\n    ) internal pure returns (uint128) {\r\n        if (_bytes.length < _start + 16) revert BytesLib__OutOfBounds();\r\n        uint128 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x10), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint256(\r\n        bytes memory _bytes,\r\n        uint256 _start\r\n    ) internal pure returns (uint256) {\r\n        if (_bytes.length < _start + 32) revert BytesLib__OutOfBounds();\r\n        uint256 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x20), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toBytes32(\r\n        bytes memory _bytes,\r\n        uint256 _start\r\n    ) internal pure returns (bytes32) {\r\n        if (_bytes.length < _start + 32) revert BytesLib__OutOfBounds();\r\n        bytes32 tempBytes32;\r\n\r\n        assembly {\r\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\r\n        }\r\n\r\n        return tempBytes32;\r\n    }\r\n\r\n    function equal(\r\n        bytes memory _preBytes,\r\n        bytes memory _postBytes\r\n    ) internal pure returns (bool) {\r\n        bool success = true;\r\n\r\n        assembly {\r\n            let length := mload(_preBytes)\r\n\r\n            // if lengths don't match the arrays are not equal\r\n            switch eq(length, mload(_postBytes))\r\n            case 1 {\r\n                // cb is a circuit breaker in the for loop since there's\r\n                //  no said feature for inline assembly loops\r\n                // cb = 1 - don't breaker\r\n                // cb = 0 - break\r\n                let cb := 1\r\n\r\n                let mc := add(_preBytes, 0x20)\r\n                let end := add(mc, length)\r\n\r\n                for {\r\n                    let cc := add(_postBytes, 0x20)\r\n                    // the next line is the loop condition:\r\n                    // while(uint256(mc < end) + cb == 2)\r\n                } eq(add(lt(mc, end), cb), 2) {\r\n                    mc := add(mc, 0x20)\r\n                    cc := add(cc, 0x20)\r\n                } {\r\n                    // if any of these checks fails then arrays are not equal\r\n                    if iszero(eq(mload(mc), mload(cc))) {\r\n                        // unsuccess:\r\n                        success := 0\r\n                        cb := 0\r\n                    }\r\n                }\r\n            }\r\n            default {\r\n                // unsuccess:\r\n                success := 0\r\n            }\r\n        }\r\n\r\n        return success;\r\n    }\r\n\r\n    function equalStorage(\r\n        bytes storage _preBytes,\r\n        bytes memory _postBytes\r\n    ) internal view returns (bool) {\r\n        bool success = true;\r\n\r\n        assembly {\r\n            // we know _preBytes_offset is 0\r\n            let fslot := sload(_preBytes.slot)\r\n            // Decode the length of the stored array like in concatStorage().\r\n            let slength := div(\r\n                and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)),\r\n                2\r\n            )\r\n            let mlength := mload(_postBytes)\r\n\r\n            // if lengths don't match the arrays are not equal\r\n            switch eq(slength, mlength)\r\n            case 1 {\r\n                // slength can contain both the length and contents of the array\r\n                // if length < 32 bytes so let's prepare for that\r\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\r\n                if iszero(iszero(slength)) {\r\n                    switch lt(slength, 32)\r\n                    case 1 {\r\n                        // blank the last byte which is the length\r\n                        fslot := mul(div(fslot, 0x100), 0x100)\r\n\r\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\r\n                            // unsuccess:\r\n                            success := 0\r\n                        }\r\n                    }\r\n                    default {\r\n                        // cb is a circuit breaker in the for loop since there's\r\n                        //  no said feature for inline assembly loops\r\n                        // cb = 1 - don't breaker\r\n                        // cb = 0 - break\r\n                        let cb := 1\r\n\r\n                        // get the keccak hash to get the contents of the array\r\n                        mstore(0x0, _preBytes.slot)\r\n                        let sc := keccak256(0x0, 0x20)\r\n\r\n                        let mc := add(_postBytes, 0x20)\r\n                        let end := add(mc, mlength)\r\n\r\n                        // the next line is the loop condition:\r\n                        // while(uint256(mc < end) + cb == 2)\r\n                        for {\r\n\r\n                        } eq(add(lt(mc, end), cb), 2) {\r\n                            sc := add(sc, 1)\r\n                            mc := add(mc, 0x20)\r\n                        } {\r\n                            if iszero(eq(sload(sc), mload(mc))) {\r\n                                // unsuccess:\r\n                                success := 0\r\n                                cb := 0\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            default {\r\n                // unsuccess:\r\n                success := 0\r\n            }\r\n        }\r\n\r\n        return success;\r\n    }\r\n}\r\n"},"@solidstate/contracts/introspection/ERC165/base/IERC165Base.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC165 } from '../../../interfaces/IERC165.sol';\nimport { IERC165BaseInternal } from './IERC165BaseInternal.sol';\n\ninterface IERC165Base is IERC165, IERC165BaseInternal {}\n"},"contracts/staking/IPremiaStaking.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-or-later\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport {PremiaStakingStorage} from \"./PremiaStakingStorage.sol\";\r\nimport {IOFT} from \"../layerZero/token/oft/IOFT.sol\";\r\n\r\nimport {IERC2612} from \"@solidstate/contracts/token/ERC20/permit/IERC2612.sol\";\r\n\r\n// IERC20Metadata inheritance not possible due to linearization issue\r\ninterface IPremiaStaking is IERC2612, IOFT {\r\n    error PremiaStaking__CantTransfer();\r\n    error PremiaStaking__ExcessiveStakePeriod();\r\n    error PremiaStaking__InsufficientSwapOutput();\r\n    error PremiaStaking__NoPendingWithdrawal();\r\n    error PremiaStaking__NotEnoughLiquidity();\r\n    error PremiaStaking__PeriodTooShort();\r\n    error PremiaStaking__StakeLocked();\r\n    error PremiaStaking__StakeNotLocked();\r\n    error PremiaStaking__WithdrawalStillPending();\r\n\r\n    event Stake(\r\n        address indexed user,\r\n        uint256 amount,\r\n        uint64 stakePeriod,\r\n        uint64 lockedUntil\r\n    );\r\n\r\n    event Unstake(\r\n        address indexed user,\r\n        uint256 amount,\r\n        uint256 fee,\r\n        uint256 startDate\r\n    );\r\n\r\n    event Harvest(address indexed user, uint256 amount);\r\n\r\n    event EarlyUnstakeRewardCollected(address indexed user, uint256 amount);\r\n\r\n    event Withdraw(address indexed user, uint256 amount);\r\n\r\n    event RewardsAdded(uint256 amount);\r\n\r\n    struct StakeLevel {\r\n        uint256 amount; // Amount to stake\r\n        uint256 discountBPS; // Discount when amount is reached\r\n    }\r\n\r\n    struct SwapArgs {\r\n        //min amount out to be used to purchase\r\n        uint256 amountOutMin;\r\n        // exchange address to call to execute the trade\r\n        address callee;\r\n        // address for which to set allowance for the trade\r\n        address allowanceTarget;\r\n        // data to execute the trade\r\n        bytes data;\r\n        // address to which refund excess tokens\r\n        address refundAddress;\r\n    }\r\n\r\n    event BridgeLock(\r\n        address indexed user,\r\n        uint64 stakePeriod,\r\n        uint64 lockedUntil\r\n    );\r\n\r\n    event UpdateLock(\r\n        address indexed user,\r\n        uint64 oldStakePeriod,\r\n        uint64 newStakePeriod\r\n    );\r\n\r\n    /**\r\n     * @notice Returns the reward token address\r\n     * @return The reward token address\r\n     */\r\n    function getRewardToken() external view returns (address);\r\n\r\n    /**\r\n     * @notice add premia tokens as available tokens to be distributed as rewards\r\n     * @param amount amount of premia tokens to add as rewards\r\n     */\r\n    function addRewards(uint256 amount) external;\r\n\r\n    /**\r\n     * @notice get amount of tokens that have not yet been distributed as rewards\r\n     * @return rewards amount of tokens not yet distributed as rewards\r\n     * @return unstakeRewards amount of PREMIA not yet claimed from early unstake fees\r\n     */\r\n    function getAvailableRewards()\r\n        external\r\n        view\r\n        returns (uint256 rewards, uint256 unstakeRewards);\r\n\r\n    /**\r\n     * @notice get pending amount of tokens to be distributed as rewards to stakers\r\n     * @return amount of tokens pending to be distributed as rewards\r\n     */\r\n    function getPendingRewards() external view returns (uint256);\r\n\r\n    /**\r\n     * @notice get pending withdrawal data of a user\r\n     * @return amount pending withdrawal amount\r\n     * @return startDate start timestamp of withdrawal\r\n     * @return unlockDate timestamp at which withdrawal becomes available\r\n     */\r\n    function getPendingWithdrawal(\r\n        address user\r\n    )\r\n        external\r\n        view\r\n        returns (uint256 amount, uint256 startDate, uint256 unlockDate);\r\n\r\n    /**\r\n     * @notice get the amount of PREMIA available for withdrawal\r\n     * @return amount of PREMIA available for withdrawal\r\n     */\r\n    function getAvailablePremiaAmount() external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Stake using IERC2612 permit\r\n     * @param amount The amount of xPremia to stake\r\n     * @param period The lockup period (in seconds)\r\n     * @param deadline Deadline after which permit will fail\r\n     * @param v V\r\n     * @param r R\r\n     * @param s S\r\n     */\r\n    function stakeWithPermit(\r\n        uint256 amount,\r\n        uint64 period,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Lockup xPremia for protocol fee discounts\r\n     *          Longer period of locking will apply a multiplier on the amount staked, in the fee discount calculation\r\n     * @param amount The amount of xPremia to stake\r\n     * @param period The lockup period (in seconds)\r\n     */\r\n    function stake(uint256 amount, uint64 period) external;\r\n\r\n    /**\r\n     * @notice update vxPremia lock\r\n     * @param period The new lockup period (in seconds)\r\n     */\r\n    function updateLock(uint64 period) external;\r\n\r\n    /**\r\n     * @notice harvest rewards, convert to PREMIA using exchange helper, and stake\r\n     * @param s swap arguments\r\n     * @param stakePeriod The lockup period (in seconds)\r\n     */\r\n    function harvestAndStake(\r\n        IPremiaStaking.SwapArgs memory s,\r\n        uint64 stakePeriod\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Harvest rewards directly to user wallet\r\n     */\r\n    function harvest() external;\r\n\r\n    /**\r\n     * @notice Get pending rewards amount, including pending pool update\r\n     * @param user User for which to calculate pending rewards\r\n     * @return reward amount of pending rewards from protocol fees (in REWARD_TOKEN)\r\n     * @return unstakeReward amount of pending rewards from early unstake fees (in PREMIA)\r\n     */\r\n    function getPendingUserRewards(\r\n        address user\r\n    ) external view returns (uint256 reward, uint256 unstakeReward);\r\n\r\n    /**\r\n     * @notice unstake tokens before end of the lock period, for a fee\r\n     * @param amount the amount of vxPremia to unstake\r\n     */\r\n    function earlyUnstake(uint256 amount) external;\r\n\r\n    /**\r\n     * @notice get early unstake fee for given user\r\n     * @param user address of the user\r\n     * @return feePercentage % fee to pay for early unstake (1e4 = 100%)\r\n     */\r\n    function getEarlyUnstakeFeeBPS(\r\n        address user\r\n    ) external view returns (uint256 feePercentage);\r\n\r\n    /**\r\n     * @notice Initiate the withdrawal process by burning xPremia, starting the delay period\r\n     * @param amount quantity of xPremia to unstake\r\n     */\r\n    function startWithdraw(uint256 amount) external;\r\n\r\n    /**\r\n     * @notice Withdraw underlying premia\r\n     */\r\n    function withdraw() external;\r\n\r\n    //////////\r\n    // View //\r\n    //////////\r\n\r\n    /**\r\n     * Calculate the stake amount of a user, after applying the bonus from the lockup period chosen\r\n     * @param user The user from which to query the stake amount\r\n     * @return The user stake amount after applying the bonus\r\n     */\r\n    function getUserPower(address user) external view returns (uint256);\r\n\r\n    /**\r\n     * Return the total power across all users (applying the bonus from lockup period chosen)\r\n     * @return The total power across all users\r\n     */\r\n    function getTotalPower() external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Calculate the % of fee discount for user, based on his stake\r\n     * @param user The _user for which the discount is for\r\n     * @return Percentage of protocol fee discount (in basis point)\r\n     *         Ex : 1000 = 10% fee discount\r\n     */\r\n    function getDiscountBPS(address user) external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Get stake levels\r\n     * @return Stake levels\r\n     *         Ex : 2500 = -25%\r\n     */\r\n    function getStakeLevels() external returns (StakeLevel[] memory);\r\n\r\n    /**\r\n     * @notice Get stake period multiplier\r\n     * @param period The duration (in seconds) for which tokens are locked\r\n     * @return The multiplier for this staking period\r\n     *         Ex : 20000 = x2\r\n     */\r\n    function getStakePeriodMultiplierBPS(\r\n        uint256 period\r\n    ) external returns (uint256);\r\n\r\n    /**\r\n     * @notice Get staking infos of a user\r\n     * @param user The user address for which to get staking infos\r\n     * @return The staking infos of the user\r\n     */\r\n    function getUserInfo(\r\n        address user\r\n    ) external view returns (PremiaStakingStorage.UserInfo memory);\r\n}\r\n"},"@solidstate/contracts/utils/UintUtils.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title utility functions for uint256 operations\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts/ (MIT license)\n */\nlibrary UintUtils {\n    error UintUtils__InsufficientHexLength();\n\n    bytes16 private constant HEX_SYMBOLS = '0123456789abcdef';\n\n    function add(uint256 a, int256 b) internal pure returns (uint256) {\n        return b < 0 ? sub(a, -b) : a + uint256(b);\n    }\n\n    function sub(uint256 a, int256 b) internal pure returns (uint256) {\n        return b < 0 ? add(a, -b) : a - uint256(b);\n    }\n\n    function toString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return '0';\n        }\n\n        uint256 temp = value;\n        uint256 digits;\n\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n\n        bytes memory buffer = new bytes(digits);\n\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n\n        return string(buffer);\n    }\n\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return '0x00';\n        }\n\n        uint256 length = 0;\n\n        for (uint256 temp = value; temp != 0; temp >>= 8) {\n            unchecked {\n                length++;\n            }\n        }\n\n        return toHexString(value, length);\n    }\n\n    function toHexString(\n        uint256 value,\n        uint256 length\n    ) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = '0';\n        buffer[1] = 'x';\n\n        unchecked {\n            for (uint256 i = 2 * length + 1; i > 1; --i) {\n                buffer[i] = HEX_SYMBOLS[value & 0xf];\n                value >>= 4;\n            }\n        }\n\n        if (value != 0) revert UintUtils__InsufficientHexLength();\n\n        return string(buffer);\n    }\n}\n"},"@solidstate/contracts/token/ERC20/ISolidStateERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC20Base } from './base/IERC20Base.sol';\nimport { IERC20Extended } from './extended/IERC20Extended.sol';\nimport { IERC20Metadata } from './metadata/IERC20Metadata.sol';\nimport { IERC20Permit } from './permit/IERC20Permit.sol';\n\ninterface ISolidStateERC20 is\n    IERC20Base,\n    IERC20Extended,\n    IERC20Metadata,\n    IERC20Permit\n{}\n"}},"settings":{"viaIR":true,"optimizer":{"enabled":true,"runs":200},"outputSelection":{"*":{"*":["evm.bytecode","evm.deployedBytecode","devdoc","userdoc","metadata","abi"]}},"libraries":{}}},"ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"proxyManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lzEndpoint\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"premia\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"exchangeHelper\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AddressUtils__NotContract\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BytesLib__OutOfBounds\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BytesLib__Overflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ECDSA__InvalidS\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ECDSA__InvalidSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ECDSA__InvalidV\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC165Base__InvalidInterfaceId\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC20Base__ApproveFromZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC20Base__ApproveToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC20Base__BurnExceedsBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC20Base__BurnFromZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC20Base__InsufficientAllowance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC20Base__MintToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC20Base__TransferExceedsBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC20Base__TransferFromZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC20Base__TransferToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC20Extended__ExcessiveAllowance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC20Extended__InsufficientAllowance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC20Permit__ExpiredDeadline\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC20Permit__InvalidSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LzApp__InvalidEndpointCaller\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LzApp__InvalidSource\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LzApp__NoTrustedPathRecord\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LzApp__NotTrustedSource\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NonblockingLzApp__CallerNotLzApp\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NonblockingLzApp__InvalidPayload\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NonblockingLzApp__NoStoredMessage\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OFT_InsufficientAllowance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Ownable__NotOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Ownable__NotTransitiveOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PremiaStaking__CantTransfer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PremiaStaking__ExcessiveStakePeriod\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PremiaStaking__InsufficientSwapOutput\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PremiaStaking__NoPendingWithdrawal\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PremiaStaking__NotEnoughLiquidity\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PremiaStaking__PeriodTooShort\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PremiaStaking__StakeLocked\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PremiaStaking__StakeNotLocked\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PremiaStaking__WithdrawalStillPending\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SafeERC20__OperationFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VxPremia__InvalidPoolAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VxPremia__InvalidVoteTarget\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VxPremia__NotEnoughVotingPower\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"enum VxPremiaStorage.VoteVersion\",\"name\":\"version\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"target\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AddVote\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"stakePeriod\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"lockedUntil\",\"type\":\"uint64\"}],\"name\":\"BridgeLock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EarlyUnstakeRewardCollected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Harvest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"srcChainId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"srcAddress\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"reason\",\"type\":\"bytes\"}],\"name\":\"MessageFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"srcChainId\",\"type\":\"uint16\"},{\"indexed\":true,\"internalType\":\"bytes\",\"name\":\"srcAddress\",\"type\":\"bytes\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"toAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ReceiveFromChain\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"enum VxPremiaStorage.VoteVersion\",\"name\":\"version\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"target\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RemoveVote\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"srcChainId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"srcAddress\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"payloadHash\",\"type\":\"bytes32\"}],\"name\":\"RetryMessageSuccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RewardsAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"dstChainId\",\"type\":\"uint16\"},{\"indexed\":true,\"internalType\":\"bytes\",\"name\":\"toAddress\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SendToChain\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"_remoteChainId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"_remoteAddress\",\"type\":\"bytes\"}],\"name\":\"SetTrustedRemoteAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_useCustomAdapterParams\",\"type\":\"bool\"}],\"name\":\"SetUseCustomAdapterParams\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"stakePeriod\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"lockedUntil\",\"type\":\"uint64\"}],\"name\":\"Stake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startDate\",\"type\":\"uint256\"}],\"name\":\"Unstake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"oldStakePeriod\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"newStakePeriod\",\"type\":\"uint64\"}],\"name\":\"UpdateLock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"domainSeparator\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PT_SEND\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"addRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"enum VxPremiaStorage.VoteVersion\",\"name\":\"version\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"target\",\"type\":\"bytes\"}],\"internalType\":\"struct VxPremiaStorage.Vote[]\",\"name\":\"votes\",\"type\":\"tuple[]\"}],\"name\":\"castVotes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"circulatingSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"earlyUnstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"dstChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"toAddress\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"useZro\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"adapterParams\",\"type\":\"bytes\"}],\"name\":\"estimateSendFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nativeFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"zroFee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"srcChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"srcAddress\",\"type\":\"bytes\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"}],\"name\":\"failedMessages\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"srcChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"srcAddress\",\"type\":\"bytes\"}],\"name\":\"forceResumeReceive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAvailablePremiaAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAvailableRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rewards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unstakeRewards\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"version\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"chainId\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"configType\",\"type\":\"uint256\"}],\"name\":\"getConfig\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getDiscountBPS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getEarlyUnstakeFeeBPS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"feePercentage\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPendingRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getPendingUserRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unstakeReward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getPendingWithdrawal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlockDate\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPendingWithdrawals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum VxPremiaStorage.VoteVersion\",\"name\":\"version\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"target\",\"type\":\"bytes\"}],\"name\":\"getPoolVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRewardToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStakeLevels\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"discountBPS\",\"type\":\"uint256\"}],\"internalType\":\"struct IPremiaStaking.StakeLevel[]\",\"name\":\"stakeLevels\",\"type\":\"tuple[]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"}],\"name\":\"getStakePeriodMultiplierBPS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalPower\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_remoteChainId\",\"type\":\"uint16\"}],\"name\":\"getTrustedRemoteAddress\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unstakeRewardDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"stakePeriod\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"lockedUntil\",\"type\":\"uint64\"}],\"internalType\":\"struct PremiaStakingStorage.UserInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserPower\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserVotes\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"enum VxPremiaStorage.VoteVersion\",\"name\":\"version\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"target\",\"type\":\"bytes\"}],\"internalType\":\"struct VxPremiaStorage.Vote[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"harvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"callee\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"allowanceTarget\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"refundAddress\",\"type\":\"address\"}],\"internalType\":\"struct IPremiaStaking.SwapArgs\",\"name\":\"s\",\"type\":\"tuple\"},{\"internalType\":\"uint64\",\"name\":\"stakePeriod\",\"type\":\"uint64\"}],\"name\":\"harvestAndStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"srcChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"srcAddress\",\"type\":\"bytes\"}],\"name\":\"isTrustedRemote\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lzEndpoint\",\"outputs\":[{\"internalType\":\"contract ILayerZeroEndpoint\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"srcChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"srcAddress\",\"type\":\"bytes\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"lzReceive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"srcChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"srcAddress\",\"type\":\"bytes\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"nonblockingLzReceive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"resetUserVotes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"srcChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"srcAddress\",\"type\":\"bytes\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"retryMessage\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"dstChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"toAddress\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"refundAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zroPaymentAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"adapterParams\",\"type\":\"bytes\"}],\"name\":\"sendFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"version\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"chainId\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"configType\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"config\",\"type\":\"bytes\"}],\"name\":\"setConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"version\",\"type\":\"uint16\"}],\"name\":\"setReceiveVersion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"version\",\"type\":\"uint16\"}],\"name\":\"setSendVersion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"remoteChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"remoteAddress\",\"type\":\"bytes\"}],\"name\":\"setTrustedRemoteAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"period\",\"type\":\"uint64\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"period\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"stakeWithPermit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"startWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"period\",\"type\":\"uint64\"}],\"name\":\"updateLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"VxPremia","CompilerVersion":"v0.8.17+commit.8df45f5f","OptimizationUsed":1,"Runs":200,"ConstructorArguments":"0x0000000000000000000000004f273f4efa9ecf5dd245a338fad9fe0bab63b35000000000000000000000000066a71dcef29a0ffbdbe3c6a460a3b5bc225cd6750000000000000000000000006399c842dd2be3de30bf99bc7d1bbf6fa3650e70000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48000000000000000000000000380eb51db6fe77a8876cb0735164cb8af7f80cb5","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":0,"SwarmSource":""}]}