{"expiry":1725830209,"data":[{"SourceCode":{"language":"Solidity","sources":{"contracts/vendors/IRateProvider.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.16;\r\n\r\n/**\r\n * @title IRateProvider\r\n * @notice This interface ensure compatibility with Balancer's Metastable pools, the getRate() method is used as the pool rate. This reduces arbitrages whenever the rswETH rate increases from a repricing event.\r\n * @dev https://github.com/balancer-labs/metastable-rate-providers/blob/master/contracts/interfaces/IRateProvider.sol\r\n */\r\ninterface IRateProvider {\r\n  function getRate() external view returns (uint256);\r\n}\r\n"},"contracts/interfaces/IWhitelist.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.16;\r\n\r\n/**\r\n * @title IWhitelist\r\n * @author https://github.com/max-taylor\r\n * @dev Interface for managing a whitelist of addresses.\r\n */\r\ninterface IWhitelist {\r\n  // ***** Events ******\r\n  /**\r\n   * @dev Emitted when an address is added to the whitelist.\r\n   * @param _address The address that was added to the whitelist.\r\n   */\r\n  event AddedToWhitelist(address indexed _address);\r\n\r\n  /**\r\n   * @dev Emitted when an address is removed from the whitelist.\r\n   * @param _address The address that was removed from the whitelist.\r\n   */\r\n  event RemovedFromWhitelist(address indexed _address);\r\n\r\n  /**\r\n   * @dev Emitted when the whitelist is enabled.\r\n   */\r\n  event WhitelistEnabled();\r\n\r\n  /**\r\n   * @dev Emitted when the whitelist is disabled.\r\n   */\r\n  event WhitelistDisabled();\r\n\r\n  // ***** Errors ******\r\n  /**\r\n   * @dev Throws an error indicating that the address is already in the whitelist.\r\n   * @param _address The address that already exists in the whitelist.\r\n   */\r\n  error AddressAlreadyInWhitelist(address _address);\r\n\r\n  /**\r\n   * @dev Throws an error indicating that the address is missing from the whitelist.\r\n   * @param _address The address that is missing from the whitelist.\r\n   */\r\n  error AddressMissingFromWhitelist(address _address);\r\n\r\n  /**\r\n   * @dev Throws an error indicating that the whitelist is already enabled.\r\n   */\r\n  error WhitelistAlreadyEnabled();\r\n\r\n  /**\r\n   * @dev Throws an error indicating that the whitelist is already disabled.\r\n   */\r\n  error WhitelistAlreadyDisabled();\r\n\r\n  /**\r\n   * @dev Throws an error indicating that the address is not in the whitelist.\r\n   */\r\n  error NotInWhitelist();\r\n\r\n  // ************************************\r\n  // ***** External Methods ******\r\n\r\n  /**\r\n   * @dev Returns true if the whitelist is enabled, false otherwise.\r\n    @return bool representing whether the whitelist is enabled.\r\n  */\r\n  function whitelistEnabled() external returns (bool);\r\n\r\n  /**\r\n   * @dev Returns true if the address is in the whitelist, false otherwise.\r\n\r\n   * @param _address The address to check.\r\n    @return bool representing whether the address is in the whitelist.\r\n  */\r\n  function whitelistedAddresses(address _address) external returns (bool);\r\n\r\n  /**\r\n   * @dev Adds the specified address to the whitelist, reverts if not the platform admin\r\n   * @param _address The address to add.\r\n   */\r\n  function addToWhitelist(address _address) external;\r\n\r\n  /**\r\n   * @dev Adds the array of addresses to the whitelist, reverts if not the platform admin.\r\n   * @param _addresses The address to add.\r\n   */\r\n  function batchAddToWhitelist(address[] calldata _addresses) external;\r\n\r\n  /**\r\n   * @dev Removes the specified address from the whitelist, reverts if not the platform admin\r\n   * @param _address The address to remove.\r\n   */\r\n  function removeFromWhitelist(address _address) external;\r\n\r\n  /**\r\n   * @dev Removes the array of addresses from the whitelist, reverts if not the platform admin\r\n   * @param _addresses The array of addresses to remove.\r\n   */\r\n  function batchRemoveFromWhitelist(address[] calldata _addresses) external;\r\n\r\n  /**\r\n   * @dev Enables the whitelist, allowing only whitelisted addresses to interact with the contract. Reverts if the caller is not the platform admin\r\n   */\r\n  function enableWhitelist() external;\r\n\r\n  /**\r\n   * @dev Disables the whitelist, allowing all addresses to interact with the contract. Reverts if the caller is not the platform admin\r\n   */\r\n  function disableWhitelist() external;\r\n}\r\n"},"contracts/vendors/contracts/libraries/Endian.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity ^0.8.0;\r\n\r\nlibrary Endian {\r\n    /**\r\n     * @notice Converts a little endian-formatted uint64 to a big endian-formatted uint64\r\n     * @param lenum little endian-formatted uint64 input, provided as 'bytes32' type\r\n     * @return n The big endian-formatted uint64\r\n     * @dev Note that the input is formatted as a 'bytes32' type (i.e. 256 bits), but it is immediately truncated to a uint64 (i.e. 64 bits)\r\n     * through a right-shift/shr operation.\r\n     */\r\n    function fromLittleEndianUint64(bytes32 lenum) internal pure returns (uint64 n) {\r\n        // the number needs to be stored in little-endian encoding (ie in bytes 0-8)\r\n        n = uint64(uint256(lenum >> 192));\r\n        return\r\n            (n >> 56) |\r\n            ((0x00FF000000000000 & n) >> 40) |\r\n            ((0x0000FF0000000000 & n) >> 24) |\r\n            ((0x000000FF00000000 & n) >> 8) |\r\n            ((0x00000000FF000000 & n) << 8) |\r\n            ((0x0000000000FF0000 & n) << 24) |\r\n            ((0x000000000000FF00 & n) << 40) |\r\n            ((0x00000000000000FF & n) << 56);\r\n    }\r\n}\r\n"},"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"},"@prb/math/src/Common.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\n/// Common mathematical functions used in both SD59x18 and UD60x18. Note that these global functions do not\n/// always operate with SD59x18 and UD60x18 numbers.\n\n/*//////////////////////////////////////////////////////////////////////////\n                                CUSTOM ERRORS\n//////////////////////////////////////////////////////////////////////////*/\n\n/// @notice Emitted when the ending result in the fixed-point version of `mulDiv` would overflow uint256.\nerror PRBMath_MulDiv18_Overflow(uint256 x, uint256 y);\n\n/// @notice Emitted when the ending result in `mulDiv` would overflow uint256.\nerror PRBMath_MulDiv_Overflow(uint256 x, uint256 y, uint256 denominator);\n\n/// @notice Emitted when attempting to run `mulDiv` with one of the inputs `type(int256).min`.\nerror PRBMath_MulDivSigned_InputTooSmall();\n\n/// @notice Emitted when the ending result in the signed version of `mulDiv` would overflow int256.\nerror PRBMath_MulDivSigned_Overflow(int256 x, int256 y);\n\n/*//////////////////////////////////////////////////////////////////////////\n                                    CONSTANTS\n//////////////////////////////////////////////////////////////////////////*/\n\n/// @dev The maximum value an uint128 number can have.\nuint128 constant MAX_UINT128 = type(uint128).max;\n\n/// @dev The maximum value an uint40 number can have.\nuint40 constant MAX_UINT40 = type(uint40).max;\n\n/// @dev How many trailing decimals can be represented.\nuint256 constant UNIT = 1e18;\n\n/// @dev Largest power of two that is a divisor of `UNIT`.\nuint256 constant UNIT_LPOTD = 262144;\n\n/// @dev The `UNIT` number inverted mod 2^256.\nuint256 constant UNIT_INVERSE = 78156646155174841979727994598816262306175212592076161876661_508869554232690281;\n\n/*//////////////////////////////////////////////////////////////////////////\n                                    FUNCTIONS\n//////////////////////////////////////////////////////////////////////////*/\n\n/// @notice Finds the zero-based index of the first one in the binary representation of x.\n/// @dev See the note on msb in the \"Find First Set\" Wikipedia article https://en.wikipedia.org/wiki/Find_first_set\n///\n/// Each of the steps in this implementation is equivalent to this high-level code:\n///\n/// ```solidity\n/// if (x >= 2 ** 128) {\n///     x >>= 128;\n///     result += 128;\n/// }\n/// ```\n///\n/// Where 128 is swapped with each respective power of two factor. See the full high-level implementation here:\n/// https://gist.github.com/PaulRBerg/f932f8693f2733e30c4d479e8e980948\n///\n/// A list of the Yul instructions used below:\n/// - \"gt\" is \"greater than\"\n/// - \"or\" is the OR bitwise operator\n/// - \"shl\" is \"shift left\"\n/// - \"shr\" is \"shift right\"\n///\n/// @param x The uint256 number for which to find the index of the most significant bit.\n/// @return result The index of the most significant bit as an uint256.\nfunction msb(uint256 x) pure returns (uint256 result) {\n    // 2^128\n    assembly (\"memory-safe\") {\n        let factor := shl(7, gt(x, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^64\n    assembly (\"memory-safe\") {\n        let factor := shl(6, gt(x, 0xFFFFFFFFFFFFFFFF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^32\n    assembly (\"memory-safe\") {\n        let factor := shl(5, gt(x, 0xFFFFFFFF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^16\n    assembly (\"memory-safe\") {\n        let factor := shl(4, gt(x, 0xFFFF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^8\n    assembly (\"memory-safe\") {\n        let factor := shl(3, gt(x, 0xFF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^4\n    assembly (\"memory-safe\") {\n        let factor := shl(2, gt(x, 0xF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^2\n    assembly (\"memory-safe\") {\n        let factor := shl(1, gt(x, 0x3))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^1\n    // No need to shift x any more.\n    assembly (\"memory-safe\") {\n        let factor := gt(x, 0x1)\n        result := or(result, factor)\n    }\n}\n\n/// @notice Calculates floor(x*y÷denominator) with full precision.\n///\n/// @dev Credits to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.\n///\n/// Requirements:\n/// - The denominator cannot be zero.\n/// - The result must fit within uint256.\n///\n/// Caveats:\n/// - This function does not work with fixed-point numbers.\n///\n/// @param x The multiplicand as an uint256.\n/// @param y The multiplier as an uint256.\n/// @param denominator The divisor as an uint256.\n/// @return result The result as an uint256.\nfunction mulDiv(uint256 x, uint256 y, uint256 denominator) pure returns (uint256 result) {\n    // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n    // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n    // variables such that product = prod1 * 2^256 + prod0.\n    uint256 prod0; // Least significant 256 bits of the product\n    uint256 prod1; // Most significant 256 bits of the product\n    assembly (\"memory-safe\") {\n        let mm := mulmod(x, y, not(0))\n        prod0 := mul(x, y)\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n    }\n\n    // Handle non-overflow cases, 256 by 256 division.\n    if (prod1 == 0) {\n        unchecked {\n            return prod0 / denominator;\n        }\n    }\n\n    // Make sure the result is less than 2^256. Also prevents denominator == 0.\n    if (prod1 >= denominator) {\n        revert PRBMath_MulDiv_Overflow(x, y, denominator);\n    }\n\n    ///////////////////////////////////////////////\n    // 512 by 256 division.\n    ///////////////////////////////////////////////\n\n    // Make division exact by subtracting the remainder from [prod1 prod0].\n    uint256 remainder;\n    assembly (\"memory-safe\") {\n        // Compute remainder using the mulmod Yul instruction.\n        remainder := mulmod(x, y, denominator)\n\n        // Subtract 256 bit number from 512 bit number.\n        prod1 := sub(prod1, gt(remainder, prod0))\n        prod0 := sub(prod0, remainder)\n    }\n\n    // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n    // See https://cs.stackexchange.com/q/138556/92363.\n    unchecked {\n        // Does not overflow because the denominator cannot be zero at this stage in the function.\n        uint256 lpotdod = denominator & (~denominator + 1);\n        assembly (\"memory-safe\") {\n            // Divide denominator by lpotdod.\n            denominator := div(denominator, lpotdod)\n\n            // Divide [prod1 prod0] by lpotdod.\n            prod0 := div(prod0, lpotdod)\n\n            // Flip lpotdod such that it is 2^256 / lpotdod. If lpotdod is zero, then it becomes one.\n            lpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\n        }\n\n        // Shift in bits from prod1 into prod0.\n        prod0 |= prod1 * lpotdod;\n\n        // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n        // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n        // four bits. That is, denominator * inv = 1 mod 2^4.\n        uint256 inverse = (3 * denominator) ^ 2;\n\n        // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n        // in modular arithmetic, doubling the correct bits in each step.\n        inverse *= 2 - denominator * inverse; // inverse mod 2^8\n        inverse *= 2 - denominator * inverse; // inverse mod 2^16\n        inverse *= 2 - denominator * inverse; // inverse mod 2^32\n        inverse *= 2 - denominator * inverse; // inverse mod 2^64\n        inverse *= 2 - denominator * inverse; // inverse mod 2^128\n        inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n        // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n        // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n        // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n        // is no longer required.\n        result = prod0 * inverse;\n    }\n}\n\n/// @notice Calculates floor(x*y÷1e18) with full precision.\n///\n/// @dev Variant of `mulDiv` with constant folding, i.e. in which the denominator is always 1e18. Before returning the\n/// final result, we add 1 if `(x * y) % UNIT >= HALF_UNIT`. Without this adjustment, 6.6e-19 would be truncated to 0\n/// instead of being rounded to 1e-18. See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717.\n///\n/// Requirements:\n/// - The result must fit within uint256.\n///\n/// Caveats:\n/// - The body is purposely left uncommented; to understand how this works, see the NatSpec comments in `mulDiv`.\n/// - It is assumed that the result can never be `type(uint256).max` when x and y solve the following two equations:\n///     1. x * y = type(uint256).max * UNIT\n///     2. (x * y) % UNIT >= UNIT / 2\n///\n/// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\n/// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\n/// @return result The result as an unsigned 60.18-decimal fixed-point number.\nfunction mulDiv18(uint256 x, uint256 y) pure returns (uint256 result) {\n    uint256 prod0;\n    uint256 prod1;\n    assembly (\"memory-safe\") {\n        let mm := mulmod(x, y, not(0))\n        prod0 := mul(x, y)\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n    }\n\n    if (prod1 >= UNIT) {\n        revert PRBMath_MulDiv18_Overflow(x, y);\n    }\n\n    uint256 remainder;\n    assembly (\"memory-safe\") {\n        remainder := mulmod(x, y, UNIT)\n    }\n\n    if (prod1 == 0) {\n        unchecked {\n            return prod0 / UNIT;\n        }\n    }\n\n    assembly (\"memory-safe\") {\n        result := mul(\n            or(\n                div(sub(prod0, remainder), UNIT_LPOTD),\n                mul(sub(prod1, gt(remainder, prod0)), add(div(sub(0, UNIT_LPOTD), UNIT_LPOTD), 1))\n            ),\n            UNIT_INVERSE\n        )\n    }\n}\n\n/// @notice Calculates floor(x*y÷denominator) with full precision.\n///\n/// @dev An extension of `mulDiv` for signed numbers. Works by computing the signs and the absolute values separately.\n///\n/// Requirements:\n/// - None of the inputs can be `type(int256).min`.\n/// - The result must fit within int256.\n///\n/// @param x The multiplicand as an int256.\n/// @param y The multiplier as an int256.\n/// @param denominator The divisor as an int256.\n/// @return result The result as an int256.\nfunction mulDivSigned(int256 x, int256 y, int256 denominator) pure returns (int256 result) {\n    if (x == type(int256).min || y == type(int256).min || denominator == type(int256).min) {\n        revert PRBMath_MulDivSigned_InputTooSmall();\n    }\n\n    // Get hold of the absolute values of x, y and the denominator.\n    uint256 absX;\n    uint256 absY;\n    uint256 absD;\n    unchecked {\n        absX = x < 0 ? uint256(-x) : uint256(x);\n        absY = y < 0 ? uint256(-y) : uint256(y);\n        absD = denominator < 0 ? uint256(-denominator) : uint256(denominator);\n    }\n\n    // Compute the absolute value of (x*y)÷denominator. The result must fit within int256.\n    uint256 rAbs = mulDiv(absX, absY, absD);\n    if (rAbs > uint256(type(int256).max)) {\n        revert PRBMath_MulDivSigned_Overflow(x, y);\n    }\n\n    // Get the signs of x, y and the denominator.\n    uint256 sx;\n    uint256 sy;\n    uint256 sd;\n    assembly (\"memory-safe\") {\n        // This works thanks to two's complement.\n        // \"sgt\" stands for \"signed greater than\" and \"sub(0,1)\" is max uint256.\n        sx := sgt(x, sub(0, 1))\n        sy := sgt(y, sub(0, 1))\n        sd := sgt(denominator, sub(0, 1))\n    }\n\n    // XOR over sx, sy and sd. What this does is to check whether there are 1 or 3 negative signs in the inputs.\n    // If there are, the result should be negative. Otherwise, it should be positive.\n    unchecked {\n        result = sx ^ sy ^ sd == 0 ? -int256(rAbs) : int256(rAbs);\n    }\n}\n\n/// @notice Calculates the binary exponent of x using the binary fraction method.\n/// @dev Has to use 192.64-bit fixed-point numbers.\n/// See https://ethereum.stackexchange.com/a/96594/24693.\n/// @param x The exponent as an unsigned 192.64-bit fixed-point number.\n/// @return result The result as an unsigned 60.18-decimal fixed-point number.\nfunction prbExp2(uint256 x) pure returns (uint256 result) {\n    unchecked {\n        // Start from 0.5 in the 192.64-bit fixed-point format.\n        result = 0x800000000000000000000000000000000000000000000000;\n\n        // Multiply the result by root(2, 2^-i) when the bit at position i is 1. None of the intermediary results overflows\n        // because the initial result is 2^191 and all magic factors are less than 2^65.\n        if (x & 0xFF00000000000000 > 0) {\n            if (x & 0x8000000000000000 > 0) {\n                result = (result * 0x16A09E667F3BCC909) >> 64;\n            }\n            if (x & 0x4000000000000000 > 0) {\n                result = (result * 0x1306FE0A31B7152DF) >> 64;\n            }\n            if (x & 0x2000000000000000 > 0) {\n                result = (result * 0x1172B83C7D517ADCE) >> 64;\n            }\n            if (x & 0x1000000000000000 > 0) {\n                result = (result * 0x10B5586CF9890F62A) >> 64;\n            }\n            if (x & 0x800000000000000 > 0) {\n                result = (result * 0x1059B0D31585743AE) >> 64;\n            }\n            if (x & 0x400000000000000 > 0) {\n                result = (result * 0x102C9A3E778060EE7) >> 64;\n            }\n            if (x & 0x200000000000000 > 0) {\n                result = (result * 0x10163DA9FB33356D8) >> 64;\n            }\n            if (x & 0x100000000000000 > 0) {\n                result = (result * 0x100B1AFA5ABCBED61) >> 64;\n            }\n        }\n\n        if (x & 0xFF000000000000 > 0) {\n            if (x & 0x80000000000000 > 0) {\n                result = (result * 0x10058C86DA1C09EA2) >> 64;\n            }\n            if (x & 0x40000000000000 > 0) {\n                result = (result * 0x1002C605E2E8CEC50) >> 64;\n            }\n            if (x & 0x20000000000000 > 0) {\n                result = (result * 0x100162F3904051FA1) >> 64;\n            }\n            if (x & 0x10000000000000 > 0) {\n                result = (result * 0x1000B175EFFDC76BA) >> 64;\n            }\n            if (x & 0x8000000000000 > 0) {\n                result = (result * 0x100058BA01FB9F96D) >> 64;\n            }\n            if (x & 0x4000000000000 > 0) {\n                result = (result * 0x10002C5CC37DA9492) >> 64;\n            }\n            if (x & 0x2000000000000 > 0) {\n                result = (result * 0x1000162E525EE0547) >> 64;\n            }\n            if (x & 0x1000000000000 > 0) {\n                result = (result * 0x10000B17255775C04) >> 64;\n            }\n        }\n\n        if (x & 0xFF0000000000 > 0) {\n            if (x & 0x800000000000 > 0) {\n                result = (result * 0x1000058B91B5BC9AE) >> 64;\n            }\n            if (x & 0x400000000000 > 0) {\n                result = (result * 0x100002C5C89D5EC6D) >> 64;\n            }\n            if (x & 0x200000000000 > 0) {\n                result = (result * 0x10000162E43F4F831) >> 64;\n            }\n            if (x & 0x100000000000 > 0) {\n                result = (result * 0x100000B1721BCFC9A) >> 64;\n            }\n            if (x & 0x80000000000 > 0) {\n                result = (result * 0x10000058B90CF1E6E) >> 64;\n            }\n            if (x & 0x40000000000 > 0) {\n                result = (result * 0x1000002C5C863B73F) >> 64;\n            }\n            if (x & 0x20000000000 > 0) {\n                result = (result * 0x100000162E430E5A2) >> 64;\n            }\n            if (x & 0x10000000000 > 0) {\n                result = (result * 0x1000000B172183551) >> 64;\n            }\n        }\n\n        if (x & 0xFF00000000 > 0) {\n            if (x & 0x8000000000 > 0) {\n                result = (result * 0x100000058B90C0B49) >> 64;\n            }\n            if (x & 0x4000000000 > 0) {\n                result = (result * 0x10000002C5C8601CC) >> 64;\n            }\n            if (x & 0x2000000000 > 0) {\n                result = (result * 0x1000000162E42FFF0) >> 64;\n            }\n            if (x & 0x1000000000 > 0) {\n                result = (result * 0x10000000B17217FBB) >> 64;\n            }\n            if (x & 0x800000000 > 0) {\n                result = (result * 0x1000000058B90BFCE) >> 64;\n            }\n            if (x & 0x400000000 > 0) {\n                result = (result * 0x100000002C5C85FE3) >> 64;\n            }\n            if (x & 0x200000000 > 0) {\n                result = (result * 0x10000000162E42FF1) >> 64;\n            }\n            if (x & 0x100000000 > 0) {\n                result = (result * 0x100000000B17217F8) >> 64;\n            }\n        }\n\n        if (x & 0xFF00000000 > 0) {\n            if (x & 0x80000000 > 0) {\n                result = (result * 0x10000000058B90BFC) >> 64;\n            }\n            if (x & 0x40000000 > 0) {\n                result = (result * 0x1000000002C5C85FE) >> 64;\n            }\n            if (x & 0x20000000 > 0) {\n                result = (result * 0x100000000162E42FF) >> 64;\n            }\n            if (x & 0x10000000 > 0) {\n                result = (result * 0x1000000000B17217F) >> 64;\n            }\n            if (x & 0x8000000 > 0) {\n                result = (result * 0x100000000058B90C0) >> 64;\n            }\n            if (x & 0x4000000 > 0) {\n                result = (result * 0x10000000002C5C860) >> 64;\n            }\n            if (x & 0x2000000 > 0) {\n                result = (result * 0x1000000000162E430) >> 64;\n            }\n            if (x & 0x1000000 > 0) {\n                result = (result * 0x10000000000B17218) >> 64;\n            }\n        }\n\n        if (x & 0xFF0000 > 0) {\n            if (x & 0x800000 > 0) {\n                result = (result * 0x1000000000058B90C) >> 64;\n            }\n            if (x & 0x400000 > 0) {\n                result = (result * 0x100000000002C5C86) >> 64;\n            }\n            if (x & 0x200000 > 0) {\n                result = (result * 0x10000000000162E43) >> 64;\n            }\n            if (x & 0x100000 > 0) {\n                result = (result * 0x100000000000B1721) >> 64;\n            }\n            if (x & 0x80000 > 0) {\n                result = (result * 0x10000000000058B91) >> 64;\n            }\n            if (x & 0x40000 > 0) {\n                result = (result * 0x1000000000002C5C8) >> 64;\n            }\n            if (x & 0x20000 > 0) {\n                result = (result * 0x100000000000162E4) >> 64;\n            }\n            if (x & 0x10000 > 0) {\n                result = (result * 0x1000000000000B172) >> 64;\n            }\n        }\n\n        if (x & 0xFF00 > 0) {\n            if (x & 0x8000 > 0) {\n                result = (result * 0x100000000000058B9) >> 64;\n            }\n            if (x & 0x4000 > 0) {\n                result = (result * 0x10000000000002C5D) >> 64;\n            }\n            if (x & 0x2000 > 0) {\n                result = (result * 0x1000000000000162E) >> 64;\n            }\n            if (x & 0x1000 > 0) {\n                result = (result * 0x10000000000000B17) >> 64;\n            }\n            if (x & 0x800 > 0) {\n                result = (result * 0x1000000000000058C) >> 64;\n            }\n            if (x & 0x400 > 0) {\n                result = (result * 0x100000000000002C6) >> 64;\n            }\n            if (x & 0x200 > 0) {\n                result = (result * 0x10000000000000163) >> 64;\n            }\n            if (x & 0x100 > 0) {\n                result = (result * 0x100000000000000B1) >> 64;\n            }\n        }\n\n        if (x & 0xFF > 0) {\n            if (x & 0x80 > 0) {\n                result = (result * 0x10000000000000059) >> 64;\n            }\n            if (x & 0x40 > 0) {\n                result = (result * 0x1000000000000002C) >> 64;\n            }\n            if (x & 0x20 > 0) {\n                result = (result * 0x10000000000000016) >> 64;\n            }\n            if (x & 0x10 > 0) {\n                result = (result * 0x1000000000000000B) >> 64;\n            }\n            if (x & 0x8 > 0) {\n                result = (result * 0x10000000000000006) >> 64;\n            }\n            if (x & 0x4 > 0) {\n                result = (result * 0x10000000000000003) >> 64;\n            }\n            if (x & 0x2 > 0) {\n                result = (result * 0x10000000000000001) >> 64;\n            }\n            if (x & 0x1 > 0) {\n                result = (result * 0x10000000000000001) >> 64;\n            }\n        }\n\n        // We're doing two things at the same time:\n        //\n        //   1. Multiply the result by 2^n + 1, where \"2^n\" is the integer part and the one is added to account for\n        //      the fact that we initially set the result to 0.5. This is accomplished by subtracting from 191\n        //      rather than 192.\n        //   2. Convert the result to the unsigned 60.18-decimal fixed-point format.\n        //\n        // This works because 2^(191-ip) = 2^ip / 2^191, where \"ip\" is the integer part \"2^n\".\n        result *= UNIT;\n        result >>= (191 - (x >> 64));\n    }\n}\n\n/// @notice Calculates the square root of x, rounding down if x is not a perfect square.\n/// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\n/// Credits to OpenZeppelin for the explanations in code comments below.\n///\n/// Caveats:\n/// - This function does not work with fixed-point numbers.\n///\n/// @param x The uint256 number for which to calculate the square root.\n/// @return result The result as an uint256.\nfunction prbSqrt(uint256 x) pure returns (uint256 result) {\n    if (x == 0) {\n        return 0;\n    }\n\n    // For our first guess, we get the biggest power of 2 which is smaller than the square root of x.\n    //\n    // We know that the \"msb\" (most significant bit) of x is a power of 2 such that we have:\n    //\n    // $$\n    // msb(x) <= x <= 2*msb(x)$\n    // $$\n    //\n    // We write $msb(x)$ as $2^k$ and we get:\n    //\n    // $$\n    // k = log_2(x)\n    // $$\n    //\n    // Thus we can write the initial inequality as:\n    //\n    // $$\n    // 2^{log_2(x)} <= x <= 2*2^{log_2(x)+1} \\\\\n    // sqrt(2^k) <= sqrt(x) < sqrt(2^{k+1}) \\\\\n    // 2^{k/2} <= sqrt(x) < 2^{(k+1)/2} <= 2^{(k/2)+1}\n    // $$\n    //\n    // Consequently, $2^{log_2(x) /2}` is a good first approximation of sqrt(x) with at least one correct bit.\n    uint256 xAux = uint256(x);\n    result = 1;\n    if (xAux >= 2 ** 128) {\n        xAux >>= 128;\n        result <<= 64;\n    }\n    if (xAux >= 2 ** 64) {\n        xAux >>= 64;\n        result <<= 32;\n    }\n    if (xAux >= 2 ** 32) {\n        xAux >>= 32;\n        result <<= 16;\n    }\n    if (xAux >= 2 ** 16) {\n        xAux >>= 16;\n        result <<= 8;\n    }\n    if (xAux >= 2 ** 8) {\n        xAux >>= 8;\n        result <<= 4;\n    }\n    if (xAux >= 2 ** 4) {\n        xAux >>= 4;\n        result <<= 2;\n    }\n    if (xAux >= 2 ** 2) {\n        result <<= 1;\n    }\n\n    // At this point, `result` is an estimation with at least one bit of precision. We know the true value has at\n    // most 128 bits, since  it is the square root of a uint256. Newton's method converges quadratically (precision\n    // doubles at every iteration). We thus need at most 7 iteration to turn our partial result with one bit of\n    // precision into the expected uint128 result.\n    unchecked {\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n\n        // Round down the result in case x is not a perfect square.\n        uint256 roundedDownResult = x / result;\n        if (result >= roundedDownResult) {\n            result = roundedDownResult;\n        }\n    }\n}\n"},"@openzeppelin/contracts-upgradeable/access/IAccessControlEnumerableUpgradeable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerableUpgradeable is IAccessControlUpgradeable {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n"},"@prb/math/src/ud60x18/Math.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport { msb, mulDiv, mulDiv18, prbExp2, prbSqrt } from \"../Common.sol\";\nimport { unwrap, wrap } from \"./Casting.sol\";\nimport { uHALF_UNIT, uLOG2_10, uLOG2_E, uMAX_UD60x18, uMAX_WHOLE_UD60x18, UNIT, uUNIT, ZERO } from \"./Constants.sol\";\nimport {\n    PRBMath_UD60x18_Ceil_Overflow,\n    PRBMath_UD60x18_Exp_InputTooBig,\n    PRBMath_UD60x18_Exp2_InputTooBig,\n    PRBMath_UD60x18_Gm_Overflow,\n    PRBMath_UD60x18_Log_InputTooSmall,\n    PRBMath_UD60x18_Sqrt_Overflow\n} from \"./Errors.sol\";\nimport { UD60x18 } from \"./ValueType.sol\";\n\n/*//////////////////////////////////////////////////////////////////////////\n                            MATHEMATICAL FUNCTIONS\n//////////////////////////////////////////////////////////////////////////*/\n\n/// @notice Calculates the arithmetic average of x and y, rounding down.\n///\n/// @dev Based on the formula:\n///\n/// $$\n/// avg(x, y) = (x & y) + ((xUint ^ yUint) / 2)\n/// $$\n//\n/// In English, what this formula does is:\n///\n/// 1. AND x and y.\n/// 2. Calculate half of XOR x and y.\n/// 3. Add the two results together.\n///\n/// This technique is known as SWAR, which stands for \"SIMD within a register\". You can read more about it here:\n/// https://devblogs.microsoft.com/oldnewthing/20220207-00/?p=106223\n///\n/// @param x The first operand as an UD60x18 number.\n/// @param y The second operand as an UD60x18 number.\n/// @return result The arithmetic average as an UD60x18 number.\nfunction avg(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\n    uint256 xUint = unwrap(x);\n    uint256 yUint = unwrap(y);\n    unchecked {\n        result = wrap((xUint & yUint) + ((xUint ^ yUint) >> 1));\n    }\n}\n\n/// @notice Yields the smallest whole UD60x18 number greater than or equal to x.\n///\n/// @dev This is optimized for fractional value inputs, because for every whole value there are \"1e18 - 1\" fractional\n/// counterparts. See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\n///\n/// Requirements:\n/// - x must be less than or equal to `MAX_WHOLE_UD60x18`.\n///\n/// @param x The UD60x18 number to ceil.\n/// @param result The least number greater than or equal to x, as an UD60x18 number.\nfunction ceil(UD60x18 x) pure returns (UD60x18 result) {\n    uint256 xUint = unwrap(x);\n    if (xUint > uMAX_WHOLE_UD60x18) {\n        revert PRBMath_UD60x18_Ceil_Overflow(x);\n    }\n\n    assembly (\"memory-safe\") {\n        // Equivalent to \"x % UNIT\" but faster.\n        let remainder := mod(x, uUNIT)\n\n        // Equivalent to \"UNIT - remainder\" but faster.\n        let delta := sub(uUNIT, remainder)\n\n        // Equivalent to \"x + delta * (remainder > 0 ? 1 : 0)\" but faster.\n        result := add(x, mul(delta, gt(remainder, 0)))\n    }\n}\n\n/// @notice Divides two UD60x18 numbers, returning a new UD60x18 number. Rounds towards zero.\n///\n/// @dev Uses `mulDiv` to enable overflow-safe multiplication and division.\n///\n/// Requirements:\n/// - The denominator cannot be zero.\n///\n/// @param x The numerator as an UD60x18 number.\n/// @param y The denominator as an UD60x18 number.\n/// @param result The quotient as an UD60x18 number.\nfunction div(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\n    result = wrap(mulDiv(unwrap(x), uUNIT, unwrap(y)));\n}\n\n/// @notice Calculates the natural exponent of x.\n///\n/// @dev Based on the formula:\n///\n/// $$\n/// e^x = 2^{x * log_2{e}}\n/// $$\n///\n/// Requirements:\n/// - All from `log2`.\n/// - x must be less than 133.084258667509499441.\n///\n/// @param x The exponent as an UD60x18 number.\n/// @return result The result as an UD60x18 number.\nfunction exp(UD60x18 x) pure returns (UD60x18 result) {\n    uint256 xUint = unwrap(x);\n\n    // Without this check, the value passed to `exp2` would be greater than 192.\n    if (xUint >= 133_084258667509499441) {\n        revert PRBMath_UD60x18_Exp_InputTooBig(x);\n    }\n\n    unchecked {\n        // We do the fixed-point multiplication inline rather than via the `mul` function to save gas.\n        uint256 doubleUnitProduct = xUint * uLOG2_E;\n        result = exp2(wrap(doubleUnitProduct / uUNIT));\n    }\n}\n\n/// @notice Calculates the binary exponent of x using the binary fraction method.\n///\n/// @dev See https://ethereum.stackexchange.com/q/79903/24693.\n///\n/// Requirements:\n/// - x must be 192 or less.\n/// - The result must fit within `MAX_UD60x18`.\n///\n/// @param x The exponent as an UD60x18 number.\n/// @return result The result as an UD60x18 number.\nfunction exp2(UD60x18 x) pure returns (UD60x18 result) {\n    uint256 xUint = unwrap(x);\n\n    // Numbers greater than or equal to 2^192 don't fit within the 192.64-bit format.\n    if (xUint >= 192e18) {\n        revert PRBMath_UD60x18_Exp2_InputTooBig(x);\n    }\n\n    // Convert x to the 192.64-bit fixed-point format.\n    uint256 x_192x64 = (xUint << 64) / uUNIT;\n\n    // Pass x to the `prbExp2` function, which uses the 192.64-bit fixed-point number representation.\n    result = wrap(prbExp2(x_192x64));\n}\n\n/// @notice Yields the greatest whole UD60x18 number less than or equal to x.\n/// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\n/// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\n/// @param x The UD60x18 number to floor.\n/// @param result The greatest integer less than or equal to x, as an UD60x18 number.\nfunction floor(UD60x18 x) pure returns (UD60x18 result) {\n    assembly (\"memory-safe\") {\n        // Equivalent to \"x % UNIT\" but faster.\n        let remainder := mod(x, uUNIT)\n\n        // Equivalent to \"x - remainder * (remainder > 0 ? 1 : 0)\" but faster.\n        result := sub(x, mul(remainder, gt(remainder, 0)))\n    }\n}\n\n/// @notice Yields the excess beyond the floor of x.\n/// @dev Based on the odd function definition https://en.wikipedia.org/wiki/Fractional_part.\n/// @param x The UD60x18 number to get the fractional part of.\n/// @param result The fractional part of x as an UD60x18 number.\nfunction frac(UD60x18 x) pure returns (UD60x18 result) {\n    assembly (\"memory-safe\") {\n        result := mod(x, uUNIT)\n    }\n}\n\n/// @notice Calculates the geometric mean of x and y, i.e. $$sqrt(x * y)$$, rounding down.\n///\n/// @dev Requirements:\n/// - x * y must fit within `MAX_UD60x18`, lest it overflows.\n///\n/// @param x The first operand as an UD60x18 number.\n/// @param y The second operand as an UD60x18 number.\n/// @return result The result as an UD60x18 number.\nfunction gm(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\n    uint256 xUint = unwrap(x);\n    uint256 yUint = unwrap(y);\n    if (xUint == 0 || yUint == 0) {\n        return ZERO;\n    }\n\n    unchecked {\n        // Checking for overflow this way is faster than letting Solidity do it.\n        uint256 xyUint = xUint * yUint;\n        if (xyUint / xUint != yUint) {\n            revert PRBMath_UD60x18_Gm_Overflow(x, y);\n        }\n\n        // We don't need to multiply the result by `UNIT` here because the x*y product had picked up a factor of `UNIT`\n        // during multiplication. See the comments in the `prbSqrt` function.\n        result = wrap(prbSqrt(xyUint));\n    }\n}\n\n/// @notice Calculates 1 / x, rounding toward zero.\n///\n/// @dev Requirements:\n/// - x cannot be zero.\n///\n/// @param x The UD60x18 number for which to calculate the inverse.\n/// @return result The inverse as an UD60x18 number.\nfunction inv(UD60x18 x) pure returns (UD60x18 result) {\n    unchecked {\n        // 1e36 is UNIT * UNIT.\n        result = wrap(1e36 / unwrap(x));\n    }\n}\n\n/// @notice Calculates the natural logarithm of x.\n///\n/// @dev Based on the formula:\n///\n/// $$\n/// ln{x} = log_2{x} / log_2{e}$$.\n/// $$\n///\n/// Requirements:\n/// - All from `log2`.\n///\n/// Caveats:\n/// - All from `log2`.\n/// - This doesn't return exactly 1 for 2.718281828459045235, for that more fine-grained precision is needed.\n///\n/// @param x The UD60x18 number for which to calculate the natural logarithm.\n/// @return result The natural logarithm as an UD60x18 number.\nfunction ln(UD60x18 x) pure returns (UD60x18 result) {\n    unchecked {\n        // We do the fixed-point multiplication inline to save gas. This is overflow-safe because the maximum value\n        // that `log2` can return is 196.205294292027477728.\n        result = wrap((unwrap(log2(x)) * uUNIT) / uLOG2_E);\n    }\n}\n\n/// @notice Calculates the common logarithm of x.\n///\n/// @dev First checks if x is an exact power of ten and it stops if yes. If it's not, calculates the common\n/// logarithm based on the formula:\n///\n/// $$\n/// log_{10}{x} = log_2{x} / log_2{10}\n/// $$\n///\n/// Requirements:\n/// - All from `log2`.\n///\n/// Caveats:\n/// - All from `log2`.\n///\n/// @param x The UD60x18 number for which to calculate the common logarithm.\n/// @return result The common logarithm as an UD60x18 number.\nfunction log10(UD60x18 x) pure returns (UD60x18 result) {\n    uint256 xUint = unwrap(x);\n    if (xUint < uUNIT) {\n        revert PRBMath_UD60x18_Log_InputTooSmall(x);\n    }\n\n    // Note that the `mul` in this assembly block is the assembly multiplication operation, not the UD60x18 `mul`.\n    // prettier-ignore\n    assembly (\"memory-safe\") {\n        switch x\n        case 1 { result := mul(uUNIT, sub(0, 18)) }\n        case 10 { result := mul(uUNIT, sub(1, 18)) }\n        case 100 { result := mul(uUNIT, sub(2, 18)) }\n        case 1000 { result := mul(uUNIT, sub(3, 18)) }\n        case 10000 { result := mul(uUNIT, sub(4, 18)) }\n        case 100000 { result := mul(uUNIT, sub(5, 18)) }\n        case 1000000 { result := mul(uUNIT, sub(6, 18)) }\n        case 10000000 { result := mul(uUNIT, sub(7, 18)) }\n        case 100000000 { result := mul(uUNIT, sub(8, 18)) }\n        case 1000000000 { result := mul(uUNIT, sub(9, 18)) }\n        case 10000000000 { result := mul(uUNIT, sub(10, 18)) }\n        case 100000000000 { result := mul(uUNIT, sub(11, 18)) }\n        case 1000000000000 { result := mul(uUNIT, sub(12, 18)) }\n        case 10000000000000 { result := mul(uUNIT, sub(13, 18)) }\n        case 100000000000000 { result := mul(uUNIT, sub(14, 18)) }\n        case 1000000000000000 { result := mul(uUNIT, sub(15, 18)) }\n        case 10000000000000000 { result := mul(uUNIT, sub(16, 18)) }\n        case 100000000000000000 { result := mul(uUNIT, sub(17, 18)) }\n        case 1000000000000000000 { result := 0 }\n        case 10000000000000000000 { result := uUNIT }\n        case 100000000000000000000 { result := mul(uUNIT, 2) }\n        case 1000000000000000000000 { result := mul(uUNIT, 3) }\n        case 10000000000000000000000 { result := mul(uUNIT, 4) }\n        case 100000000000000000000000 { result := mul(uUNIT, 5) }\n        case 1000000000000000000000000 { result := mul(uUNIT, 6) }\n        case 10000000000000000000000000 { result := mul(uUNIT, 7) }\n        case 100000000000000000000000000 { result := mul(uUNIT, 8) }\n        case 1000000000000000000000000000 { result := mul(uUNIT, 9) }\n        case 10000000000000000000000000000 { result := mul(uUNIT, 10) }\n        case 100000000000000000000000000000 { result := mul(uUNIT, 11) }\n        case 1000000000000000000000000000000 { result := mul(uUNIT, 12) }\n        case 10000000000000000000000000000000 { result := mul(uUNIT, 13) }\n        case 100000000000000000000000000000000 { result := mul(uUNIT, 14) }\n        case 1000000000000000000000000000000000 { result := mul(uUNIT, 15) }\n        case 10000000000000000000000000000000000 { result := mul(uUNIT, 16) }\n        case 100000000000000000000000000000000000 { result := mul(uUNIT, 17) }\n        case 1000000000000000000000000000000000000 { result := mul(uUNIT, 18) }\n        case 10000000000000000000000000000000000000 { result := mul(uUNIT, 19) }\n        case 100000000000000000000000000000000000000 { result := mul(uUNIT, 20) }\n        case 1000000000000000000000000000000000000000 { result := mul(uUNIT, 21) }\n        case 10000000000000000000000000000000000000000 { result := mul(uUNIT, 22) }\n        case 100000000000000000000000000000000000000000 { result := mul(uUNIT, 23) }\n        case 1000000000000000000000000000000000000000000 { result := mul(uUNIT, 24) }\n        case 10000000000000000000000000000000000000000000 { result := mul(uUNIT, 25) }\n        case 100000000000000000000000000000000000000000000 { result := mul(uUNIT, 26) }\n        case 1000000000000000000000000000000000000000000000 { result := mul(uUNIT, 27) }\n        case 10000000000000000000000000000000000000000000000 { result := mul(uUNIT, 28) }\n        case 100000000000000000000000000000000000000000000000 { result := mul(uUNIT, 29) }\n        case 1000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 30) }\n        case 10000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 31) }\n        case 100000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 32) }\n        case 1000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 33) }\n        case 10000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 34) }\n        case 100000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 35) }\n        case 1000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 36) }\n        case 10000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 37) }\n        case 100000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 38) }\n        case 1000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 39) }\n        case 10000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 40) }\n        case 100000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 41) }\n        case 1000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 42) }\n        case 10000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 43) }\n        case 100000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 44) }\n        case 1000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 45) }\n        case 10000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 46) }\n        case 100000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 47) }\n        case 1000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 48) }\n        case 10000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 49) }\n        case 100000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 50) }\n        case 1000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 51) }\n        case 10000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 52) }\n        case 100000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 53) }\n        case 1000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 54) }\n        case 10000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 55) }\n        case 100000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 56) }\n        case 1000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 57) }\n        case 10000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 58) }\n        case 100000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 59) }\n        default {\n            result := uMAX_UD60x18\n        }\n    }\n\n    if (unwrap(result) == uMAX_UD60x18) {\n        unchecked {\n            // Do the fixed-point division inline to save gas.\n            result = wrap((unwrap(log2(x)) * uUNIT) / uLOG2_10);\n        }\n    }\n}\n\n/// @notice Calculates the binary logarithm of x.\n///\n/// @dev Based on the iterative approximation algorithm.\n/// https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation\n///\n/// Requirements:\n/// - x must be greater than or equal to UNIT, otherwise the result would be negative.\n///\n/// Caveats:\n/// - The results are nor perfectly accurate to the last decimal, due to the lossy precision of the iterative approximation.\n///\n/// @param x The UD60x18 number for which to calculate the binary logarithm.\n/// @return result The binary logarithm as an UD60x18 number.\nfunction log2(UD60x18 x) pure returns (UD60x18 result) {\n    uint256 xUint = unwrap(x);\n\n    if (xUint < uUNIT) {\n        revert PRBMath_UD60x18_Log_InputTooSmall(x);\n    }\n\n    unchecked {\n        // Calculate the integer part of the logarithm, add it to the result and finally calculate y = x * 2^(-n).\n        uint256 n = msb(xUint / uUNIT);\n\n        // This is the integer part of the logarithm as an UD60x18 number. The operation can't overflow because n\n        // n is maximum 255 and UNIT is 1e18.\n        uint256 resultUint = n * uUNIT;\n\n        // This is $y = x * 2^{-n}$.\n        uint256 y = xUint >> n;\n\n        // If y is 1, the fractional part is zero.\n        if (y == uUNIT) {\n            return wrap(resultUint);\n        }\n\n        // Calculate the fractional part via the iterative approximation.\n        // The \"delta.rshift(1)\" part is equivalent to \"delta /= 2\", but shifting bits is faster.\n        uint256 DOUBLE_UNIT = 2e18;\n        for (uint256 delta = uHALF_UNIT; delta > 0; delta >>= 1) {\n            y = (y * y) / uUNIT;\n\n            // Is y^2 > 2 and so in the range [2,4)?\n            if (y >= DOUBLE_UNIT) {\n                // Add the 2^{-m} factor to the logarithm.\n                resultUint += delta;\n\n                // Corresponds to z/2 on Wikipedia.\n                y >>= 1;\n            }\n        }\n        result = wrap(resultUint);\n    }\n}\n\n/// @notice Multiplies two UD60x18 numbers together, returning a new UD60x18 number.\n/// @dev See the documentation for the `Common.mulDiv18` function.\n/// @param x The multiplicand as an UD60x18 number.\n/// @param y The multiplier as an UD60x18 number.\n/// @return result The product as an UD60x18 number.\nfunction mul(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\n    result = wrap(mulDiv18(unwrap(x), unwrap(y)));\n}\n\n/// @notice Raises x to the power of y.\n///\n/// @dev Based on the formula:\n///\n/// $$\n/// x^y = 2^{log_2{x} * y}\n/// $$\n///\n/// Requirements:\n/// - All from `exp2`, `log2` and `mul`.\n///\n/// Caveats:\n/// - All from `exp2`, `log2` and `mul`.\n/// - Assumes 0^0 is 1.\n///\n/// @param x Number to raise to given power y, as an UD60x18 number.\n/// @param y Exponent to raise x to, as an UD60x18 number.\n/// @return result x raised to power y, as an UD60x18 number.\nfunction pow(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\n    uint256 xUint = unwrap(x);\n    uint256 yUint = unwrap(y);\n\n    if (xUint == 0) {\n        result = yUint == 0 ? UNIT : ZERO;\n    } else {\n        if (yUint == uUNIT) {\n            result = x;\n        } else {\n            result = exp2(mul(log2(x), y));\n        }\n    }\n}\n\n/// @notice Raises x (an UD60x18 number) to the power y (unsigned basic integer) using the famous algorithm\n/// \"exponentiation by squaring\".\n///\n/// @dev See https://en.wikipedia.org/wiki/Exponentiation_by_squaring\n///\n/// Requirements:\n/// - The result must fit within `MAX_UD60x18`.\n///\n/// Caveats:\n/// - All from \"Common.mulDiv18\".\n/// - Assumes 0^0 is 1.\n///\n/// @param x The base as an UD60x18 number.\n/// @param y The exponent as an uint256.\n/// @return result The result as an UD60x18 number.\nfunction powu(UD60x18 x, uint256 y) pure returns (UD60x18 result) {\n    // Calculate the first iteration of the loop in advance.\n    uint256 xUint = unwrap(x);\n    uint256 resultUint = y & 1 > 0 ? xUint : uUNIT;\n\n    // Equivalent to \"for(y /= 2; y > 0; y /= 2)\" but faster.\n    for (y >>= 1; y > 0; y >>= 1) {\n        xUint = mulDiv18(xUint, xUint);\n\n        // Equivalent to \"y % 2 == 1\" but faster.\n        if (y & 1 > 0) {\n            resultUint = mulDiv18(resultUint, xUint);\n        }\n    }\n    result = wrap(resultUint);\n}\n\n/// @notice Calculates the square root of x, rounding down.\n/// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\n///\n/// Requirements:\n/// - x must be less than `MAX_UD60x18` divided by `UNIT`.\n///\n/// @param x The UD60x18 number for which to calculate the square root.\n/// @return result The result as an UD60x18 number.\nfunction sqrt(UD60x18 x) pure returns (UD60x18 result) {\n    uint256 xUint = unwrap(x);\n\n    unchecked {\n        if (xUint > uMAX_UD60x18 / uUNIT) {\n            revert PRBMath_UD60x18_Sqrt_Overflow(x);\n        }\n        // Multiply x by `UNIT` to account for the factor of `UNIT` that is picked up when multiplying two UD60x18\n        // numbers together (in this case, the two numbers are both the square root).\n        result = wrap(prbSqrt(xUint * uUNIT));\n    }\n}\n"},"contracts/implementations/RswETH.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.16;\r\n\r\nimport {UD60x18, wrap} from \"@prb/math/src/UD60x18.sol\";\r\nimport {ERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\r\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\r\nimport {AddressUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\r\nimport {EnumerableSetUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\r\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\nimport {Whitelist} from \"./Whitelist.sol\";\r\n\r\nimport {SwellLib} from \"../libraries/SwellLib.sol\";\r\n\r\nimport {IrswETH} from \"../interfaces/IrswETH.sol\";\r\nimport {IAccessControlManager} from \"../interfaces/IAccessControlManager.sol\";\r\nimport {INodeOperatorRegistry} from \"../interfaces/INodeOperatorRegistry.sol\";\r\nimport {IRateProvider} from \"../vendors/IRateProvider.sol\";\r\n\r\n/**\r\n * @title rswETH\r\n * @notice Contract for handling user deposits in ETH in exchange for rswETH at the stored rate. Also handles the rate updates from the BOT wallet which will occur at a fixed interval.\r\n * @author https://github.com/max-taylor\r\n * @dev This contract inherits the Whitelist contract which holds the Access control manager state variable and the checkRole modifier\r\n */\r\ncontract RswETH is\r\n  Initializable,\r\n  Whitelist,\r\n  IrswETH,\r\n  IRateProvider,\r\n  ERC20Upgradeable\r\n{\r\n  using SafeERC20 for IERC20;\r\n  using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\r\n\r\n  uint256 public override lastRepriceETHReserves;\r\n  uint256 private rswETHToETHRateFixed;\r\n\r\n  uint256 public override swellTreasuryRewardPercentage;\r\n  uint256 public override nodeOperatorRewardPercentage;\r\n\r\n  uint256 public override lastRepriceUNIX;\r\n\r\n  uint256 public override totalETHDeposited;\r\n\r\n  uint256 public override minimumRepriceTime;\r\n  uint256 public override maximumRepriceDifferencePercentage;\r\n  uint256 public override maximumRepriceRswETHDifferencePercentage;\r\n\r\n  /// @custom:oz-upgrades-unsafe-allow constructor\r\n  constructor() {\r\n    _disableInitializers();\r\n  }\r\n\r\n  fallback() external {\r\n    revert SwellLib.InvalidMethodCall();\r\n  }\r\n\r\n  function initialize(\r\n    IAccessControlManager _accessControlManager\r\n  ) external initializer checkZeroAddress(address(_accessControlManager)) {\r\n    __ERC20_init(\"rswETH\", \"rswETH\");\r\n\r\n    __Whitelist_init(_accessControlManager);\r\n  }\r\n\r\n  // ************************************\r\n  // ***** External methods ******\r\n\r\n  function withdrawERC20(\r\n    IERC20 _token\r\n  ) external override checkRole(SwellLib.PLATFORM_ADMIN) {\r\n    uint256 contractBalance = _token.balanceOf(address(this));\r\n    if (contractBalance == 0) {\r\n      revert SwellLib.NoTokensToWithdraw();\r\n    }\r\n\r\n    _token.safeTransfer(msg.sender, contractBalance);\r\n  }\r\n\r\n  function setSwellTreasuryRewardPercentage(\r\n    uint256 _newSwellTreasuryRewardPercentage\r\n  ) external override checkRole(SwellLib.PLATFORM_ADMIN) {\r\n    // Joined percentage total cannot exceed 100% (1 ether)\r\n    if (\r\n      nodeOperatorRewardPercentage + _newSwellTreasuryRewardPercentage > 1 ether\r\n    ) {\r\n      revert RewardPercentageTotalOverflow();\r\n    }\r\n\r\n    emit SwellTreasuryRewardPercentageUpdate(\r\n      swellTreasuryRewardPercentage,\r\n      _newSwellTreasuryRewardPercentage\r\n    );\r\n\r\n    swellTreasuryRewardPercentage = _newSwellTreasuryRewardPercentage;\r\n  }\r\n\r\n  function setNodeOperatorRewardPercentage(\r\n    uint256 _newNodeOperatorRewardPercentage\r\n  ) external override checkRole(SwellLib.PLATFORM_ADMIN) {\r\n    // Joined percentage total cannot exceed 100% (1 ether)\r\n    if (\r\n      swellTreasuryRewardPercentage + _newNodeOperatorRewardPercentage > 1 ether\r\n    ) {\r\n      revert RewardPercentageTotalOverflow();\r\n    }\r\n\r\n    emit NodeOperatorRewardPercentageUpdate(\r\n      nodeOperatorRewardPercentage,\r\n      _newNodeOperatorRewardPercentage\r\n    );\r\n\r\n    nodeOperatorRewardPercentage = _newNodeOperatorRewardPercentage;\r\n  }\r\n\r\n  function setMinimumRepriceTime(\r\n    uint256 _minimumRepriceTime\r\n  ) external checkRole(SwellLib.PLATFORM_ADMIN) {\r\n    emit MinimumRepriceTimeUpdated(minimumRepriceTime, _minimumRepriceTime);\r\n\r\n    minimumRepriceTime = _minimumRepriceTime;\r\n  }\r\n\r\n  function setMaximumRepriceRswETHDifferencePercentage(\r\n    uint256 _maximumRepriceRswETHDifferencePercentage\r\n  ) external checkRole(SwellLib.PLATFORM_ADMIN) {\r\n    emit MaximumRepriceRswETHDifferencePercentageUpdated(\r\n      maximumRepriceRswETHDifferencePercentage,\r\n      _maximumRepriceRswETHDifferencePercentage\r\n    );\r\n\r\n    maximumRepriceRswETHDifferencePercentage = _maximumRepriceRswETHDifferencePercentage;\r\n  }\r\n\r\n  function setMaximumRepriceDifferencePercentage(\r\n    uint256 _maximumRepriceDifferencePercentage\r\n  ) external checkRole(SwellLib.PLATFORM_ADMIN) {\r\n    emit MaximumRepriceDifferencePercentageUpdated(\r\n      maximumRepriceDifferencePercentage,\r\n      _maximumRepriceDifferencePercentage\r\n    );\r\n\r\n    maximumRepriceDifferencePercentage = _maximumRepriceDifferencePercentage;\r\n  }\r\n\r\n  function rswETHToETHRate() external view override returns (uint256) {\r\n    return _rswETHToETHRate().unwrap();\r\n  }\r\n\r\n  function ethToRswETHRate() external view override returns (uint256) {\r\n    return _ethToRswETHRate().unwrap();\r\n  }\r\n\r\n  function getRate() external view override returns (uint256) {\r\n    // This method is identical to swETHToETHRate but is required for the Balancer Metastable pools. Keeping this and the swETHToETHRate method because the swETHToETHRate method is more readable for integrations.\r\n    return _rswETHToETHRate().unwrap();\r\n  }\r\n\r\n  function _deposit(address referral) internal checkWhitelist(msg.sender) {\r\n    if (AccessControlManager.coreMethodsPaused()) {\r\n      revert SwellLib.CoreMethodsPaused();\r\n    }\r\n\r\n    if (msg.value == 0) {\r\n      revert SwellLib.InvalidETHDeposit();\r\n    }\r\n\r\n    uint256 rswETHAmount = wrap(msg.value)\r\n      .mul(wrap(1 ether))\r\n      .div(_rswETHToETHRate())\r\n      .unwrap();\r\n\r\n    _mint(msg.sender, rswETHAmount);\r\n\r\n    totalETHDeposited += msg.value;\r\n\r\n    AddressUpgradeable.sendValue(\r\n      payable(address(AccessControlManager.DepositManager())),\r\n      msg.value\r\n    );\r\n\r\n    emit ETHDepositReceived(\r\n      msg.sender,\r\n      msg.value,\r\n      rswETHAmount,\r\n      totalETHDeposited,\r\n      referral\r\n    );\r\n  }\r\n\r\n  function deposit() external payable override {\r\n    _deposit(address(0));\r\n  }\r\n\r\n  function depositWithReferral(address referral) external payable override {\r\n    if (msg.sender == referral) {\r\n      revert SwellLib.CannotReferSelf();\r\n    }\r\n    _deposit(referral);\r\n  }\r\n\r\n  function depositViaDepositManager(\r\n    uint256 _amount,\r\n    address _to,\r\n    uint256 _minRswETH\r\n  ) external checkZeroAddress(_to) {\r\n    if (AccessControlManager.coreMethodsPaused()) {\r\n      revert SwellLib.CoreMethodsPaused();\r\n    }\r\n    if (msg.sender != address(AccessControlManager.DepositManager())) {\r\n      revert OnlyDepositManager();\r\n    }\r\n\r\n    uint256 rswETHAmount = wrap(_amount)\r\n      .mul(wrap(1 ether))\r\n      .div(_rswETHToETHRate())\r\n      .unwrap();\r\n\r\n    if (rswETHAmount < _minRswETH) {\r\n      revert InsufficientRswETHReceived(rswETHAmount, _minRswETH);\r\n    }\r\n\r\n    _mint(_to, rswETHAmount);\r\n\r\n    emit DepoistManagerDeposit(_to, _amount, rswETHAmount);\r\n  }\r\n\r\n  function reprice(\r\n    uint256 _preRewardETHReserves,\r\n    uint256 _newETHRewards,\r\n    uint256 _rswETHTotalSupply\r\n  ) external override checkRole(SwellLib.REPRICER) {\r\n    uint256 currSupply = totalSupply();\r\n\r\n    if (_rswETHTotalSupply == 0 || currSupply == 0) {\r\n      revert CannotRepriceWithZeroRswETHSupply();\r\n    }\r\n\r\n    if (_preRewardETHReserves == 0) {\r\n      revert InvalidPreRewardETHReserves();\r\n    }\r\n\r\n    uint256 cachedLastRepriceUNIX = lastRepriceUNIX;\r\n\r\n    uint256 timeSinceLastReprice = block.timestamp - cachedLastRepriceUNIX;\r\n    uint256 cachedMinimumRepriceTime = minimumRepriceTime;\r\n\r\n    if (timeSinceLastReprice < cachedMinimumRepriceTime) {\r\n      revert NotEnoughTimeElapsedForReprice(\r\n        cachedMinimumRepriceTime - timeSinceLastReprice\r\n      );\r\n    }\r\n\r\n    uint256 totalReserves = _preRewardETHReserves + _newETHRewards;\r\n\r\n    uint256 cachedNodeOperatorRewardPercentage = nodeOperatorRewardPercentage;\r\n\r\n    uint256 rewardPercentageTotal = swellTreasuryRewardPercentage +\r\n      cachedNodeOperatorRewardPercentage;\r\n\r\n    UD60x18 rewardsInETH = wrap(_newETHRewards).mul(\r\n      wrap(rewardPercentageTotal)\r\n    );\r\n\r\n    UD60x18 rewardsInRswETH = wrap(_rswETHTotalSupply).mul(rewardsInETH).div(\r\n      wrap(totalReserves - rewardsInETH.unwrap())\r\n    );\r\n\r\n    // Also including the amount of new rswETH that was minted alongside the provided rswETH total supply\r\n    uint256 updatedRswETHToETHRateFixed = wrap(totalReserves)\r\n      .div(wrap(_rswETHTotalSupply + rewardsInRswETH.unwrap()))\r\n      .unwrap();\r\n\r\n    // Ensure that the reprice differences are within expected ranges, only if the reprice method has been called before\r\n    if (cachedLastRepriceUNIX != 0) {\r\n      uint256 cachedRswETHToETHRateFixed = rswETHToETHRateFixed;\r\n      // Check repricing rate difference\r\n      uint256 repriceDiff = _absolute(\r\n        updatedRswETHToETHRateFixed,\r\n        cachedRswETHToETHRateFixed\r\n      );\r\n\r\n      uint256 maximumRepriceDiff = wrap(cachedRswETHToETHRateFixed)\r\n        .mul(wrap(maximumRepriceDifferencePercentage))\r\n        .unwrap();\r\n\r\n      if (repriceDiff > maximumRepriceDiff) {\r\n        revert RepriceDifferenceTooLarge(repriceDiff, maximumRepriceDiff);\r\n      }\r\n    }\r\n\r\n    // Check rswETH supply provided with actual current supply\r\n    uint256 rswETHSupplyDiff = _absolute(currSupply, _rswETHTotalSupply);\r\n\r\n    uint256 maximumRswETHDiff = (currSupply *\r\n      maximumRepriceRswETHDifferencePercentage) / 1 ether;\r\n\r\n    if (rswETHSupplyDiff > maximumRswETHDiff) {\r\n      revert RepriceRswETHDifferenceTooLarge(rswETHSupplyDiff, maximumRswETHDiff);\r\n    }\r\n\r\n    uint256 nodeOperatorRewards;\r\n    uint256 swellTreasuryRewards;\r\n    uint256 distributedNodeOperatorRewards;\r\n\r\n    if (rewardsInRswETH.unwrap() != 0) {\r\n      UD60x18 nodeOperatorRewardPortion = wrap(\r\n        cachedNodeOperatorRewardPercentage\r\n      ).div(wrap(rewardPercentageTotal));\r\n\r\n      nodeOperatorRewards = nodeOperatorRewardPortion\r\n        .mul(rewardsInRswETH)\r\n        .unwrap();\r\n\r\n      INodeOperatorRegistry nodeOperatorRegistry = AccessControlManager\r\n        .NodeOperatorRegistry();\r\n\r\n      uint256 totalActiveValidators = nodeOperatorRegistry\r\n        .getPoRAddressListLength();\r\n\r\n      if (totalActiveValidators == 0) {\r\n        nodeOperatorRewards = 0;\r\n      } else if (nodeOperatorRewards != 0) {\r\n        uint128 totalOperators = nodeOperatorRegistry.numOperators();\r\n\r\n        UD60x18 rewardsPerValidator = wrap(nodeOperatorRewards).div(\r\n          wrap(totalActiveValidators)\r\n        );\r\n\r\n        // Operator Id's start at 1\r\n        for (uint128 i = 1; i <= totalOperators; ) {\r\n          (\r\n            address rewardAddress,\r\n            uint256 operatorActiveValidators\r\n          ) = nodeOperatorRegistry.getRewardDetailsForOperatorId(i);\r\n\r\n          if (operatorActiveValidators != 0) {\r\n            uint256 operatorsRewardShare = rewardsPerValidator\r\n              .mul(wrap(operatorActiveValidators))\r\n              .unwrap();\r\n\r\n            _mint(rewardAddress, operatorsRewardShare);\r\n            distributedNodeOperatorRewards += operatorsRewardShare;\r\n          }\r\n\r\n          // Will never overflow as the total operators are capped at uint128\r\n          unchecked {\r\n            ++i;\r\n          }\r\n        }\r\n      }\r\n\r\n      // Transfer the remaining rewards to the treasury\r\n      swellTreasuryRewards = rewardsInRswETH.unwrap() - distributedNodeOperatorRewards;\r\n\r\n      if (swellTreasuryRewards != 0) {\r\n        _mint(AccessControlManager.SwellTreasury(), swellTreasuryRewards);\r\n      }\r\n    }\r\n\r\n    lastRepriceETHReserves = totalReserves;\r\n    lastRepriceUNIX = block.timestamp;\r\n    rswETHToETHRateFixed = updatedRswETHToETHRateFixed;\r\n\r\n    emit Reprice(\r\n      totalReserves,\r\n      updatedRswETHToETHRateFixed,\r\n      distributedNodeOperatorRewards,\r\n      swellTreasuryRewards,\r\n      totalETHDeposited\r\n    );\r\n  }\r\n\r\n  function burn(uint256 amount) external override {\r\n    if (amount == 0) {\r\n      revert CannotBurnZeroRswETH();\r\n    }\r\n\r\n    _burn(msg.sender, amount);\r\n  }\r\n\r\n  // ************************************\r\n  // ***** Internal methods ******\r\n\r\n  /**\r\n   * @dev Returns the ETH -> rswETH rate, if no PoR reading has come through the rate is 1:1\r\n   * @return The rate as a fixed-point type\r\n   */\r\n  function _ethToRswETHRate() internal view returns (UD60x18) {\r\n    return wrap(1 ether).div(_rswETHToETHRate());\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the rswETH -> ETH rate, if no PoR reading has come in the rate is 1:1\r\n   * @return The rate as a fixed-point type\r\n   */\r\n  function _rswETHToETHRate() internal view returns (UD60x18) {\r\n    uint256 cachedRswETHToETHRateFixed = rswETHToETHRateFixed;\r\n\r\n    if (cachedRswETHToETHRateFixed == 0) {\r\n      return wrap(1 ether);\r\n    }\r\n\r\n    return wrap(cachedRswETHToETHRateFixed);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the absolute difference between two uint256 values\r\n   */\r\n  function _absolute(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    if (_a < _b) {\r\n      return _b - _a;\r\n    }\r\n\r\n    return _a - _b;\r\n  }\r\n}\r\n"},"@prb/math/src/UD60x18.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport \"./ud60x18/Casting.sol\";\nimport \"./ud60x18/Constants.sol\";\nimport \"./ud60x18/Conversions.sol\";\nimport \"./ud60x18/Errors.sol\";\nimport \"./ud60x18/Helpers.sol\";\nimport \"./ud60x18/Math.sol\";\nimport \"./ud60x18/ValueType.sol\";\n"},"@prb/math/src/ud60x18/Constants.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport { UD60x18 } from \"./ValueType.sol\";\n\n/// @dev Euler's number as an UD60x18 number.\nUD60x18 constant E = UD60x18.wrap(2_718281828459045235);\n\n/// @dev Half the UNIT number.\nuint256 constant uHALF_UNIT = 0.5e18;\nUD60x18 constant HALF_UNIT = UD60x18.wrap(uHALF_UNIT);\n\n/// @dev log2(10) as an UD60x18 number.\nuint256 constant uLOG2_10 = 3_321928094887362347;\nUD60x18 constant LOG2_10 = UD60x18.wrap(uLOG2_10);\n\n/// @dev log2(e) as an UD60x18 number.\nuint256 constant uLOG2_E = 1_442695040888963407;\nUD60x18 constant LOG2_E = UD60x18.wrap(uLOG2_E);\n\n/// @dev The maximum value an UD60x18 number can have.\nuint256 constant uMAX_UD60x18 = 115792089237316195423570985008687907853269984665640564039457_584007913129639935;\nUD60x18 constant MAX_UD60x18 = UD60x18.wrap(uMAX_UD60x18);\n\n/// @dev The maximum whole value an UD60x18 number can have.\nuint256 constant uMAX_WHOLE_UD60x18 = 115792089237316195423570985008687907853269984665640564039457_000000000000000000;\nUD60x18 constant MAX_WHOLE_UD60x18 = UD60x18.wrap(uMAX_WHOLE_UD60x18);\n\n/// @dev PI as an UD60x18 number.\nUD60x18 constant PI = UD60x18.wrap(3_141592653589793238);\n\n/// @dev The unit amount that implies how many trailing decimals can be represented.\nuint256 constant uUNIT = 1e18;\nUD60x18 constant UNIT = UD60x18.wrap(uUNIT);\n\n/// @dev Zero as an UD60x18 number.\nUD60x18 constant ZERO = UD60x18.wrap(0);\n"},"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"./extensions/IERC20MetadataUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[45] private __gap;\n}\n"},"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"},"contracts/libraries/SwellLib.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.16;\r\n\r\n/**\r\n * @title SwellLib\r\n * @author https://github.com/max-taylor\r\n * @notice This library contains roles, errors, events and functions that are widely used throughout the protocol\r\n */\r\nlibrary SwellLib {\r\n  // ***** Roles *****\r\n  /**\r\n   * @dev The platform admin role\r\n   */\r\n  bytes32 public constant PLATFORM_ADMIN = keccak256(\"PLATFORM_ADMIN\");\r\n\r\n  /**\r\n   * @dev The bot role\r\n   */\r\n  bytes32 public constant BOT = keccak256(\"BOT\");\r\n\r\n  /**\r\n   * @dev The role used for the swETH.reprice method\r\n   */\r\n  bytes32 public constant REPRICER = keccak256(\"REPRICER\");\r\n\r\n  /**\r\n   * @dev Used for checking all the pausing methods\r\n   */\r\n  bytes32 public constant PAUSER = keccak256(\"PAUSER\");\r\n\r\n  /**\r\n   * @dev Used for checking all the unpausing methods\r\n   */\r\n  bytes32 public constant UNPAUSER = keccak256(\"UNPAUSER\");\r\n\r\n  /**\r\n   * @dev Role used specifically in the deleteActiveValidators method\r\n   */\r\n  bytes32 public constant DELETE_ACTIVE_VALIDATORS =\r\n    keccak256(\"DELETE_ACTIVE_VALIDATORS\");\r\n\r\n  /**\r\n   * @dev Role used specifically in the processWithdrawals method\r\n   */\r\n  bytes32 public constant PROCESS_WITHDRAWALS =\r\n    keccak256(\"PROCESS_WITHDRAWALS\");\r\n\r\n  /**\r\n   * @dev Role used specifically in Eigen Layer Delegation\r\n   */\r\n  bytes32 public constant EIGENLAYER_DELEGATOR = keccak256(\"EIGENLAYER_DELEGATOR\");\r\n\r\n  /**\r\n   * @dev Role used specifically in withdrawals from an Eigen Pod\r\n   */\r\n  bytes32 public constant EIGENLAYER_WITHDRAWALS = keccak256(\"EIGENLAYER_WITHDRAWALS\");\r\n\r\n  // ***** Errors *****\r\n  /**\r\n   * @dev Thrown when _checkZeroAddress is called with the zero address\r\n   */\r\n  error CannotBeZeroAddress();\r\n\r\n  /**\r\n   * @dev Thrown in some contracts when the contract call is received by the fallback method\r\n   */\r\n  error InvalidMethodCall();\r\n\r\n  /**\r\n   * @dev Thrown in some contracts when ETH is sent directly to the contract\r\n   */\r\n  error InvalidETHDeposit();\r\n\r\n  /**\r\n   * @dev Thrown when interacting with a method on the protocol that is disabled via the coreMethodsPaused bool\r\n   */\r\n  error CoreMethodsPaused();\r\n\r\n  /**\r\n   * @dev Thrown when interacting with a method on the protocol that is disabled via the botMethodsPaused bool\r\n   */\r\n  error BotMethodsPaused();\r\n\r\n  /**\r\n   * @dev Thrown when interacting with a method on the protocol that is disabled via the operatorMethodsPaused bool\r\n   */\r\n  error OperatorMethodsPaused();\r\n\r\n  /**\r\n   * @dev Thrown when interacting with a method on the protocol that is disabled via the withdrawalsPaused bool\r\n   */\r\n  error WithdrawalsPaused();\r\n\r\n  /**\r\n   * @dev Thrown when calling the withdrawERC20 method and the contracts balance is 0\r\n   */\r\n  error NoTokensToWithdraw();\r\n\r\n  /**\r\n   * @dev Thrown when attempting to deposit with referrer the same all calling address\r\n   */\r\n  error CannotReferSelf();\r\n\r\n  // ************************************\r\n  // ***** Internal Methods *****\r\n  /**\r\n   * @dev This helper is used throughout the protocol to guard against zero addresses being passed as parameters\r\n   * @param _address The address to check if it is the zero address\r\n   */\r\n  function _checkZeroAddress(address _address) internal pure {\r\n    if (_address == address(0)) {\r\n      revert CannotBeZeroAddress();\r\n    }\r\n  }\r\n}\r\n"},"contracts/vendors/contracts/libraries/BeaconChainProofs.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./Merkle.sol\";\r\nimport \"../libraries/Endian.sol\";\r\n\r\n//Utility library for parsing and PHASE0 beacon chain block headers\r\n//SSZ Spec: https://github.com/ethereum/consensus-specs/blob/dev/ssz/simple-serialize.md#merkleization\r\n//BeaconBlockHeader Spec: https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/beacon-chain.md#beaconblockheader\r\n//BeaconState Spec: https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/beacon-chain.md#beaconstate\r\nlibrary BeaconChainProofs {\r\n    // constants are the number of fields and the heights of the different merkle trees used in merkleizing beacon chain containers\r\n    uint256 internal constant BEACON_BLOCK_HEADER_FIELD_TREE_HEIGHT = 3;\r\n\r\n    uint256 internal constant BEACON_BLOCK_BODY_FIELD_TREE_HEIGHT = 4;\r\n\r\n    uint256 internal constant BEACON_STATE_FIELD_TREE_HEIGHT = 5;\r\n\r\n    uint256 internal constant VALIDATOR_FIELD_TREE_HEIGHT = 3;\r\n\r\n    //Note: changed in the deneb hard fork from 4->5\r\n    uint256 internal constant EXECUTION_PAYLOAD_HEADER_FIELD_TREE_HEIGHT_DENEB = 5;\r\n    uint256 internal constant EXECUTION_PAYLOAD_HEADER_FIELD_TREE_HEIGHT_CAPELLA = 4;\r\n\r\n    // SLOTS_PER_HISTORICAL_ROOT = 2**13, so tree height is 13\r\n    uint256 internal constant BLOCK_ROOTS_TREE_HEIGHT = 13;\r\n\r\n    //HISTORICAL_ROOTS_LIMIT = 2**24, so tree height is 24\r\n    uint256 internal constant HISTORICAL_SUMMARIES_TREE_HEIGHT = 24;\r\n\r\n    //Index of block_summary_root in historical_summary container\r\n    uint256 internal constant BLOCK_SUMMARY_ROOT_INDEX = 0;\r\n\r\n    // tree height for hash tree of an individual withdrawal container\r\n    uint256 internal constant WITHDRAWAL_FIELD_TREE_HEIGHT = 2;\r\n\r\n    uint256 internal constant VALIDATOR_TREE_HEIGHT = 40;\r\n\r\n    // MAX_WITHDRAWALS_PER_PAYLOAD = 2**4, making tree height = 4\r\n    uint256 internal constant WITHDRAWALS_TREE_HEIGHT = 4;\r\n\r\n    //in beacon block body https://github.com/ethereum/consensus-specs/blob/dev/specs/capella/beacon-chain.md#beaconblockbody\r\n    uint256 internal constant EXECUTION_PAYLOAD_INDEX = 9;\r\n\r\n    // in beacon block header https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/beacon-chain.md#beaconblockheader\r\n    uint256 internal constant SLOT_INDEX = 0;\r\n    uint256 internal constant STATE_ROOT_INDEX = 3;\r\n    uint256 internal constant BODY_ROOT_INDEX = 4;\r\n    // in beacon state https://github.com/ethereum/consensus-specs/blob/dev/specs/capella/beacon-chain.md#beaconstate\r\n    uint256 internal constant VALIDATOR_TREE_ROOT_INDEX = 11;\r\n    uint256 internal constant HISTORICAL_SUMMARIES_INDEX = 27;\r\n\r\n    // in validator https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/beacon-chain.md#validator\r\n    uint256 internal constant VALIDATOR_PUBKEY_INDEX = 0;\r\n    uint256 internal constant VALIDATOR_WITHDRAWAL_CREDENTIALS_INDEX = 1;\r\n    uint256 internal constant VALIDATOR_BALANCE_INDEX = 2;\r\n    uint256 internal constant VALIDATOR_WITHDRAWABLE_EPOCH_INDEX = 7;\r\n\r\n    // in execution payload header\r\n    uint256 internal constant TIMESTAMP_INDEX = 9;\r\n\r\n    //in execution payload\r\n    uint256 internal constant WITHDRAWALS_INDEX = 14;\r\n\r\n    // in withdrawal\r\n    uint256 internal constant WITHDRAWAL_VALIDATOR_INDEX_INDEX = 1;\r\n    uint256 internal constant WITHDRAWAL_VALIDATOR_AMOUNT_INDEX = 3;\r\n\r\n    //Misc Constants\r\n\r\n    /// @notice The number of slots each epoch in the beacon chain\r\n    uint64 internal constant SLOTS_PER_EPOCH = 32;\r\n\r\n    /// @notice The number of seconds in a slot in the beacon chain\r\n    uint64 internal constant SECONDS_PER_SLOT = 12;\r\n\r\n    /// @notice Number of seconds per epoch: 384 == 32 slots/epoch * 12 seconds/slot \r\n    uint64 internal constant SECONDS_PER_EPOCH = SLOTS_PER_EPOCH * SECONDS_PER_SLOT;\r\n\r\n    bytes8 internal constant UINT64_MASK = 0xffffffffffffffff;\r\n\r\n    /// @notice This struct contains the merkle proofs and leaves needed to verify a partial/full withdrawal\r\n    struct WithdrawalProof {\r\n        bytes withdrawalProof;\r\n        bytes slotProof;\r\n        bytes executionPayloadProof;\r\n        bytes timestampProof;\r\n        bytes historicalSummaryBlockRootProof;\r\n        uint64 blockRootIndex;\r\n        uint64 historicalSummaryIndex;\r\n        uint64 withdrawalIndex;\r\n        bytes32 blockRoot;\r\n        bytes32 slotRoot;\r\n        bytes32 timestampRoot;\r\n        bytes32 executionPayloadRoot;\r\n    }\r\n\r\n    /// @notice This struct contains the root and proof for verifying the state root against the oracle block root\r\n    struct StateRootProof {\r\n        bytes32 beaconStateRoot;\r\n        bytes proof;\r\n    }\r\n\r\n    /**\r\n     * @notice This function verifies merkle proofs of the fields of a certain validator against a beacon chain state root\r\n     * @param validatorIndex the index of the proven validator\r\n     * @param beaconStateRoot is the beacon chain state root to be proven against.\r\n     * @param validatorFieldsProof is the data used in proving the validator's fields\r\n     * @param validatorFields the claimed fields of the validator\r\n     */\r\n    function verifyValidatorFields(\r\n        bytes32 beaconStateRoot,\r\n        bytes32[] calldata validatorFields,\r\n        bytes calldata validatorFieldsProof,\r\n        uint40 validatorIndex\r\n    ) internal view {\r\n        require(\r\n            validatorFields.length == 2 ** VALIDATOR_FIELD_TREE_HEIGHT,\r\n            \"BeaconChainProofs.verifyValidatorFields: Validator fields has incorrect length\"\r\n        );\r\n\r\n        /**\r\n         * Note: the length of the validator merkle proof is BeaconChainProofs.VALIDATOR_TREE_HEIGHT + 1.\r\n         * There is an additional layer added by hashing the root with the length of the validator list\r\n         */\r\n        require(\r\n            validatorFieldsProof.length == 32 * ((VALIDATOR_TREE_HEIGHT + 1) + BEACON_STATE_FIELD_TREE_HEIGHT),\r\n            \"BeaconChainProofs.verifyValidatorFields: Proof has incorrect length\"\r\n        );\r\n        uint256 index = (VALIDATOR_TREE_ROOT_INDEX << (VALIDATOR_TREE_HEIGHT + 1)) | uint256(validatorIndex);\r\n        // merkleize the validatorFields to get the leaf to prove\r\n        bytes32 validatorRoot = Merkle.merkleizeSha256(validatorFields);\r\n\r\n        // verify the proof of the validatorRoot against the beaconStateRoot\r\n        require(\r\n            Merkle.verifyInclusionSha256({\r\n                proof: validatorFieldsProof,\r\n                root: beaconStateRoot,\r\n                leaf: validatorRoot,\r\n                index: index\r\n            }),\r\n            \"BeaconChainProofs.verifyValidatorFields: Invalid merkle proof\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice This function verifies the latestBlockHeader against the state root. the latestBlockHeader is\r\n     * a tracked in the beacon state.\r\n     * @param beaconStateRoot is the beacon chain state root to be proven against.\r\n     * @param stateRootProof is the provided merkle proof\r\n     * @param latestBlockRoot is hashtree root of the latest block header in the beacon state\r\n     */\r\n    function verifyStateRootAgainstLatestBlockRoot(\r\n        bytes32 latestBlockRoot,\r\n        bytes32 beaconStateRoot,\r\n        bytes calldata stateRootProof\r\n    ) internal view {\r\n        require(\r\n            stateRootProof.length == 32 * (BEACON_BLOCK_HEADER_FIELD_TREE_HEIGHT),\r\n            \"BeaconChainProofs.verifyStateRootAgainstLatestBlockRoot: Proof has incorrect length\"\r\n        );\r\n        //Next we verify the slot against the blockRoot\r\n        require(\r\n            Merkle.verifyInclusionSha256({\r\n                proof: stateRootProof,\r\n                root: latestBlockRoot,\r\n                leaf: beaconStateRoot,\r\n                index: STATE_ROOT_INDEX\r\n            }),\r\n            \"BeaconChainProofs.verifyStateRootAgainstLatestBlockRoot: Invalid latest block header root merkle proof\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice This function verifies the slot and the withdrawal fields for a given withdrawal\r\n     * @param withdrawalProof is the provided set of merkle proofs\r\n     * @param withdrawalFields is the serialized withdrawal container to be proven\r\n     */\r\n    function verifyWithdrawal(\r\n        bytes32 beaconStateRoot,\r\n        bytes32[] calldata withdrawalFields,\r\n        WithdrawalProof calldata withdrawalProof,\r\n        uint64 denebForkTimestamp\r\n    ) internal view {\r\n        require(\r\n            withdrawalFields.length == 2 ** WITHDRAWAL_FIELD_TREE_HEIGHT,\r\n            \"BeaconChainProofs.verifyWithdrawal: withdrawalFields has incorrect length\"\r\n        );\r\n\r\n        require(\r\n            withdrawalProof.blockRootIndex < 2 ** BLOCK_ROOTS_TREE_HEIGHT,\r\n            \"BeaconChainProofs.verifyWithdrawal: blockRootIndex is too large\"\r\n        );\r\n        require(\r\n            withdrawalProof.withdrawalIndex < 2 ** WITHDRAWALS_TREE_HEIGHT,\r\n            \"BeaconChainProofs.verifyWithdrawal: withdrawalIndex is too large\"\r\n        );\r\n\r\n        require(\r\n            withdrawalProof.historicalSummaryIndex < 2 ** HISTORICAL_SUMMARIES_TREE_HEIGHT,\r\n            \"BeaconChainProofs.verifyWithdrawal: historicalSummaryIndex is too large\"\r\n        );\r\n\r\n        //Note: post deneb hard fork, the number of exection payload header fields increased from 15->17, adding an extra level to the tree height\r\n        uint256 executionPayloadHeaderFieldTreeHeight = (getWithdrawalTimestamp(withdrawalProof) < denebForkTimestamp) ? EXECUTION_PAYLOAD_HEADER_FIELD_TREE_HEIGHT_CAPELLA : EXECUTION_PAYLOAD_HEADER_FIELD_TREE_HEIGHT_DENEB;\r\n        require(\r\n            withdrawalProof.withdrawalProof.length ==\r\n                32 * (executionPayloadHeaderFieldTreeHeight + WITHDRAWALS_TREE_HEIGHT + 1),\r\n            \"BeaconChainProofs.verifyWithdrawal: withdrawalProof has incorrect length\"\r\n        );\r\n        require(\r\n            withdrawalProof.executionPayloadProof.length ==\r\n                32 * (BEACON_BLOCK_HEADER_FIELD_TREE_HEIGHT + BEACON_BLOCK_BODY_FIELD_TREE_HEIGHT),\r\n            \"BeaconChainProofs.verifyWithdrawal: executionPayloadProof has incorrect length\"\r\n        );\r\n        require(\r\n            withdrawalProof.slotProof.length == 32 * (BEACON_BLOCK_HEADER_FIELD_TREE_HEIGHT),\r\n            \"BeaconChainProofs.verifyWithdrawal: slotProof has incorrect length\"\r\n        );\r\n        require(\r\n            withdrawalProof.timestampProof.length == 32 * (executionPayloadHeaderFieldTreeHeight),\r\n            \"BeaconChainProofs.verifyWithdrawal: timestampProof has incorrect length\"\r\n        );\r\n\r\n        require(\r\n            withdrawalProof.historicalSummaryBlockRootProof.length ==\r\n                32 *\r\n                    (BEACON_STATE_FIELD_TREE_HEIGHT +\r\n                        (HISTORICAL_SUMMARIES_TREE_HEIGHT + 1) +\r\n                        1 +\r\n                        (BLOCK_ROOTS_TREE_HEIGHT)),\r\n            \"BeaconChainProofs.verifyWithdrawal: historicalSummaryBlockRootProof has incorrect length\"\r\n        );\r\n        /**\r\n         * Note: Here, the \"1\" in \"1 + (BLOCK_ROOTS_TREE_HEIGHT)\" signifies that extra step of choosing the \"block_root_summary\" within the individual\r\n         * \"historical_summary\". Everywhere else it signifies merkelize_with_mixin, where the length of an array is hashed with the root of the array,\r\n         * but not here.\r\n         */\r\n        uint256 historicalBlockHeaderIndex = (HISTORICAL_SUMMARIES_INDEX <<\r\n            ((HISTORICAL_SUMMARIES_TREE_HEIGHT + 1) + 1 + (BLOCK_ROOTS_TREE_HEIGHT))) |\r\n            (uint256(withdrawalProof.historicalSummaryIndex) << (1 + (BLOCK_ROOTS_TREE_HEIGHT))) |\r\n            (BLOCK_SUMMARY_ROOT_INDEX << (BLOCK_ROOTS_TREE_HEIGHT)) |\r\n            uint256(withdrawalProof.blockRootIndex);\r\n\r\n        require(\r\n            Merkle.verifyInclusionSha256({\r\n                proof: withdrawalProof.historicalSummaryBlockRootProof,\r\n                root: beaconStateRoot,\r\n                leaf: withdrawalProof.blockRoot,\r\n                index: historicalBlockHeaderIndex\r\n            }),\r\n            \"BeaconChainProofs.verifyWithdrawal: Invalid historicalsummary merkle proof\"\r\n        );\r\n\r\n        //Next we verify the slot against the blockRoot\r\n        require(\r\n            Merkle.verifyInclusionSha256({\r\n                proof: withdrawalProof.slotProof,\r\n                root: withdrawalProof.blockRoot,\r\n                leaf: withdrawalProof.slotRoot,\r\n                index: SLOT_INDEX\r\n            }),\r\n            \"BeaconChainProofs.verifyWithdrawal: Invalid slot merkle proof\"\r\n        );\r\n\r\n        {\r\n            // Next we verify the executionPayloadRoot against the blockRoot\r\n            uint256 executionPayloadIndex = (BODY_ROOT_INDEX << (BEACON_BLOCK_BODY_FIELD_TREE_HEIGHT)) |\r\n                EXECUTION_PAYLOAD_INDEX;\r\n            require(\r\n                Merkle.verifyInclusionSha256({\r\n                    proof: withdrawalProof.executionPayloadProof,\r\n                    root: withdrawalProof.blockRoot,\r\n                    leaf: withdrawalProof.executionPayloadRoot,\r\n                    index: executionPayloadIndex\r\n                }),\r\n                \"BeaconChainProofs.verifyWithdrawal: Invalid executionPayload merkle proof\"\r\n            );\r\n        }\r\n\r\n        // Next we verify the timestampRoot against the executionPayload root\r\n        require(\r\n            Merkle.verifyInclusionSha256({\r\n                proof: withdrawalProof.timestampProof,\r\n                root: withdrawalProof.executionPayloadRoot,\r\n                leaf: withdrawalProof.timestampRoot,\r\n                index: TIMESTAMP_INDEX\r\n            }),\r\n            \"BeaconChainProofs.verifyWithdrawal: Invalid timestamp merkle proof\"\r\n        );\r\n\r\n        {\r\n            /**\r\n             * Next we verify the withdrawal fields against the executionPayloadRoot:\r\n             * First we compute the withdrawal_index, then we merkleize the \r\n             * withdrawalFields container to calculate the withdrawalRoot.\r\n             *\r\n             * Note: Merkleization of the withdrawals root tree uses MerkleizeWithMixin, i.e., the length of the array is hashed with the root of\r\n             * the array.  Thus we shift the WITHDRAWALS_INDEX over by WITHDRAWALS_TREE_HEIGHT + 1 and not just WITHDRAWALS_TREE_HEIGHT.\r\n             */\r\n            uint256 withdrawalIndex = (WITHDRAWALS_INDEX << (WITHDRAWALS_TREE_HEIGHT + 1)) |\r\n                uint256(withdrawalProof.withdrawalIndex);\r\n            bytes32 withdrawalRoot = Merkle.merkleizeSha256(withdrawalFields);\r\n            require(\r\n                Merkle.verifyInclusionSha256({\r\n                    proof: withdrawalProof.withdrawalProof,\r\n                    root: withdrawalProof.executionPayloadRoot,\r\n                    leaf: withdrawalRoot,\r\n                    index: withdrawalIndex\r\n                }),\r\n                \"BeaconChainProofs.verifyWithdrawal: Invalid withdrawal merkle proof\"\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice This function replicates the ssz hashing of a validator's pubkey, outlined below:\r\n     *  hh := ssz.NewHasher()\r\n     *  hh.PutBytes(validatorPubkey[:])\r\n     *  validatorPubkeyHash := hh.Hash()\r\n     *  hh.Reset()\r\n     */\r\n    function hashValidatorBLSPubkey(bytes memory validatorPubkey) internal pure returns (bytes32 pubkeyHash) {\r\n        require(validatorPubkey.length == 48, \"Input should be 48 bytes in length\");\r\n        return sha256(abi.encodePacked(validatorPubkey, bytes16(0)));\r\n    }\r\n\r\n    /**\r\n     * @dev Retrieve the withdrawal timestamp\r\n     */\r\n    function getWithdrawalTimestamp(WithdrawalProof memory withdrawalProof) internal pure returns (uint64) {\r\n        return\r\n            Endian.fromLittleEndianUint64(withdrawalProof.timestampRoot);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts the withdrawal's slot to an epoch\r\n     */\r\n    function getWithdrawalEpoch(WithdrawalProof memory withdrawalProof) internal pure returns (uint64) {\r\n        return\r\n            Endian.fromLittleEndianUint64(withdrawalProof.slotRoot) / SLOTS_PER_EPOCH;\r\n    }\r\n\r\n    /**\r\n     * Indices for validator fields (refer to consensus specs):\r\n     * 0: pubkey\r\n     * 1: withdrawal credentials\r\n     * 2: effective balance\r\n     * 3: slashed?\r\n     * 4: activation elligibility epoch\r\n     * 5: activation epoch\r\n     * 6: exit epoch\r\n     * 7: withdrawable epoch\r\n     */\r\n\r\n    /**\r\n     * @dev Retrieves a validator's pubkey hash\r\n     */\r\n    function getPubkeyHash(bytes32[] memory validatorFields) internal pure returns (bytes32) {\r\n        return \r\n            validatorFields[VALIDATOR_PUBKEY_INDEX];\r\n    }\r\n\r\n    function getWithdrawalCredentials(bytes32[] memory validatorFields) internal pure returns (bytes32) {\r\n        return\r\n            validatorFields[VALIDATOR_WITHDRAWAL_CREDENTIALS_INDEX];\r\n    }\r\n\r\n    /**\r\n     * @dev Retrieves a validator's effective balance (in gwei)\r\n     */\r\n    function getEffectiveBalanceGwei(bytes32[] memory validatorFields) internal pure returns (uint64) {\r\n        return \r\n            Endian.fromLittleEndianUint64(validatorFields[VALIDATOR_BALANCE_INDEX]);\r\n    }\r\n\r\n    /**\r\n     * @dev Retrieves a validator's withdrawable epoch\r\n     */\r\n    function getWithdrawableEpoch(bytes32[] memory validatorFields) internal pure returns (uint64) {\r\n        return \r\n            Endian.fromLittleEndianUint64(validatorFields[VALIDATOR_WITHDRAWABLE_EPOCH_INDEX]);\r\n    }\r\n\r\n    /**\r\n     * Indices for withdrawal fields (refer to consensus specs):\r\n     * 0: withdrawal index\r\n     * 1: validator index\r\n     * 2: execution address\r\n     * 3: withdrawal amount\r\n     */\r\n\r\n    /**\r\n     * @dev Retrieves a withdrawal's validator index\r\n     */\r\n    function getValidatorIndex(bytes32[] memory withdrawalFields) internal pure returns (uint40) {\r\n        return \r\n            uint40(Endian.fromLittleEndianUint64(withdrawalFields[WITHDRAWAL_VALIDATOR_INDEX_INDEX]));\r\n    }\r\n\r\n    /**\r\n     * @dev Retrieves a withdrawal's withdrawal amount (in gwei)\r\n     */\r\n    function getWithdrawalAmountGwei(bytes32[] memory withdrawalFields) internal pure returns (uint64) {\r\n        return\r\n            Endian.fromLittleEndianUint64(withdrawalFields[WITHDRAWAL_VALIDATOR_AMOUNT_INDEX]);\r\n    }\r\n}\r\n"},"contracts/interfaces/IEigenLayerManager.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.16;\r\n\r\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport {IDelegationManager} from \"../vendors/contracts/interfaces/IDelegationManager.sol\";\r\nimport {IEigenPodManager} from \"../vendors/contracts/interfaces/IEigenPodManager.sol\";\r\nimport {BeaconChainProofs} from \"../vendors/contracts/libraries/BeaconChainProofs.sol\";\r\nimport {IDelayedWithdrawalRouter} from \"../vendors/contracts/interfaces/IDelayedWithdrawalRouter.sol\";\r\nimport {IStrategy} from \"../vendors/contracts/interfaces/IStrategy.sol\";\r\n\r\n/**\r\n * @title IEigenLayerManager\r\n * @notice The interface for the EigenLayerManager contract\r\n */\r\ninterface IEigenLayerManager {\r\n  // ***** Errors ******\r\n  /**\r\n   * @dev Error thrown when an admin passes an invalid staker Id\r\n   */\r\n  error InvalidStakerId();\r\n\r\n  /**\r\n   * @dev Error thrown when batch creating a staker and its pod with a batch size of zero.\r\n   */\r\n  error BatchSizeCannotBeZero();\r\n\r\n  /**\r\n   * @dev Error thrown when array lengths dont match.\r\n   */\r\n  error ArrayLengthMismatch();\r\n\r\n  /**\r\n   * @dev Error thrown when trying to send to the zero address.\r\n   */\r\n  error CannotSendToZeroAddress();\r\n\r\n  /**\r\n   * @dev Error thrown when stakerProxy implementation address already set.\r\n   */\r\n  error AddressAlreadySet();\r\n\r\n  /**\r\n   * @dev Error thrown when trying to deposit zero amount into a strategy\r\n   */\r\n  error CannotDepositZero();\r\n\r\n  /**\r\n   * @dev Error thrown when a token address does not match a Strategy's underlying token.\r\n   */\r\n  error StrategyTokenMismatch();\r\n\r\n  /**\r\n   * @dev Error thrown when a strategy is not set for a token.\r\n   */\r\n  error StrategyNotSet();\r\n\r\n  /**\r\n   * @dev Error thrown when a staker is still delegated to an operator during manual unassignment.\r\n   */\r\n  error StakerIsStillDelegatedToOperator();\r\n\r\n  /**\r\n   * @dev Error thrown when a staker was not found in an operator's staker list during manual unassignment.\r\n   */\r\n  error StakerNotFoundInOperatorStakerList();\r\n\r\n  /**\r\n   * @dev Error thrown when a staker is already assigned to an operator during manual assignment.\r\n   */\r\n  error StakerIsAlreadyAssignedToOperator();\r\n\r\n  /**\r\n   * @dev Error thrown when a staker is not delegated to an operator during manual assignment.\r\n   */\r\n  error StakerIsNotDelegatedToOperator();\r\n\r\n  // ***** Events ******\r\n\r\n  /**\r\n   * @dev Event fired when an admin succesfully updates the signer address used for delegation\r\n   * @param oldSigner The address of the old admin signer\r\n   * @param newSigner The address of the new admin signer\r\n   */\r\n  event AdminSignerUpdated(address oldSigner, address newSigner);\r\n\r\n  /**\r\n   * @dev Event fired when a stakerProxy is successfully created\r\n   * @param stakerProxyAddress The address of the created stakerProxy contract\r\n   */\r\n  event StakerCreated(address stakerProxyAddress);\r\n\r\n  /**\r\n   * @dev Event fired when the DelayedWithdrawalRouter is set.\r\n   * @param delayedWithdrawalRouter The address of the DelayedWithdrawalRouter contract\r\n   */\r\n  event DelayedWithdrawalRouterSet(address delayedWithdrawalRouter);\r\n\r\n  /**\r\n   * @dev Event fired when the StrategyManager contract is set.\r\n   * @param strategyManager The address of the StrategyManager contract\r\n   */\r\n  event StrategyManagerAddressSet(address strategyManager);\r\n\r\n  /**\r\n   * @dev Event fired when the DelegationManager contract is set.\r\n   * @param _delegationManager The address of the DelegationManager contract\r\n   */\r\n  event DelegationManagerSet(address _delegationManager);\r\n\r\n  /**\r\n   * Emitted when new validators are setup on EigenLayer\r\n   * @param stakerIds The IDs of the stakerProxy contracts used for validator setup\r\n   * @param pubKeys The pubKeys that have been used for validator setup\r\n   */\r\n  event ValidatorsSetupOnEigenLayer(uint256[] stakerIds, bytes[] pubKeys);\r\n\r\n  /**\r\n   * @dev Event fired when the admin succesfully deposits LST's into an Eigen Layer Strategy\r\n   * @param amount The amount of the LST deiposited into the Eigen Layer strategy\r\n   * @param token The address of the LST deposited\r\n   * @param currentStrategy The interface of the Eigen Layer strategy the LST was deposited into\r\n   */\r\n  event DepositedIntoStrategy(\r\n    uint256 amount,\r\n    address token,\r\n    IStrategy currentStrategy\r\n  );\r\n\r\n  /**\r\n   * Emitted when a stakerProxy contract is successfully registered\r\n   * @param beacon The address of the beacon contract\r\n   */\r\n  event StakerProxyRegistered(address beacon);\r\n\r\n  /**\r\n   * Emitted when a stakerProxy contract is successfully upgraded to a new implementation\r\n   * @param newImplementation The address of the new implementation contract\r\n   */\r\n  event StakerProxyUpgraded(address newImplementation);\r\n\r\n  /**\r\n   * @dev Event is fired when some contracts receive ETH\r\n   * @param from The account that sent the ETH\r\n   * @param amount The amount of ETH received\r\n   */\r\n  event ETHReceived(address indexed from, uint256 amount);\r\n\r\n  /**\r\n   * @dev Event fired when the admin succesfully sets the Eigen Layer strategy for a LST\r\n   * @param token The address of the LST for which corresponds to the Eigen Layer strategy\r\n   * @param strategy The address Eigen Layer strategy contract for the above LST\r\n   */\r\n  event StrategySetAndApproved(address indexed token, address indexed strategy);\r\n\r\n  /**\r\n   * @dev Event fired when a staker is manually unassigned from an operator.\r\n   * @param stakerId The ID of the stakerProxy contract\r\n   * @param operator The address of the operator\r\n   */\r\n  event StakerUnassignedFromOperator(uint256 stakerId, address operator);\r\n\r\n  /**\r\n   * @dev Event fired when a staker is manually assigned to an operator.\r\n   * @param stakerId The ID of the stakerProxy contract\r\n   * @param operator The address of the operator\r\n   */\r\n  event StakerAssignedToOperator(uint256 stakerId, address operator);\r\n\r\n  // ************************************\r\n  // ***** External methods ******\r\n\r\n  /**\r\n   * @dev Returns the address of the EigenLayer DelegationManager contract.\r\n   * @return The address of the DelegationManager contract.\r\n   */\r\n  function DelegationManager() external view returns (IDelegationManager);\r\n\r\n  /**\r\n   * @dev Returns the address of the DelayedWithdrawalRouter contract.\r\n   * @return The address of the DelayedWithdrawalRouter contract.\r\n   */\r\n  function DelayedWithdrawalRouter()\r\n    external\r\n    view\r\n    returns (IDelayedWithdrawalRouter);\r\n\r\n  /**\r\n   * @dev Returns the address of the EigenPodManager contract.\r\n   * @return The address of the EigenPodManager contract.\r\n   */\r\n  function EigenPodManager() external view returns (IEigenPodManager);\r\n\r\n  /**\r\n   * @dev Returns the address of the StrategyManager contract.\r\n   * @return The address of the StrategyManager contract.\r\n   */\r\n  function strategyManagerAddress() external view returns (address);\r\n\r\n  /**\r\n   * @dev Returns the address of the admin signer.\r\n   * @return The address of the admin signer.\r\n   */\r\n  function adminSigner() external view returns (address);\r\n\r\n  /**\r\n   * @dev Returns the latest stakeId assigned to a stakerProxy contract.\r\n   * @return The latest stakeId.\r\n   */\r\n  function stakeId() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev A mapping of token addresses to their corresponding EigenLayer strategy.\r\n   * @param _token The address of the token.\r\n   * @return The address of the strategy.\r\n   */\r\n  function tokenToStrategy(address _token) external view returns (address);\r\n\r\n  /**\r\n   * @dev A mapping of operator addresses to associated stakerProxy Ids.\r\n   * @param _operator The address of the operator.\r\n   * @return An array of stakerProxy Ids.\r\n   */\r\n  function getDelegatedStakers(\r\n    address _operator\r\n  ) external view returns (uint256[] memory);\r\n\r\n  /**\r\n   * @dev Returns the stakerProxy address for a given staker ID.\r\n   * @notice Reverts if the staker ID is invalid.\r\n   * @param _stakerId The ID of the staker.\r\n   * @return stakerProxy The address of the stakerProxy contract.\r\n   */\r\n  function isValidStaker(\r\n    uint256 _stakerId\r\n  ) external view returns (address stakerProxy);\r\n\r\n  /**\r\n   * @dev Returns the stakerProxy address for a given staker ID.\r\n   * @param _stakerId The ID of the staker.\r\n   * @return stakerProxy The address of the stakerProxy contract.\r\n   */\r\n  function stakerProxyAddresses(\r\n    uint256 _stakerId\r\n  ) external view returns (address stakerProxy);\r\n\r\n  /**\r\n   * @dev Sets the StrategyManager contract address.\r\n   * @param _strategyManager The address of the StrategyManager contract.\r\n   */\r\n  function setStrategyManager(address _strategyManager) external;\r\n\r\n  /**\r\n   * @dev Sets the admin signer address.\r\n   * @param _adminSigner The address of the admin signer.\r\n   */\r\n  function setAdminSigner(address _adminSigner) external;\r\n\r\n  /**\r\n   * @dev Sets the DelayedWithdrawalRouter contract address.\r\n   * @param _delayedWithdrawalRouter The address of the DelayedWithdrawalRouter contract.\r\n   */\r\n  function setDelayedWithdrawalRouter(\r\n    address _delayedWithdrawalRouter\r\n  ) external;\r\n\r\n  /**\r\n   * @dev Sets the DelegationManager contract address.\r\n   * @param _delegationManager The address of the DelegationManager contract.\r\n   */\r\n  function setDelegationManager(address _delegationManager) external;\r\n\r\n  /**\r\n   * @dev Allows a Swell Admin to set the Eigen Layer Strategy for a given token.\r\n   * @param _token The address of the token.\r\n   * @param _strategy The address of the strategy.\r\n   */\r\n  function setEigenLayerStrategy(address _token, address _strategy) external;\r\n\r\n  /**\r\n   * @dev Stake on the EigenLayer network.\r\n   * @param _stakerIds An array of stakerProxy Ids.\r\n   * @param _pubKeys An array of public keys for operators registered on the Swell Network.\r\n   * @param _depositDataRoot The deposit data root.\r\n   */\r\n  function stakeOnEigenLayer(\r\n    uint256[] calldata _stakerIds,\r\n    bytes[] calldata _pubKeys,\r\n    bytes32 _depositDataRoot\r\n  ) external;\r\n\r\n  /**\r\n   * @dev Allows a Swell Admin to Deposit liquid staking tokens into an Eigen Layer Strategy.\r\n   * @param _stakerId The Id if the stakerProxy contract to deposit on behalf of.\r\n   * @param _amount The amount of LST's to deposit.\r\n   * @param _token The LST token address.\r\n   */\r\n  function depositIntoEigenLayerStrategy(\r\n    uint256 _stakerId,\r\n    uint256 _amount,\r\n    address _token\r\n  ) external;\r\n\r\n  /**\r\n   * @dev Delegates the staker's Eigen Layer shares to the specified operator using the provided signatures and expiry times.\r\n   * @param _stakerId The Id of the stakerProxy contract.\r\n   * @param _operator The address of the operator.\r\n   * @param _stakerSignatureAndExpiry A struct containing the staker's signature and expiry time.\r\n   * @param _approverSignatureAndExpiry A struct containing the approver's signature and expiry time.\r\n   * @param _approverSalt A unique salt value used for the approver's signature.\r\n   */\r\n  function delegateToWithSignature(\r\n    uint256 _stakerId,\r\n    address _operator,\r\n    IDelegationManager.SignatureWithExpiry calldata _stakerSignatureAndExpiry,\r\n    IDelegationManager.SignatureWithExpiry calldata _approverSignatureAndExpiry,\r\n    bytes32 _approverSalt\r\n  ) external;\r\n\r\n  /**\r\n   * @dev Batch delegates multiple stakers to multiple operators using their signatures and expiry times.\r\n   * @param stakerIds An array of stakerProxy Ids.\r\n   * @param operatorArray An array of operator addresses.\r\n   * @param stakerSignatureAndExpiryArray An array of SignatureWithExpiry structs containing staker signatures and expiry times.\r\n   * @param approverSignatureAndExpiryArray An array of SignatureWithExpiry structs containing approver signatures and expiry times.\r\n   * @param approverSaltArray An array of salts used for the approver signatures.\r\n   */\r\n  function batchDelegateToWithSignature(\r\n    uint256[] calldata stakerIds,\r\n    address[] calldata operatorArray,\r\n    IDelegationManager.SignatureWithExpiry[]\r\n      calldata stakerSignatureAndExpiryArray,\r\n    IDelegationManager.SignatureWithExpiry[]\r\n      calldata approverSignatureAndExpiryArray,\r\n    bytes32[] calldata approverSaltArray\r\n  ) external;\r\n\r\n  /**\r\n   * @dev Manually unassigns a staker from an operator.\r\n   * @dev This is a cleanup function which requires that the staker is undelegated on EigenLayer. This can occur when the operator or their delegation approver forces one of their delegated stakers to undelegate.\r\n   * @param _stakerId The ID of the staker to unassign.\r\n   * @param _operator The address of the operator.\r\n   */\r\n  function unassignStakerFromOperator(\r\n    uint256 _stakerId,\r\n    address _operator\r\n  ) external;\r\n\r\n  /**\r\n   * @dev Manually assigns a staker to an operator.\r\n   * @dev This is a cleanup function which requires that the staker is delegated on EigenLayer. This can occur when a staker is delegated to an operator directly via DelegationManager.\r\n   * @param stakerId The ID of the staker to assign.\r\n   * @param operator The address of the operator.\r\n   */\r\n  function assignStakerToOperator(uint256 stakerId, address operator) external;\r\n\r\n  /**\r\n   * @dev Queues multiple withdrawals for a staker proxy.\r\n   * @param _stakerProxyId The ID of the staker proxy.\r\n   * @param _queuedWithdrawalParams An array of QueuedWithdrawalParams struct containing withdrawal details.\r\n   * @return An array of bytes32 representing the withdrawal roots.\r\n   */\r\n  function queueWithdrawals(\r\n    uint256 _stakerProxyId,\r\n    IDelegationManager.QueuedWithdrawalParams[] calldata _queuedWithdrawalParams\r\n  ) external returns (bytes32[] memory);\r\n\r\n  /**\r\n   * @dev Complete a queued withdrawal via a StakerProxy\r\n   * @param _stakerProxyId The ID of the staker proxy.\r\n   * @param _withdrawal The Withdrawal to complete.\r\n   * @param _tokens Array in which the i-th entry specifies the `token` input to the 'withdraw' function of the i-th Strategy in the `withdrawal.strategies` array.\r\n   * This input can be provided with zero length if `receiveAsTokens` is set to 'false' (since in that case, this input will be unused)\r\n   * @param _middlewareTimesIndex is the index in the operator that the staker who triggered the withdrawal was delegated to's middleware times array\r\n   * @param _receiveAsTokens If true, the shares specified in the withdrawal will be withdrawn from the specified strategies themselves\r\n   * and sent to the caller, through calls to `withdrawal.strategies[i].withdraw`. If false, then the shares in the specified strategies\r\n   * will simply be transferred to the caller directly.\r\n   * @dev middlewareTimesIndex should be calculated off chain before calling this function by finding the first index that satisfies `slasher.canWithdraw`\r\n   * @dev beaconChainETHStrategy shares are non-transferrable, so if `receiveAsTokens = false` and `withdrawal.withdrawer != withdrawal.staker`, note that\r\n   * any beaconChainETHStrategy shares in the `withdrawal` will be _returned to the staker_, rather than transferred to the withdrawer, unlike shares in\r\n   * any other strategies, which will be transferred to the withdrawer.\r\n   */\r\n  function completeQueuedWithdrawal(\r\n    uint256 _stakerProxyId,\r\n    IDelegationManager.Withdrawal calldata _withdrawal,\r\n    IERC20[] calldata _tokens,\r\n    uint256 _middlewareTimesIndex,\r\n    bool _receiveAsTokens\r\n  ) external;\r\n\r\n  /**\r\n   * @dev This function is used to claim partial withdrawals on behalf of the recipient after the withdrawal delay has passed.\r\n   * @param _recipient The address of the recipient to claim the withdrawals for.\r\n   * @param _maxNumberOfWithdrawalsToClaim The maximum number of withdrawals to claim.\r\n   */\r\n  function claimDelayedWithdrawals(\r\n    address _recipient,\r\n    uint256 _maxNumberOfWithdrawalsToClaim\r\n  ) external;\r\n\r\n  /**\r\n   * @dev  For a staker proxy: Verify the withdrawal credentials of validator(s) owned by the pod owner are pointing to the eigenpod.\r\n   * @param _stakerProxyId is the ID of the staker proxy contract\r\n   * @param _oracleTimestamp is the Beacon Chain timestamp whose state root the `proof` will be proven against.\r\n   * @param _stateRootProof proves a `beaconStateRoot` against a block root fetched from the oracle\r\n   * @param _validatorIndices is the list of indices of the validators being proven, refer to consensus specs\r\n   * @param _validatorFieldsProofs proofs against the `beaconStateRoot` for each validator in `validatorFields`\r\n   * @param _validatorFields are the fields of the \"Validator Container\", refer to consensus specs\r\n   * for details: https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/beacon-chain.md#validator\r\n   */\r\n  function verifyPodWithdrawalCredentials(\r\n    uint256 _stakerProxyId,\r\n    uint64 _oracleTimestamp,\r\n    BeaconChainProofs.StateRootProof calldata _stateRootProof,\r\n    uint40[] calldata _validatorIndices,\r\n    bytes[] calldata _validatorFieldsProofs,\r\n    bytes32[][] calldata _validatorFields\r\n  ) external;\r\n\r\n  /**\r\n   * @dev Verifies and processes withdrawals for a staker proxy.\r\n   * @param _stakerProxyId The ID of the staker proxy.\r\n   * @param _oracleTimestamp The timestamp provided by the oracle.\r\n   * @param _stateRootProof The proof of the state root.\r\n   * @param _withdrawalProofs An array of withdrawal proofs.\r\n   * @param _validatorFieldsProofs An array of validator fields proofs.\r\n   * @param _validatorFields An array of validator fields.\r\n   * @param _withdrawalFields An array of withdrawal fields.\r\n   */\r\n  function verifyAndProcessWithdrawals(\r\n    uint256 _stakerProxyId,\r\n    uint64 _oracleTimestamp,\r\n    BeaconChainProofs.StateRootProof calldata _stateRootProof,\r\n    BeaconChainProofs.WithdrawalProof[] calldata _withdrawalProofs,\r\n    bytes[] calldata _validatorFieldsProofs,\r\n    bytes32[][] calldata _validatorFields,\r\n    bytes32[][] calldata _withdrawalFields\r\n  ) external;\r\n\r\n  /**\r\n   * @dev Undelegates a staker from an operator.\r\n   * @param _stakerId The ID of the staker to undelegate.\r\n   */\r\n  function undelegateStakerFromOperator(uint256 _stakerId) external;\r\n\r\n  /**\r\n   * @dev Batch undelegates multiple stakers from their associated operators.\r\n   * @param _stakerIdArray An array of staker IDs to undelegate.\r\n   */\r\n  function batchUndelegateStakerFromOperator(\r\n    uint256[] calldata _stakerIdArray\r\n  ) external;\r\n\r\n  /**\r\n   * @dev Batch withdraws ERC20 tokens from a specific staker's pod.\r\n   * @param _stakeId The ID of the stake.\r\n   * @param _tokens An array of ERC20 tokens to withdraw.\r\n   * @param _amounts An array of amounts to withdraw for each token.\r\n   * @param _recipient The address to receive the withdrawn tokens.\r\n   */\r\n  function batchWithdrawERC20(\r\n    uint256 _stakeId,\r\n    IERC20[] memory _tokens,\r\n    uint256[] memory _amounts,\r\n    address _recipient\r\n  ) external;\r\n\r\n  /**\r\n   * @dev Allows a Swell Admin to create a batch of stakerProxy contracts with associated Eigen Pods.\r\n   * @param _batchSize The amount of stakerProxy contracts to create.\r\n   */\r\n  function createStakerAndPod(uint256 _batchSize) external;\r\n\r\n  /**\r\n   * @dev Registers the implementation of the StakerProxy contract.\r\n   * @param _beacon The address of the beacon contract.\r\n   */\r\n  function registerStakerProxyImplementation(address _beacon) external;\r\n\r\n  /**\r\n   * @dev Upgrades the StakerProxy contract to a new implementation.\r\n   * @param _newImplementation The address of the new implementation contract.\r\n   */\r\n  function upgradeStakerProxy(address _newImplementation) external;\r\n}\r\n"},"@prb/math/src/sd59x18/ValueType.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport \"./Casting.sol\" as C;\nimport \"./Helpers.sol\" as H;\nimport \"./Math.sol\" as M;\n\n/// @notice The signed 59.18-decimal fixed-point number representation, which can have up to 59 digits and up to 18 decimals.\n/// The values of this are bound by the minimum and the maximum values permitted by the underlying Solidity type int256.\ntype SD59x18 is int256;\n\n/*//////////////////////////////////////////////////////////////////////////\n                                    CASTING\n//////////////////////////////////////////////////////////////////////////*/\n\nusing {\n    C.intoInt256,\n    C.intoSD1x18,\n    C.intoUD2x18,\n    C.intoUD60x18,\n    C.intoUint256,\n    C.intoUint128,\n    C.intoUint40,\n    C.unwrap\n} for SD59x18 global;\n\n/*//////////////////////////////////////////////////////////////////////////\n                            MATHEMATICAL FUNCTIONS\n//////////////////////////////////////////////////////////////////////////*/\n\nusing {\n    M.abs,\n    M.avg,\n    M.ceil,\n    M.div,\n    M.exp,\n    M.exp2,\n    M.floor,\n    M.frac,\n    M.gm,\n    M.inv,\n    M.log10,\n    M.log2,\n    M.ln,\n    M.mul,\n    M.pow,\n    M.powu,\n    M.sqrt\n} for SD59x18 global;\n\n/*//////////////////////////////////////////////////////////////////////////\n                                HELPER FUNCTIONS\n//////////////////////////////////////////////////////////////////////////*/\n\nusing {\n    H.add,\n    H.and,\n    H.eq,\n    H.gt,\n    H.gte,\n    H.isZero,\n    H.lshift,\n    H.lt,\n    H.lte,\n    H.mod,\n    H.neq,\n    H.or,\n    H.rshift,\n    H.sub,\n    H.uncheckedAdd,\n    H.uncheckedSub,\n    H.uncheckedUnary,\n    H.xor\n} for SD59x18 global;\n"},"@prb/math/src/ud60x18/ValueType.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport \"./Casting.sol\" as C;\nimport \"./Helpers.sol\" as H;\nimport \"./Math.sol\" as M;\n\n/// @notice The unsigned 60.18-decimal fixed-point number representation, which can have up to 60 digits and up to 18 decimals.\n/// The values of this are bound by the minimum and the maximum values permitted by the Solidity type uint256.\n/// @dev The value type is defined here so it can be imported in all other files.\ntype UD60x18 is uint256;\n\n/*//////////////////////////////////////////////////////////////////////////\n                                    CASTING\n//////////////////////////////////////////////////////////////////////////*/\n\nusing { C.intoSD1x18, C.intoUD2x18, C.intoSD59x18, C.intoUint128, C.intoUint256, C.intoUint40, C.unwrap } for UD60x18 global;\n\n/*//////////////////////////////////////////////////////////////////////////\n                            MATHEMATICAL FUNCTIONS\n//////////////////////////////////////////////////////////////////////////*/\n\n/// The global \"using for\" directive makes the functions in this library callable on the UD60x18 type.\nusing {\n    M.avg,\n    M.ceil,\n    M.div,\n    M.exp,\n    M.exp2,\n    M.floor,\n    M.frac,\n    M.gm,\n    M.inv,\n    M.ln,\n    M.log10,\n    M.log2,\n    M.mul,\n    M.pow,\n    M.powu,\n    M.sqrt\n} for UD60x18 global;\n\n/*//////////////////////////////////////////////////////////////////////////\n                                HELPER FUNCTIONS\n//////////////////////////////////////////////////////////////////////////*/\n\n/// The global \"using for\" directive makes the functions in this library callable on the UD60x18 type.\nusing {\n    H.add,\n    H.and,\n    H.eq,\n    H.gt,\n    H.gte,\n    H.isZero,\n    H.lshift,\n    H.lt,\n    H.lte,\n    H.mod,\n    H.neq,\n    H.or,\n    H.rshift,\n    H.sub,\n    H.uncheckedAdd,\n    H.uncheckedSub,\n    H.xor\n} for UD60x18 global;\n"},"@prb/math/src/sd1x18/ValueType.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport \"./Casting.sol\" as C;\n\n/// @notice The signed 1.18-decimal fixed-point number representation, which can have up to 1 digit and up to 18 decimals.\n/// The values of this are bound by the minimum and the maximum values permitted by the underlying Solidity type int64.\n/// This is useful when end users want to use int64 to save gas, e.g. with tight variable packing in contract storage.\ntype SD1x18 is int64;\n\n/*//////////////////////////////////////////////////////////////////////////\n                                    CASTING\n//////////////////////////////////////////////////////////////////////////*/\n\nusing { C.intoSD59x18, C.intoUD2x18, C.intoUD60x18, C.intoUint256, C.intoUint128, C.intoUint40, C.unwrap } for SD1x18 global;\n"},"@prb/math/src/ud60x18/Casting.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport { MAX_UINT128, MAX_UINT40 } from \"../Common.sol\";\nimport { uMAX_SD1x18 } from \"../sd1x18/Constants.sol\";\nimport { SD1x18 } from \"../sd1x18/ValueType.sol\";\nimport { uMAX_SD59x18 } from \"../sd59x18/Constants.sol\";\nimport { SD59x18 } from \"../sd59x18/ValueType.sol\";\nimport { uMAX_UD2x18 } from \"../ud2x18/Constants.sol\";\nimport { UD2x18 } from \"../ud2x18/ValueType.sol\";\nimport {\n    PRBMath_UD60x18_IntoSD1x18_Overflow,\n    PRBMath_UD60x18_IntoUD2x18_Overflow,\n    PRBMath_UD60x18_IntoSD59x18_Overflow,\n    PRBMath_UD60x18_IntoUint128_Overflow,\n    PRBMath_UD60x18_IntoUint40_Overflow\n} from \"./Errors.sol\";\nimport { UD60x18 } from \"./ValueType.sol\";\n\n/// @notice Casts an UD60x18 number into SD1x18.\n/// @dev Requirements:\n/// - x must be less than or equal to `uMAX_SD1x18`.\nfunction intoSD1x18(UD60x18 x) pure returns (SD1x18 result) {\n    uint256 xUint = UD60x18.unwrap(x);\n    if (xUint > uint256(int256(uMAX_SD1x18))) {\n        revert PRBMath_UD60x18_IntoSD1x18_Overflow(x);\n    }\n    result = SD1x18.wrap(int64(uint64(xUint)));\n}\n\n/// @notice Casts an UD60x18 number into UD2x18.\n/// @dev Requirements:\n/// - x must be less than or equal to `uMAX_UD2x18`.\nfunction intoUD2x18(UD60x18 x) pure returns (UD2x18 result) {\n    uint256 xUint = UD60x18.unwrap(x);\n    if (xUint > uMAX_UD2x18) {\n        revert PRBMath_UD60x18_IntoUD2x18_Overflow(x);\n    }\n    result = UD2x18.wrap(uint64(xUint));\n}\n\n/// @notice Casts an UD60x18 number into SD59x18.\n/// @dev Requirements:\n/// - x must be less than or equal to `uMAX_SD59x18`.\nfunction intoSD59x18(UD60x18 x) pure returns (SD59x18 result) {\n    uint256 xUint = UD60x18.unwrap(x);\n    if (xUint > uint256(uMAX_SD59x18)) {\n        revert PRBMath_UD60x18_IntoSD59x18_Overflow(x);\n    }\n    result = SD59x18.wrap(int256(xUint));\n}\n\n/// @notice Casts an UD60x18 number into uint128.\n/// @dev This is basically a functional alias for the `unwrap` function.\nfunction intoUint256(UD60x18 x) pure returns (uint256 result) {\n    result = UD60x18.unwrap(x);\n}\n\n/// @notice Casts an UD60x18 number into uint128.\n/// @dev Requirements:\n/// - x must be less than or equal to `MAX_UINT128`.\nfunction intoUint128(UD60x18 x) pure returns (uint128 result) {\n    uint256 xUint = UD60x18.unwrap(x);\n    if (xUint > MAX_UINT128) {\n        revert PRBMath_UD60x18_IntoUint128_Overflow(x);\n    }\n    result = uint128(xUint);\n}\n\n/// @notice Casts an UD60x18 number into uint40.\n/// @dev Requirements:\n/// - x must be less than or equal to `MAX_UINT40`.\nfunction intoUint40(UD60x18 x) pure returns (uint40 result) {\n    uint256 xUint = UD60x18.unwrap(x);\n    if (xUint > MAX_UINT40) {\n        revert PRBMath_UD60x18_IntoUint40_Overflow(x);\n    }\n    result = uint40(xUint);\n}\n\n/// @notice Alias for the `wrap` function.\nfunction ud(uint256 x) pure returns (UD60x18 result) {\n    result = wrap(x);\n}\n\n/// @notice Alias for the `wrap` function.\nfunction ud60x18(uint256 x) pure returns (UD60x18 result) {\n    result = wrap(x);\n}\n\n/// @notice Unwraps an UD60x18 number into uint256.\nfunction unwrap(UD60x18 x) pure returns (uint256 result) {\n    result = UD60x18.unwrap(x);\n}\n\n/// @notice Wraps an uint256 number into the UD60x18 value type.\nfunction wrap(uint256 x) pure returns (UD60x18 result) {\n    result = UD60x18.wrap(x);\n}\n"},"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"},"@prb/math/src/sd59x18/Helpers.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport { unwrap, wrap } from \"./Casting.sol\";\nimport { SD59x18 } from \"./ValueType.sol\";\n\n/// @notice Implements the checked addition operation (+) in the SD59x18 type.\nfunction add(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\n    return wrap(unwrap(x) + unwrap(y));\n}\n\n/// @notice Implements the AND (&) bitwise operation in the SD59x18 type.\nfunction and(SD59x18 x, int256 bits) pure returns (SD59x18 result) {\n    return wrap(unwrap(x) & bits);\n}\n\n/// @notice Implements the equal (=) operation in the SD59x18 type.\nfunction eq(SD59x18 x, SD59x18 y) pure returns (bool result) {\n    result = unwrap(x) == unwrap(y);\n}\n\n/// @notice Implements the greater than operation (>) in the SD59x18 type.\nfunction gt(SD59x18 x, SD59x18 y) pure returns (bool result) {\n    result = unwrap(x) > unwrap(y);\n}\n\n/// @notice Implements the greater than or equal to operation (>=) in the SD59x18 type.\nfunction gte(SD59x18 x, SD59x18 y) pure returns (bool result) {\n    result = unwrap(x) >= unwrap(y);\n}\n\n/// @notice Implements a zero comparison check function in the SD59x18 type.\nfunction isZero(SD59x18 x) pure returns (bool result) {\n    result = unwrap(x) == 0;\n}\n\n/// @notice Implements the left shift operation (<<) in the SD59x18 type.\nfunction lshift(SD59x18 x, uint256 bits) pure returns (SD59x18 result) {\n    result = wrap(unwrap(x) << bits);\n}\n\n/// @notice Implements the lower than operation (<) in the SD59x18 type.\nfunction lt(SD59x18 x, SD59x18 y) pure returns (bool result) {\n    result = unwrap(x) < unwrap(y);\n}\n\n/// @notice Implements the lower than or equal to operation (<=) in the SD59x18 type.\nfunction lte(SD59x18 x, SD59x18 y) pure returns (bool result) {\n    result = unwrap(x) <= unwrap(y);\n}\n\n/// @notice Implements the unchecked modulo operation (%) in the SD59x18 type.\nfunction mod(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\n    result = wrap(unwrap(x) % unwrap(y));\n}\n\n/// @notice Implements the not equal operation (!=) in the SD59x18 type.\nfunction neq(SD59x18 x, SD59x18 y) pure returns (bool result) {\n    result = unwrap(x) != unwrap(y);\n}\n\n/// @notice Implements the OR (|) bitwise operation in the SD59x18 type.\nfunction or(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\n    result = wrap(unwrap(x) | unwrap(y));\n}\n\n/// @notice Implements the right shift operation (>>) in the SD59x18 type.\nfunction rshift(SD59x18 x, uint256 bits) pure returns (SD59x18 result) {\n    result = wrap(unwrap(x) >> bits);\n}\n\n/// @notice Implements the checked subtraction operation (-) in the SD59x18 type.\nfunction sub(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\n    result = wrap(unwrap(x) - unwrap(y));\n}\n\n/// @notice Implements the unchecked addition operation (+) in the SD59x18 type.\nfunction uncheckedAdd(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\n    unchecked {\n        result = wrap(unwrap(x) + unwrap(y));\n    }\n}\n\n/// @notice Implements the unchecked subtraction operation (-) in the SD59x18 type.\nfunction uncheckedSub(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\n    unchecked {\n        result = wrap(unwrap(x) - unwrap(y));\n    }\n}\n\n/// @notice Implements the unchecked unary minus operation (-) in the SD59x18 type.\nfunction uncheckedUnary(SD59x18 x) pure returns (SD59x18 result) {\n    unchecked {\n        result = wrap(-unwrap(x));\n    }\n}\n\n/// @notice Implements the XOR (^) bitwise operation in the SD59x18 type.\nfunction xor(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\n    result = wrap(unwrap(x) ^ unwrap(y));\n}\n"},"@prb/math/src/sd1x18/Casting.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport { MAX_UINT40 } from \"../Common.sol\";\nimport { SD59x18 } from \"../sd59x18/ValueType.sol\";\nimport { UD2x18 } from \"../ud2x18/ValueType.sol\";\nimport { UD60x18 } from \"../ud60x18/ValueType.sol\";\nimport {\n    PRBMath_SD1x18_ToUD2x18_Underflow,\n    PRBMath_SD1x18_ToUD60x18_Underflow,\n    PRBMath_SD1x18_ToUint128_Underflow,\n    PRBMath_SD1x18_ToUint256_Underflow,\n    PRBMath_SD1x18_ToUint40_Overflow,\n    PRBMath_SD1x18_ToUint40_Underflow\n} from \"./Errors.sol\";\nimport { SD1x18 } from \"./ValueType.sol\";\n\n/// @notice Casts an SD1x18 number into SD59x18.\n/// @dev There is no overflow check because the domain of SD1x18 is a subset of SD59x18.\nfunction intoSD59x18(SD1x18 x) pure returns (SD59x18 result) {\n    result = SD59x18.wrap(int256(SD1x18.unwrap(x)));\n}\n\n/// @notice Casts an SD1x18 number into UD2x18.\n/// - x must be positive.\nfunction intoUD2x18(SD1x18 x) pure returns (UD2x18 result) {\n    int64 xInt = SD1x18.unwrap(x);\n    if (xInt < 0) {\n        revert PRBMath_SD1x18_ToUD2x18_Underflow(x);\n    }\n    result = UD2x18.wrap(uint64(xInt));\n}\n\n/// @notice Casts an SD1x18 number into UD60x18.\n/// @dev Requirements:\n/// - x must be positive.\nfunction intoUD60x18(SD1x18 x) pure returns (UD60x18 result) {\n    int64 xInt = SD1x18.unwrap(x);\n    if (xInt < 0) {\n        revert PRBMath_SD1x18_ToUD60x18_Underflow(x);\n    }\n    result = UD60x18.wrap(uint64(xInt));\n}\n\n/// @notice Casts an SD1x18 number into uint256.\n/// @dev Requirements:\n/// - x must be positive.\nfunction intoUint256(SD1x18 x) pure returns (uint256 result) {\n    int64 xInt = SD1x18.unwrap(x);\n    if (xInt < 0) {\n        revert PRBMath_SD1x18_ToUint256_Underflow(x);\n    }\n    result = uint256(uint64(xInt));\n}\n\n/// @notice Casts an SD1x18 number into uint128.\n/// @dev Requirements:\n/// - x must be positive.\nfunction intoUint128(SD1x18 x) pure returns (uint128 result) {\n    int64 xInt = SD1x18.unwrap(x);\n    if (xInt < 0) {\n        revert PRBMath_SD1x18_ToUint128_Underflow(x);\n    }\n    result = uint128(uint64(xInt));\n}\n\n/// @notice Casts an SD1x18 number into uint40.\n/// @dev Requirements:\n/// - x must be positive.\n/// - x must be less than or equal to `MAX_UINT40`.\nfunction intoUint40(SD1x18 x) pure returns (uint40 result) {\n    int64 xInt = SD1x18.unwrap(x);\n    if (xInt < 0) {\n        revert PRBMath_SD1x18_ToUint40_Underflow(x);\n    }\n    if (xInt > int64(uint64(MAX_UINT40))) {\n        revert PRBMath_SD1x18_ToUint40_Overflow(x);\n    }\n    result = uint40(uint64(xInt));\n}\n\n/// @notice Alias for the `wrap` function.\nfunction sd1x18(int64 x) pure returns (SD1x18 result) {\n    result = wrap(x);\n}\n\n/// @notice Unwraps an SD1x18 number into int64.\nfunction unwrap(SD1x18 x) pure returns (int64 result) {\n    result = SD1x18.unwrap(x);\n}\n\n/// @notice Wraps an int64 number into the SD1x18 value type.\nfunction wrap(int64 x) pure returns (SD1x18 result) {\n    result = SD1x18.wrap(x);\n}\n"},"@openzeppelin/contracts/utils/Address.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"},"@prb/math/src/ud60x18/Conversions.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport { uMAX_UD60x18, uUNIT } from \"./Constants.sol\";\nimport { PRBMath_UD60x18_Convert_Overflow } from \"./Errors.sol\";\nimport { UD60x18 } from \"./ValueType.sol\";\n\n/// @notice Converts an UD60x18 number to a simple integer by dividing it by `UNIT`. Rounds towards zero in the process.\n/// @dev Rounds down in the process.\n/// @param x The UD60x18 number to convert.\n/// @return result The same number in basic integer form.\nfunction convert(UD60x18 x) pure returns (uint256 result) {\n    result = UD60x18.unwrap(x) / uUNIT;\n}\n\n/// @notice Converts a simple integer to UD60x18 by multiplying it by `UNIT`.\n///\n/// @dev Requirements:\n/// - x must be less than or equal to `MAX_UD60x18` divided by `UNIT`.\n///\n/// @param x The basic integer to convert.\n/// @param result The same number converted to UD60x18.\nfunction convert(uint256 x) pure returns (UD60x18 result) {\n    if (x > uMAX_UD60x18 / uUNIT) {\n        revert PRBMath_UD60x18_Convert_Overflow(x);\n    }\n    unchecked {\n        result = UD60x18.wrap(x * uUNIT);\n    }\n}\n\n/// @notice Alias for the `convert` function defined above.\n/// @dev Here for backward compatibility. Will be removed in V4.\nfunction fromUD60x18(UD60x18 x) pure returns (uint256 result) {\n    result = convert(x);\n}\n\n/// @notice Alias for the `convert` function defined above.\n/// @dev Here for backward compatibility. Will be removed in V4.\nfunction toUD60x18(uint256 x) pure returns (UD60x18 result) {\n    result = convert(x);\n}\n"},"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.1) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"},"@prb/math/src/ud2x18/Constants.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport { UD2x18 } from \"./ValueType.sol\";\n\n/// @dev Euler's number as an UD2x18 number.\nUD2x18 constant E = UD2x18.wrap(2_718281828459045235);\n\n/// @dev The maximum value an UD2x18 number can have.\nuint64 constant uMAX_UD2x18 = 18_446744073709551615;\nUD2x18 constant MAX_UD2x18 = UD2x18.wrap(uMAX_UD2x18);\n\n/// @dev PI as an UD2x18 number.\nUD2x18 constant PI = UD2x18.wrap(3_141592653589793238);\n\n/// @dev The unit amount that implies how many trailing decimals can be represented.\nuint256 constant uUNIT = 1e18;\nUD2x18 constant UNIT = UD2x18.wrap(1e18);\n"},"contracts/implementations/Whitelist.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.16;\r\n\r\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\r\n\r\nimport {IAccessControlManager} from \"../interfaces/IAccessControlManager.sol\";\r\nimport {IWhitelist} from \"../interfaces/IWhitelist.sol\";\r\n\r\nimport {SwellLib} from \"../libraries/SwellLib.sol\";\r\n\r\n/**\r\n  @title Whitelist\r\n  @author https://github.com/max-taylor \r\n  @dev Contract to manage a whitelist, used in the rswETH contract to handle allowed depositors\r\n*/\r\ncontract Whitelist is Initializable, IWhitelist {\r\n  IAccessControlManager public AccessControlManager;\r\n\r\n  mapping(address => bool) public override whitelistedAddresses;\r\n\r\n  bool public override whitelistEnabled;\r\n\r\n  /// @custom:oz-upgrades-unsafe-allow constructor\r\n  constructor() {\r\n    _disableInitializers();\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to check for empty addresses\r\n   * @param _address The address to check\r\n   */\r\n  modifier checkZeroAddress(address _address) {\r\n    SwellLib._checkZeroAddress(_address);\r\n\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * Helper to check the sender against the given role\r\n   * @param role The role to check for the msg.sender\r\n   */\r\n  modifier checkRole(bytes32 role) {\r\n    AccessControlManager.checkRole(role, msg.sender);\r\n\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Method checks if the whitelist is enabled and also whether the address is in the whitelist, reverting if true.\r\n   * @param _address The address to check in the whitelist\r\n   */\r\n  modifier checkWhitelist(address _address) {\r\n    if (whitelistEnabled && !whitelistedAddresses[_address]) {\r\n      revert NotInWhitelist();\r\n    }\r\n\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev This contract is intended to be inherited from a parent contract, so using an onlyInitializing modifier to allow that.\r\n   * @param _accessControlManager The access control manager to use for role management\r\n   */\r\n  function __Whitelist_init(\r\n    IAccessControlManager _accessControlManager\r\n  ) internal onlyInitializing checkZeroAddress(address(_accessControlManager)) {\r\n    AccessControlManager = _accessControlManager;\r\n\r\n    whitelistEnabled = true;\r\n  }\r\n\r\n  // ************************************\r\n  // ***** External methods ******\r\n\r\n  function addToWhitelist(\r\n    address _address\r\n  ) external override checkRole(SwellLib.PLATFORM_ADMIN) {\r\n    _checkAndAddToWhitelist(_address);\r\n  }\r\n\r\n  function batchAddToWhitelist(\r\n    address[] calldata _addresses\r\n  ) external checkRole(SwellLib.PLATFORM_ADMIN) {\r\n    uint256 addressesLength = _addresses.length;\r\n\r\n    for (uint256 i; i < addressesLength; ) {\r\n      _checkAndAddToWhitelist(_addresses[i]);\r\n\r\n      unchecked {\r\n        ++i;\r\n      }\r\n    }\r\n  }\r\n\r\n  function removeFromWhitelist(\r\n    address _address\r\n  ) external override checkRole(SwellLib.PLATFORM_ADMIN) {\r\n    _checkAndRemoveFromWhitelist(_address);\r\n  }\r\n\r\n  function batchRemoveFromWhitelist(\r\n    address[] calldata _addresses\r\n  ) external checkRole(SwellLib.PLATFORM_ADMIN) {\r\n    uint256 addressesLength = _addresses.length;\r\n\r\n    for (uint256 i; i < addressesLength; ) {\r\n      _checkAndRemoveFromWhitelist(_addresses[i]);\r\n\r\n      unchecked {\r\n        ++i;\r\n      }\r\n    }\r\n  }\r\n\r\n  function enableWhitelist()\r\n    external\r\n    override\r\n    checkRole(SwellLib.PLATFORM_ADMIN)\r\n  {\r\n    if (whitelistEnabled) {\r\n      revert WhitelistAlreadyEnabled();\r\n    }\r\n\r\n    whitelistEnabled = true;\r\n\r\n    emit WhitelistEnabled();\r\n  }\r\n\r\n  function disableWhitelist()\r\n    external\r\n    override\r\n    checkRole(SwellLib.PLATFORM_ADMIN)\r\n  {\r\n    if (!whitelistEnabled) {\r\n      revert WhitelistAlreadyDisabled();\r\n    }\r\n\r\n    whitelistEnabled = false;\r\n\r\n    emit WhitelistDisabled();\r\n  }\r\n\r\n  // ************************************\r\n  // ***** Internal methods ******\r\n\r\n  /**\r\n   * @dev This method checks if the given address is the zero address or is in the whitelist already, reverting if true; otherwise the address is added and an event is emitted\r\n   * @param _address The address to check and add to the whitelist\r\n   */\r\n  function _checkAndAddToWhitelist(address _address) internal {\r\n    SwellLib._checkZeroAddress(_address);\r\n\r\n    if (whitelistedAddresses[_address]) {\r\n      revert AddressAlreadyInWhitelist(_address);\r\n    }\r\n\r\n    whitelistedAddresses[_address] = true;\r\n\r\n    emit AddedToWhitelist(_address);\r\n  }\r\n\r\n  /**\r\n   * @dev This method checks if the address doesn't exist within the whitelist and reverts if true, otherwise the address is removed from the whitelist and an event is emitted\r\n   * @param _address The address to check and remove from the whitelist\r\n   */\r\n  function _checkAndRemoveFromWhitelist(address _address) internal {\r\n    if (!whitelistedAddresses[_address]) {\r\n      revert AddressMissingFromWhitelist(_address);\r\n    }\r\n\r\n    whitelistedAddresses[_address] = false;\r\n\r\n    emit RemovedFromWhitelist(_address);\r\n  }\r\n\r\n  /**\r\n   * @dev Gap for upgrades\r\n   */\r\n  uint256[45] private __gap;\r\n}\r\n"},"contracts/vendors/contracts/interfaces/IPausable.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity >=0.5.0;\r\n\r\nimport \"../interfaces/IPauserRegistry.sol\";\r\n\r\n/**\r\n * @title Adds pausability to a contract, with pausing & unpausing controlled by the `pauser` and `unpauser` of a PauserRegistry contract.\r\n * @author Layr Labs, Inc.\r\n * @notice Terms of Service: https://docs.eigenlayer.xyz/overview/terms-of-service\r\n * @notice Contracts that inherit from this contract may define their own `pause` and `unpause` (and/or related) functions.\r\n * These functions should be permissioned as \"onlyPauser\" which defers to a `PauserRegistry` for determining access control.\r\n * @dev Pausability is implemented using a uint256, which allows up to 256 different single bit-flags; each bit can potentially pause different functionality.\r\n * Inspiration for this was taken from the NearBridge design here https://etherscan.io/address/0x3FEFc5A4B1c02f21cBc8D3613643ba0635b9a873#code.\r\n * For the `pause` and `unpause` functions we've implemented, if you pause, you can only flip (any number of) switches to on/1 (aka \"paused\"), and if you unpause,\r\n * you can only flip (any number of) switches to off/0 (aka \"paused\").\r\n * If you want a pauseXYZ function that just flips a single bit / \"pausing flag\", it will:\r\n * 1) 'bit-wise and' (aka `&`) a flag with the current paused state (as a uint256)\r\n * 2) update the paused state to this new value\r\n * @dev We note as well that we have chosen to identify flags by their *bit index* as opposed to their numerical value, so, e.g. defining `DEPOSITS_PAUSED = 3`\r\n * indicates specifically that if the *third bit* of `_paused` is flipped -- i.e. it is a '1' -- then deposits should be paused\r\n */\r\n\r\ninterface IPausable {\r\n    /// @notice Emitted when the `pauserRegistry` is set to `newPauserRegistry`.\r\n    event PauserRegistrySet(IPauserRegistry pauserRegistry, IPauserRegistry newPauserRegistry);\r\n\r\n    /// @notice Emitted when the pause is triggered by `account`, and changed to `newPausedStatus`.\r\n    event Paused(address indexed account, uint256 newPausedStatus);\r\n\r\n    /// @notice Emitted when the pause is lifted by `account`, and changed to `newPausedStatus`.\r\n    event Unpaused(address indexed account, uint256 newPausedStatus);\r\n    \r\n    /// @notice Address of the `PauserRegistry` contract that this contract defers to for determining access control (for pausing).\r\n    function pauserRegistry() external view returns (IPauserRegistry);\r\n\r\n    /**\r\n     * @notice This function is used to pause an EigenLayer contract's functionality.\r\n     * It is permissioned to the `pauser` address, which is expected to be a low threshold multisig.\r\n     * @param newPausedStatus represents the new value for `_paused` to take, which means it may flip several bits at once.\r\n     * @dev This function can only pause functionality, and thus cannot 'unflip' any bit in `_paused` from 1 to 0.\r\n     */\r\n    function pause(uint256 newPausedStatus) external;\r\n\r\n    /**\r\n     * @notice Alias for `pause(type(uint256).max)`.\r\n     */\r\n    function pauseAll() external;\r\n\r\n    /**\r\n     * @notice This function is used to unpause an EigenLayer contract's functionality.\r\n     * It is permissioned to the `unpauser` address, which is expected to be a high threshold multisig or governance contract.\r\n     * @param newPausedStatus represents the new value for `_paused` to take, which means it may flip several bits at once.\r\n     * @dev This function can only unpause functionality, and thus cannot 'flip' any bit in `_paused` from 0 to 1.\r\n     */\r\n    function unpause(uint256 newPausedStatus) external;\r\n\r\n    /// @notice Returns the current paused status as a uint256.\r\n    function paused() external view returns (uint256);\r\n\r\n    /// @notice Returns 'true' if the `indexed`th bit of `_paused` is 1, and 'false' otherwise\r\n    function paused(uint8 index) external view returns (bool);\r\n\r\n    /// @notice Allows the unpauser to set a new pauser registry\r\n    function setPauserRegistry(IPauserRegistry newPauserRegistry) external;\r\n}\r\n"},"contracts/vendors/contracts/interfaces/IStrategyManager.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity >=0.5.0;\r\n\r\nimport \"./IStrategy.sol\";\r\nimport \"./ISlasher.sol\";\r\nimport \"./IDelegationManager.sol\";\r\nimport \"./IEigenPodManager.sol\";\r\n\r\n/**\r\n * @title Interface for the primary entrypoint for funds into EigenLayer.\r\n * @author Layr Labs, Inc.\r\n * @notice Terms of Service: https://docs.eigenlayer.xyz/overview/terms-of-service\r\n * @notice See the `StrategyManager` contract itself for implementation details.\r\n */\r\ninterface IStrategyManager {\r\n    /**\r\n     * @notice Emitted when a new deposit occurs on behalf of `staker`.\r\n     * @param staker Is the staker who is depositing funds into EigenLayer.\r\n     * @param strategy Is the strategy that `staker` has deposited into.\r\n     * @param token Is the token that `staker` deposited.\r\n     * @param shares Is the number of new shares `staker` has been granted in `strategy`.\r\n     */\r\n    event Deposit(address staker, IERC20 token, IStrategy strategy, uint256 shares);\r\n\r\n    /// @notice Emitted when `thirdPartyTransfersForbidden` is updated for a strategy and value by the owner\r\n    event UpdatedThirdPartyTransfersForbidden(IStrategy strategy, bool value);\r\n\r\n    /// @notice Emitted when the `strategyWhitelister` is changed\r\n    event StrategyWhitelisterChanged(address previousAddress, address newAddress);\r\n\r\n    /// @notice Emitted when a strategy is added to the approved list of strategies for deposit\r\n    event StrategyAddedToDepositWhitelist(IStrategy strategy);\r\n\r\n    /// @notice Emitted when a strategy is removed from the approved list of strategies for deposit\r\n    event StrategyRemovedFromDepositWhitelist(IStrategy strategy);\r\n\r\n    /**\r\n     * @notice Deposits `amount` of `token` into the specified `strategy`, with the resultant shares credited to `msg.sender`\r\n     * @param strategy is the specified strategy where deposit is to be made,\r\n     * @param token is the denomination in which the deposit is to be made,\r\n     * @param amount is the amount of token to be deposited in the strategy by the staker\r\n     * @return shares The amount of new shares in the `strategy` created as part of the action.\r\n     * @dev The `msg.sender` must have previously approved this contract to transfer at least `amount` of `token` on their behalf.\r\n     * @dev Cannot be called by an address that is 'frozen' (this function will revert if the `msg.sender` is frozen).\r\n     *\r\n     * WARNING: Depositing tokens that allow reentrancy (eg. ERC-777) into a strategy is not recommended.  This can lead to attack vectors\r\n     *          where the token balance and corresponding strategy shares are not in sync upon reentrancy.\r\n     */\r\n    function depositIntoStrategy(IStrategy strategy, IERC20 token, uint256 amount) external returns (uint256 shares);\r\n\r\n    /**\r\n     * @notice Used for depositing an asset into the specified strategy with the resultant shares credited to `staker`,\r\n     * who must sign off on the action.\r\n     * Note that the assets are transferred out/from the `msg.sender`, not from the `staker`; this function is explicitly designed\r\n     * purely to help one address deposit 'for' another.\r\n     * @param strategy is the specified strategy where deposit is to be made,\r\n     * @param token is the denomination in which the deposit is to be made,\r\n     * @param amount is the amount of token to be deposited in the strategy by the staker\r\n     * @param staker the staker that the deposited assets will be credited to\r\n     * @param expiry the timestamp at which the signature expires\r\n     * @param signature is a valid signature from the `staker`. either an ECDSA signature if the `staker` is an EOA, or data to forward\r\n     * following EIP-1271 if the `staker` is a contract\r\n     * @return shares The amount of new shares in the `strategy` created as part of the action.\r\n     * @dev The `msg.sender` must have previously approved this contract to transfer at least `amount` of `token` on their behalf.\r\n     * @dev A signature is required for this function to eliminate the possibility of griefing attacks, specifically those\r\n     * targeting stakers who may be attempting to undelegate.\r\n     * @dev Cannot be called if thirdPartyTransfersForbidden is set to true for this strategy\r\n     *\r\n     *  WARNING: Depositing tokens that allow reentrancy (eg. ERC-777) into a strategy is not recommended.  This can lead to attack vectors\r\n     *          where the token balance and corresponding strategy shares are not in sync upon reentrancy\r\n     */\r\n    function depositIntoStrategyWithSignature(\r\n        IStrategy strategy,\r\n        IERC20 token,\r\n        uint256 amount,\r\n        address staker,\r\n        uint256 expiry,\r\n        bytes memory signature\r\n    ) external returns (uint256 shares);\r\n\r\n    /// @notice Used by the DelegationManager to remove a Staker's shares from a particular strategy when entering the withdrawal queue\r\n    function removeShares(address staker, IStrategy strategy, uint256 shares) external;\r\n\r\n    /// @notice Used by the DelegationManager to award a Staker some shares that have passed through the withdrawal queue\r\n    function addShares(address staker, IERC20 token, IStrategy strategy, uint256 shares) external;\r\n    \r\n    /// @notice Used by the DelegationManager to convert withdrawn shares to tokens and send them to a recipient\r\n    function withdrawSharesAsTokens(address recipient, IStrategy strategy, uint256 shares, IERC20 token) external;\r\n\r\n    /// @notice Returns the current shares of `user` in `strategy`\r\n    function stakerStrategyShares(address user, IStrategy strategy) external view returns (uint256 shares);\r\n\r\n    /**\r\n     * @notice Get all details on the staker's deposits and corresponding shares\r\n     * @return (staker's strategies, shares in these strategies)\r\n     */\r\n    function getDeposits(address staker) external view returns (IStrategy[] memory, uint256[] memory);\r\n\r\n    /// @notice Simple getter function that returns `stakerStrategyList[staker].length`.\r\n    function stakerStrategyListLength(address staker) external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Owner-only function that adds the provided Strategies to the 'whitelist' of strategies that stakers can deposit into\r\n     * @param strategiesToWhitelist Strategies that will be added to the `strategyIsWhitelistedForDeposit` mapping (if they aren't in it already)\r\n     * @param thirdPartyTransfersForbiddenValues bool values to set `thirdPartyTransfersForbidden` to for each strategy\r\n     */\r\n    function addStrategiesToDepositWhitelist(\r\n        IStrategy[] calldata strategiesToWhitelist,\r\n        bool[] calldata thirdPartyTransfersForbiddenValues\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Owner-only function that removes the provided Strategies from the 'whitelist' of strategies that stakers can deposit into\r\n     * @param strategiesToRemoveFromWhitelist Strategies that will be removed to the `strategyIsWhitelistedForDeposit` mapping (if they are in it)\r\n     */\r\n    function removeStrategiesFromDepositWhitelist(IStrategy[] calldata strategiesToRemoveFromWhitelist) external;\r\n\r\n    /// @notice Returns the single, central Delegation contract of EigenLayer\r\n    function delegation() external view returns (IDelegationManager);\r\n\r\n    /// @notice Returns the single, central Slasher contract of EigenLayer\r\n    function slasher() external view returns (ISlasher);\r\n\r\n    /// @notice Returns the EigenPodManager contract of EigenLayer\r\n    function eigenPodManager() external view returns (IEigenPodManager);\r\n\r\n    /// @notice Returns the address of the `strategyWhitelister`\r\n    function strategyWhitelister() external view returns (address);\r\n\r\n    /**\r\n     * @notice Returns bool for whether or not `strategy` enables credit transfers. i.e enabling\r\n     * depositIntoStrategyWithSignature calls or queueing withdrawals to a different address than the staker.\r\n     */\r\n    function thirdPartyTransfersForbidden(IStrategy strategy) external view returns (bool);\r\n\r\n// LIMITED BACKWARDS-COMPATIBILITY FOR DEPRECATED FUNCTIONALITY\r\n    // packed struct for queued withdrawals; helps deal with stack-too-deep errors\r\n    struct DeprecatedStruct_WithdrawerAndNonce {\r\n        address withdrawer;\r\n        uint96 nonce;\r\n    }\r\n\r\n    /**\r\n     * Struct type used to specify an existing queued withdrawal. Rather than storing the entire struct, only a hash is stored.\r\n     * In functions that operate on existing queued withdrawals -- e.g. `startQueuedWithdrawalWaitingPeriod` or `completeQueuedWithdrawal`,\r\n     * the data is resubmitted and the hash of the submitted data is computed by `calculateWithdrawalRoot` and checked against the\r\n     * stored hash in order to confirm the integrity of the submitted data.\r\n     */\r\n    struct DeprecatedStruct_QueuedWithdrawal {\r\n        IStrategy[] strategies;\r\n        uint256[] shares;\r\n        address staker;\r\n        DeprecatedStruct_WithdrawerAndNonce withdrawerAndNonce;\r\n        uint32 withdrawalStartBlock;\r\n        address delegatedAddress;\r\n    }\r\n\r\n    function migrateQueuedWithdrawal(DeprecatedStruct_QueuedWithdrawal memory queuedWithdrawal) external returns (bool, bytes32);\r\n\r\n    function calculateWithdrawalRoot(DeprecatedStruct_QueuedWithdrawal memory queuedWithdrawal) external pure returns (bytes32);\r\n}\r\n"},"contracts/vendors/contracts/interfaces/ISlasher.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity >=0.5.0;\r\n\r\nimport \"./IStrategyManager.sol\";\r\nimport \"./IDelegationManager.sol\";\r\n\r\n/**\r\n * @title Interface for the primary 'slashing' contract for EigenLayer.\r\n * @author Layr Labs, Inc.\r\n * @notice Terms of Service: https://docs.eigenlayer.xyz/overview/terms-of-service\r\n * @notice See the `Slasher` contract itself for implementation details.\r\n */\r\ninterface ISlasher {\r\n    // struct used to store information about the current state of an operator's obligations to middlewares they are serving\r\n    struct MiddlewareTimes {\r\n        // The update block for the middleware whose most recent update was earliest, i.e. the 'stalest' update out of all middlewares the operator is serving\r\n        uint32 stalestUpdateBlock;\r\n        // The latest 'serveUntilBlock' from all of the middleware that the operator is serving\r\n        uint32 latestServeUntilBlock;\r\n    }\r\n\r\n    // struct used to store details relevant to a single middleware that an operator has opted-in to serving\r\n    struct MiddlewareDetails {\r\n        // the block at which the contract begins being able to finalize the operator's registration with the service via calling `recordFirstStakeUpdate`\r\n        uint32 registrationMayBeginAtBlock;\r\n        // the block before which the contract is allowed to slash the user\r\n        uint32 contractCanSlashOperatorUntilBlock;\r\n        // the block at which the middleware's view of the operator's stake was most recently updated\r\n        uint32 latestUpdateBlock;\r\n    }\r\n\r\n    /// @notice Emitted when a middleware times is added to `operator`'s array.\r\n    event MiddlewareTimesAdded(\r\n        address operator,\r\n        uint256 index,\r\n        uint32 stalestUpdateBlock,\r\n        uint32 latestServeUntilBlock\r\n    );\r\n\r\n    /// @notice Emitted when `operator` begins to allow `contractAddress` to slash them.\r\n    event OptedIntoSlashing(address indexed operator, address indexed contractAddress);\r\n\r\n    /// @notice Emitted when `contractAddress` signals that it will no longer be able to slash `operator` after the `contractCanSlashOperatorUntilBlock`.\r\n    event SlashingAbilityRevoked(\r\n        address indexed operator,\r\n        address indexed contractAddress,\r\n        uint32 contractCanSlashOperatorUntilBlock\r\n    );\r\n\r\n    /**\r\n     * @notice Emitted when `slashingContract` 'freezes' the `slashedOperator`.\r\n     * @dev The `slashingContract` must have permission to slash the `slashedOperator`, i.e. `canSlash(slasherOperator, slashingContract)` must return 'true'.\r\n     */\r\n    event OperatorFrozen(address indexed slashedOperator, address indexed slashingContract);\r\n\r\n    /// @notice Emitted when `previouslySlashedAddress` is 'unfrozen', allowing them to again move deposited funds within EigenLayer.\r\n    event FrozenStatusReset(address indexed previouslySlashedAddress);\r\n\r\n    /**\r\n     * @notice Gives the `contractAddress` permission to slash the funds of the caller.\r\n     * @dev Typically, this function must be called prior to registering for a middleware.\r\n     */\r\n    function optIntoSlashing(address contractAddress) external;\r\n\r\n    /**\r\n     * @notice Used for 'slashing' a certain operator.\r\n     * @param toBeFrozen The operator to be frozen.\r\n     * @dev Technically the operator is 'frozen' (hence the name of this function), and then subject to slashing pending a decision by a human-in-the-loop.\r\n     * @dev The operator must have previously given the caller (which should be a contract) the ability to slash them, through a call to `optIntoSlashing`.\r\n     */\r\n    function freezeOperator(address toBeFrozen) external;\r\n\r\n    /**\r\n     * @notice Removes the 'frozen' status from each of the `frozenAddresses`\r\n     * @dev Callable only by the contract owner (i.e. governance).\r\n     */\r\n    function resetFrozenStatus(address[] calldata frozenAddresses) external;\r\n\r\n    /**\r\n     * @notice this function is a called by middlewares during an operator's registration to make sure the operator's stake at registration\r\n     *         is slashable until serveUntil\r\n     * @param operator the operator whose stake update is being recorded\r\n     * @param serveUntilBlock the block until which the operator's stake at the current block is slashable\r\n     * @dev adds the middleware's slashing contract to the operator's linked list\r\n     */\r\n    function recordFirstStakeUpdate(address operator, uint32 serveUntilBlock) external;\r\n\r\n    /**\r\n     * @notice this function is a called by middlewares during a stake update for an operator (perhaps to free pending withdrawals)\r\n     *         to make sure the operator's stake at updateBlock is slashable until serveUntil\r\n     * @param operator the operator whose stake update is being recorded\r\n     * @param updateBlock the block for which the stake update is being recorded\r\n     * @param serveUntilBlock the block until which the operator's stake at updateBlock is slashable\r\n     * @param insertAfter the element of the operators linked list that the currently updating middleware should be inserted after\r\n     * @dev insertAfter should be calculated offchain before making the transaction that calls this. this is subject to race conditions,\r\n     *      but it is anticipated to be rare and not detrimental.\r\n     */\r\n    function recordStakeUpdate(\r\n        address operator,\r\n        uint32 updateBlock,\r\n        uint32 serveUntilBlock,\r\n        uint256 insertAfter\r\n    ) external;\r\n\r\n    /**\r\n     * @notice this function is a called by middlewares during an operator's deregistration to make sure the operator's stake at deregistration\r\n     *         is slashable until serveUntil\r\n     * @param operator the operator whose stake update is being recorded\r\n     * @param serveUntilBlock the block until which the operator's stake at the current block is slashable\r\n     * @dev removes the middleware's slashing contract to the operator's linked list and revokes the middleware's (i.e. caller's) ability to\r\n     * slash `operator` once `serveUntil` is reached\r\n     */\r\n    function recordLastStakeUpdateAndRevokeSlashingAbility(address operator, uint32 serveUntilBlock) external;\r\n\r\n    /// @notice The StrategyManager contract of EigenLayer\r\n    function strategyManager() external view returns (IStrategyManager);\r\n\r\n    /// @notice The DelegationManager contract of EigenLayer\r\n    function delegation() external view returns (IDelegationManager);\r\n\r\n    /**\r\n     * @notice Used to determine whether `staker` is actively 'frozen'. If a staker is frozen, then they are potentially subject to\r\n     * slashing of their funds, and cannot cannot deposit or withdraw from the strategyManager until the slashing process is completed\r\n     * and the staker's status is reset (to 'unfrozen').\r\n     * @param staker The staker of interest.\r\n     * @return Returns 'true' if `staker` themselves has their status set to frozen, OR if the staker is delegated\r\n     * to an operator who has their status set to frozen. Otherwise returns 'false'.\r\n     */\r\n    function isFrozen(address staker) external view returns (bool);\r\n\r\n    /// @notice Returns true if `slashingContract` is currently allowed to slash `toBeSlashed`.\r\n    function canSlash(address toBeSlashed, address slashingContract) external view returns (bool);\r\n\r\n    /// @notice Returns the block until which `serviceContract` is allowed to slash the `operator`.\r\n    function contractCanSlashOperatorUntilBlock(\r\n        address operator,\r\n        address serviceContract\r\n    ) external view returns (uint32);\r\n\r\n    /// @notice Returns the block at which the `serviceContract` last updated its view of the `operator`'s stake\r\n    function latestUpdateBlock(address operator, address serviceContract) external view returns (uint32);\r\n\r\n    /// @notice A search routine for finding the correct input value of `insertAfter` to `recordStakeUpdate` / `_updateMiddlewareList`.\r\n    function getCorrectValueForInsertAfter(address operator, uint32 updateBlock) external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Returns 'true' if `operator` can currently complete a withdrawal started at the `withdrawalStartBlock`, with `middlewareTimesIndex` used\r\n     * to specify the index of a `MiddlewareTimes` struct in the operator's list (i.e. an index in `operatorToMiddlewareTimes[operator]`). The specified\r\n     * struct is consulted as proof of the `operator`'s ability (or lack thereof) to complete the withdrawal.\r\n     * This function will return 'false' if the operator cannot currently complete a withdrawal started at the `withdrawalStartBlock`, *or* in the event\r\n     * that an incorrect `middlewareTimesIndex` is supplied, even if one or more correct inputs exist.\r\n     * @param operator Either the operator who queued the withdrawal themselves, or if the withdrawing party is a staker who delegated to an operator,\r\n     * this address is the operator *who the staker was delegated to* at the time of the `withdrawalStartBlock`.\r\n     * @param withdrawalStartBlock The block number at which the withdrawal was initiated.\r\n     * @param middlewareTimesIndex Indicates an index in `operatorToMiddlewareTimes[operator]` to consult as proof of the `operator`'s ability to withdraw\r\n     * @dev The correct `middlewareTimesIndex` input should be computable off-chain.\r\n     */\r\n    function canWithdraw(\r\n        address operator,\r\n        uint32 withdrawalStartBlock,\r\n        uint256 middlewareTimesIndex\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * operator =>\r\n     *  [\r\n     *      (\r\n     *          the least recent update block of all of the middlewares it's serving/served,\r\n     *          latest time that the stake bonded at that update needed to serve until\r\n     *      )\r\n     *  ]\r\n     */\r\n    function operatorToMiddlewareTimes(\r\n        address operator,\r\n        uint256 arrayIndex\r\n    ) external view returns (MiddlewareTimes memory);\r\n\r\n    /// @notice Getter function for fetching `operatorToMiddlewareTimes[operator].length`\r\n    function middlewareTimesLength(address operator) external view returns (uint256);\r\n\r\n    /// @notice Getter function for fetching `operatorToMiddlewareTimes[operator][index].stalestUpdateBlock`.\r\n    function getMiddlewareTimesIndexStalestUpdateBlock(address operator, uint32 index) external view returns (uint32);\r\n\r\n    /// @notice Getter function for fetching `operatorToMiddlewareTimes[operator][index].latestServeUntil`.\r\n    function getMiddlewareTimesIndexServeUntilBlock(address operator, uint32 index) external view returns (uint32);\r\n\r\n    /// @notice Getter function for fetching `_operatorToWhitelistedContractsByUpdate[operator].size`.\r\n    function operatorWhitelistedContractsLinkedListSize(address operator) external view returns (uint256);\r\n\r\n    /// @notice Getter function for fetching a single node in the operator's linked list (`_operatorToWhitelistedContractsByUpdate[operator]`).\r\n    function operatorWhitelistedContractsLinkedListEntry(\r\n        address operator,\r\n        address node\r\n    ) external view returns (bool, uint256, uint256);\r\n}\r\n"},"contracts/interfaces/IAccessControlManager.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.16;\r\n\r\nimport {IAccessControlEnumerableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/IAccessControlEnumerableUpgradeable.sol\";\r\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\nimport {IDepositManager} from \"./IDepositManager.sol\";\r\nimport {IrswETH} from \"./IrswETH.sol\";\r\nimport {IrswEXIT} from \"./IrswEXIT.sol\";\r\nimport {INodeOperatorRegistry} from \"./INodeOperatorRegistry.sol\";\r\n\r\n/**\r\n  @title IAccessControlManager\r\n  @author https://github.com/max-taylor \r\n  @dev The interface for the Access Control Manager, which manages roles and permissions for contracts within the Swell ecosystem\r\n*/\r\ninterface IAccessControlManager is IAccessControlEnumerableUpgradeable {\r\n  // ***** Structs ******\r\n\r\n  /**\r\n    @dev Parameters for initializing the contract.\r\n    @param admin The admin address\r\n    @param swellTreasury The swell treasury address\r\n  */\r\n  struct InitializeParams {\r\n    address admin;\r\n    address swellTreasury;\r\n  }\r\n\r\n  // ***** Errors ******\r\n\r\n  /**\r\n    @dev Error thrown when attempting to pause an already-paused boolean\r\n  */\r\n  error AlreadyPaused();\r\n\r\n  /**\r\n    @dev Error thrown when attempting to unpause an already-unpaused boolean\r\n  */\r\n  error AlreadyUnpaused();\r\n\r\n  // ***** Events ******\r\n\r\n  /**\r\n    @dev Emitted when a new DepositManager contract address is set.\r\n    @param newAddress The new DepositManager contract address.\r\n    @param oldAddress The old DepositManager contract address.\r\n  */\r\n  event UpdatedDepositManager(address newAddress, address oldAddress);\r\n\r\n  /**\r\n    @dev Emitted when a new NodeOperatorRegistry contract address is set.\r\n    @param newAddress The new NodeOperatorRegistry contract address.\r\n    @param oldAddress The old NodeOperatorRegistry contract address.\r\n  */\r\n  event UpdatedNodeOperatorRegistry(address newAddress, address oldAddress);\r\n\r\n  /**\r\n    @dev Emitted when a new SwellTreasury contract address is set.\r\n    @param newAddress The new SwellTreasury contract address.\r\n    @param oldAddress The old SwellTreasury contract address.\r\n  */\r\n  event UpdatedSwellTreasury(address newAddress, address oldAddress);\r\n\r\n  /**\r\n    @dev Emitted when a new rswETH contract address is set.\r\n    @param newAddress The new rswETH contract address.\r\n    @param oldAddress The old rswETH contract address.\r\n  */\r\n  event UpdatedRswETH(address newAddress, address oldAddress);\r\n\r\n  /**\r\n    @dev Emitted when a new rswEXIT contract address is set.\r\n    @param newAddress The new rswEXIT contract address.\r\n    @param oldAddress The old rswEXIT contract address.\r\n  */\r\n  event UpdatedRswEXIT(address newAddress, address oldAddress);\r\n\r\n  /**\r\n    @dev Emitted when core methods functionality is paused or unpaused.\r\n    @param newPausedStatus The new paused status.\r\n  */\r\n  event CoreMethodsPause(bool newPausedStatus);\r\n\r\n  /**\r\n    @dev Emitted when bot methods functionality is paused or unpaused.\r\n    @param newPausedStatus The new paused status.\r\n  */\r\n  event BotMethodsPause(bool newPausedStatus);\r\n\r\n  /**\r\n    @dev Emitted when operator methods functionality is paused or unpaused.\r\n    @param newPausedStatus The new paused status.\r\n  */\r\n  event OperatorMethodsPause(bool newPausedStatus);\r\n\r\n  /**\r\n    @dev Emitted when withdrawals functionality is paused or unpaused.\r\n    @param newPausedStatus The new paused status.\r\n  */\r\n  event WithdrawalsPause(bool newPausedStatus);\r\n\r\n  /**\r\n    @dev Emitted when all functionality is paused.\r\n  */\r\n  event Lockdown();\r\n\r\n  // ************************************\r\n  // ***** External Methods ******\r\n\r\n  /**\r\n   * @dev Pass-through method to call the _checkRole method on the inherited access control contract. This method is to be used by external contracts that are using this centralised access control manager, this ensures that if the check fails it reverts with the correct access control error message\r\n   * @param role The role to check\r\n   * @param account The account to check for\r\n   */\r\n  function checkRole(bytes32 role, address account) external view;\r\n\r\n  // ***** Setters ******\r\n\r\n  /**\r\n   * @notice Sets the `rswETH` address to `_rswETH`.\r\n   * @dev This function is only callable by the `PLATFORM_ADMIN` role.\r\n   * @param _rswETH The address of the `rswETH` contract.\r\n   */\r\n  function setRswETH(IrswETH _rswETH) external;\r\n\r\n  /**\r\n   * @notice Sets the `rswEXIT` address to `_rswEXIT`.\r\n   * @dev This function is only callable by the `PLATFORM_ADMIN` role.\r\n   * @param _rswEXIT The address of the `rswEXIT` contract.\r\n   */\r\n  function setRswEXIT(IrswEXIT _rswEXIT) external;\r\n\r\n  /**\r\n   * @notice Sets the `DepositManager` address to `_depositManager`.\r\n   * @dev This function is only callable by the `PLATFORM_ADMIN` role.\r\n   * @param _depositManager The address of the `DepositManager` contract.\r\n   */\r\n  function setDepositManager(IDepositManager _depositManager) external;\r\n\r\n  /**\r\n   * @notice Sets the `NodeOperatorRegistry` address to `_NodeOperatorRegistry`.\r\n   * @dev This function is only callable by the `PLATFORM_ADMIN` role.\r\n   * @param _NodeOperatorRegistry The address of the `NodeOperatorRegistry` contract.\r\n   */\r\n  function setNodeOperatorRegistry(\r\n    INodeOperatorRegistry _NodeOperatorRegistry\r\n  ) external;\r\n\r\n  /**\r\n   * @notice Sets the `SwellTreasury` address to `_swellTreasury`.\r\n   * @dev This function is only callable by the `PLATFORM_ADMIN` role.\r\n   * @param _swellTreasury The new address of the `SwellTreasury` contract.\r\n   */\r\n  function setSwellTreasury(address _swellTreasury) external;\r\n\r\n  // ***** Getters ******\r\n\r\n  /**\r\n    @dev Returns the PLATFORM_ADMIN role.\r\n    @return The bytes32 representation of the PLATFORM_ADMIN role.\r\n  */\r\n  function PLATFORM_ADMIN() external pure returns (bytes32);\r\n\r\n  /**\r\n    @dev Returns the Swell Restaked ETH contract.\r\n    @return The Swell Restaked ETH contract.\r\n  */\r\n  function rswETH() external view returns (IrswETH);\r\n\r\n  /**\r\n   * @dev Returns the rswEXIT contract.\r\n   * @return The rswEXIT contract.\r\n   */\r\n  function rswEXIT() external view returns (IrswEXIT);\r\n\r\n  /**\r\n    @dev Returns the address of the Swell Treasury contract.\r\n    @return The address of the Swell Treasury contract.\r\n  */\r\n  function SwellTreasury() external view returns (address);\r\n\r\n  /**\r\n    @dev Returns the Deposit Manager contract.\r\n    @return The Deposit Manager contract.\r\n  */\r\n  function DepositManager() external view returns (IDepositManager);\r\n\r\n  /**\r\n    @dev Returns the Node Operator Registry contract.\r\n    @return The Node Operator Registry contract.\r\n  */\r\n  function NodeOperatorRegistry() external view returns (INodeOperatorRegistry);\r\n\r\n  /**\r\n    @dev Returns true if core methods are currently paused.\r\n    @return Whether core methods are paused.\r\n  */\r\n  function coreMethodsPaused() external view returns (bool);\r\n\r\n  /**\r\n    @dev Returns true if bot methods are currently paused.\r\n    @return Whether bot methods are paused.\r\n  */\r\n  function botMethodsPaused() external view returns (bool);\r\n\r\n  /**\r\n    @dev Returns true if operator methods are currently paused.\r\n    @return Whether operator methods are paused.\r\n  */\r\n  function operatorMethodsPaused() external view returns (bool);\r\n\r\n  /**\r\n    @dev Returns true if withdrawals are currently paused.\r\n    @dev ! Note that this is completely unused in the current implementation and is a placeholder that will be used once the withdrawals are implemented.\r\n    @return Whether withdrawals are paused.\r\n  */\r\n  function withdrawalsPaused() external view returns (bool);\r\n\r\n  // ***** Pausable methods ******\r\n\r\n  /**\r\n    @dev Pauses the core methods of the Swell ecosystem, only callable by the PAUSER role\r\n  */\r\n  function pauseCoreMethods() external;\r\n\r\n  /**\r\n    @dev Unpauses the core methods of the Swell ecosystem, only callable by the UNPAUSER role\r\n  */\r\n  function unpauseCoreMethods() external;\r\n\r\n  /**\r\n    @dev Pauses the bot specific methods, only callable by the PAUSER role\r\n  */\r\n  function pauseBotMethods() external;\r\n\r\n  /**\r\n    @dev Unpauses the bot specific methods, only callable by the UNPAUSER role\r\n  */\r\n  function unpauseBotMethods() external;\r\n\r\n  /**\r\n    @dev Pauses the operator methods in the NO registry contract, only callable by the PAUSER role\r\n  */\r\n  function pauseOperatorMethods() external;\r\n\r\n  /**\r\n    @dev Unpauses the operator methods in the NO registry contract, only callable by the UNPAUSER role\r\n  */\r\n  function unpauseOperatorMethods() external;\r\n\r\n  /**\r\n    @dev Pauses the withdrawals of the Swell ecosystem, only callable by the PAUSER role\r\n  */\r\n  function pauseWithdrawals() external;\r\n\r\n  /**\r\n    @dev Unpauses the withdrawals of the Swell ecosystem, only callable by the UNPAUSER role\r\n  */\r\n  function unpauseWithdrawals() external;\r\n\r\n  /**\r\n    @dev Pause all the methods in one go, only callable by the PAUSER role.\r\n  */\r\n  function lockdown() external;\r\n\r\n  /**\r\n   * @dev This method withdraws contract's _token balance to a platform admin\r\n   * @param _token The ERC20 token to withdraw from the contract\r\n   */\r\n  function withdrawERC20(IERC20 _token) external;\r\n}\r\n"},"@prb/math/src/sd59x18/Casting.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport { MAX_UINT128, MAX_UINT40 } from \"../Common.sol\";\nimport { uMAX_SD1x18, uMIN_SD1x18 } from \"../sd1x18/Constants.sol\";\nimport { SD1x18 } from \"../sd1x18/ValueType.sol\";\nimport { uMAX_UD2x18 } from \"../ud2x18/Constants.sol\";\nimport { UD2x18 } from \"../ud2x18/ValueType.sol\";\nimport { UD60x18 } from \"../ud60x18/ValueType.sol\";\nimport {\n    PRBMath_SD59x18_IntoSD1x18_Overflow,\n    PRBMath_SD59x18_IntoSD1x18_Underflow,\n    PRBMath_SD59x18_IntoUD2x18_Overflow,\n    PRBMath_SD59x18_IntoUD2x18_Underflow,\n    PRBMath_SD59x18_IntoUD60x18_Underflow,\n    PRBMath_SD59x18_IntoUint128_Overflow,\n    PRBMath_SD59x18_IntoUint128_Underflow,\n    PRBMath_SD59x18_IntoUint256_Underflow,\n    PRBMath_SD59x18_IntoUint40_Overflow,\n    PRBMath_SD59x18_IntoUint40_Underflow\n} from \"./Errors.sol\";\nimport { SD59x18 } from \"./ValueType.sol\";\n\n/// @notice Casts an SD59x18 number into int256.\n/// @dev This is basically a functional alias for the `unwrap` function.\nfunction intoInt256(SD59x18 x) pure returns (int256 result) {\n    result = SD59x18.unwrap(x);\n}\n\n/// @notice Casts an SD59x18 number into SD1x18.\n/// @dev Requirements:\n/// - x must be greater than or equal to `uMIN_SD1x18`.\n/// - x must be less than or equal to `uMAX_SD1x18`.\nfunction intoSD1x18(SD59x18 x) pure returns (SD1x18 result) {\n    int256 xInt = SD59x18.unwrap(x);\n    if (xInt < uMIN_SD1x18) {\n        revert PRBMath_SD59x18_IntoSD1x18_Underflow(x);\n    }\n    if (xInt > uMAX_SD1x18) {\n        revert PRBMath_SD59x18_IntoSD1x18_Overflow(x);\n    }\n    result = SD1x18.wrap(int64(xInt));\n}\n\n/// @notice Casts an SD59x18 number into UD2x18.\n/// @dev Requirements:\n/// - x must be positive.\n/// - x must be less than or equal to `uMAX_UD2x18`.\nfunction intoUD2x18(SD59x18 x) pure returns (UD2x18 result) {\n    int256 xInt = SD59x18.unwrap(x);\n    if (xInt < 0) {\n        revert PRBMath_SD59x18_IntoUD2x18_Underflow(x);\n    }\n    if (xInt > int256(uint256(uMAX_UD2x18))) {\n        revert PRBMath_SD59x18_IntoUD2x18_Overflow(x);\n    }\n    result = UD2x18.wrap(uint64(uint256(xInt)));\n}\n\n/// @notice Casts an SD59x18 number into UD60x18.\n/// @dev Requirements:\n/// - x must be positive.\nfunction intoUD60x18(SD59x18 x) pure returns (UD60x18 result) {\n    int256 xInt = SD59x18.unwrap(x);\n    if (xInt < 0) {\n        revert PRBMath_SD59x18_IntoUD60x18_Underflow(x);\n    }\n    result = UD60x18.wrap(uint256(xInt));\n}\n\n/// @notice Casts an SD59x18 number into uint256.\n/// @dev Requirements:\n/// - x must be positive.\nfunction intoUint256(SD59x18 x) pure returns (uint256 result) {\n    int256 xInt = SD59x18.unwrap(x);\n    if (xInt < 0) {\n        revert PRBMath_SD59x18_IntoUint256_Underflow(x);\n    }\n    result = uint256(xInt);\n}\n\n/// @notice Casts an SD59x18 number into uint128.\n/// @dev Requirements:\n/// - x must be positive.\n/// - x must be less than or equal to `uMAX_UINT128`.\nfunction intoUint128(SD59x18 x) pure returns (uint128 result) {\n    int256 xInt = SD59x18.unwrap(x);\n    if (xInt < 0) {\n        revert PRBMath_SD59x18_IntoUint128_Underflow(x);\n    }\n    if (xInt > int256(uint256(MAX_UINT128))) {\n        revert PRBMath_SD59x18_IntoUint128_Overflow(x);\n    }\n    result = uint128(uint256(xInt));\n}\n\n/// @notice Casts an SD59x18 number into uint40.\n/// @dev Requirements:\n/// - x must be positive.\n/// - x must be less than or equal to `MAX_UINT40`.\nfunction intoUint40(SD59x18 x) pure returns (uint40 result) {\n    int256 xInt = SD59x18.unwrap(x);\n    if (xInt < 0) {\n        revert PRBMath_SD59x18_IntoUint40_Underflow(x);\n    }\n    if (xInt > int256(uint256(MAX_UINT40))) {\n        revert PRBMath_SD59x18_IntoUint40_Overflow(x);\n    }\n    result = uint40(uint256(xInt));\n}\n\n/// @notice Alias for the `wrap` function.\nfunction sd(int256 x) pure returns (SD59x18 result) {\n    result = wrap(x);\n}\n\n/// @notice Alias for the `wrap` function.\nfunction sd59x18(int256 x) pure returns (SD59x18 result) {\n    result = wrap(x);\n}\n\n/// @notice Unwraps an SD59x18 number into int256.\nfunction unwrap(SD59x18 x) pure returns (int256 result) {\n    result = SD59x18.unwrap(x);\n}\n\n/// @notice Wraps an int256 number into the SD59x18 value type.\nfunction wrap(int256 x) pure returns (SD59x18 result) {\n    result = SD59x18.wrap(x);\n}\n"},"@openzeppelin/contracts/token/ERC20/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"},"contracts/vendors/contracts/interfaces/IBeaconChainOracle.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity >=0.5.0;\r\n\r\n/**\r\n * @title Interface for the BeaconStateOracle contract.\r\n * @author Layr Labs, Inc.\r\n * @notice Terms of Service: https://docs.eigenlayer.xyz/overview/terms-of-service\r\n */\r\ninterface IBeaconChainOracle {\r\n    /// @notice The block number to state root mapping.\r\n    function timestampToBlockRoot(uint256 timestamp) external view returns (bytes32);\r\n}\r\n"},"contracts/vendors/contracts/interfaces/IDelayedWithdrawalRouter.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity >=0.5.0;\r\n\r\ninterface IDelayedWithdrawalRouter {\r\n    // struct used to pack data into a single storage slot\r\n    struct DelayedWithdrawal {\r\n        uint224 amount;\r\n        uint32 blockCreated;\r\n    }\r\n\r\n    // struct used to store a single users delayedWithdrawal data\r\n    struct UserDelayedWithdrawals {\r\n        uint256 delayedWithdrawalsCompleted;\r\n        DelayedWithdrawal[] delayedWithdrawals;\r\n    }\r\n\r\n     /// @notice event for delayedWithdrawal creation\r\n    event DelayedWithdrawalCreated(address podOwner, address recipient, uint256 amount, uint256 index);\r\n\r\n    /// @notice event for the claiming of delayedWithdrawals\r\n    event DelayedWithdrawalsClaimed(address recipient, uint256 amountClaimed, uint256 delayedWithdrawalsCompleted);\r\n\r\n    /// @notice Emitted when the `withdrawalDelayBlocks` variable is modified from `previousValue` to `newValue`.\r\n    event WithdrawalDelayBlocksSet(uint256 previousValue, uint256 newValue);\r\n\r\n    /**\r\n     * @notice Creates an delayed withdrawal for `msg.value` to the `recipient`.\r\n     * @dev Only callable by the `podOwner`'s EigenPod contract.\r\n     */\r\n    function createDelayedWithdrawal(address podOwner, address recipient) external payable;\r\n\r\n    /**\r\n     * @notice Called in order to withdraw delayed withdrawals made to the `recipient` that have passed the `withdrawalDelayBlocks` period.\r\n     * @param recipient The address to claim delayedWithdrawals for.\r\n     * @param maxNumberOfWithdrawalsToClaim Used to limit the maximum number of withdrawals to loop through claiming.\r\n     */\r\n    function claimDelayedWithdrawals(address recipient, uint256 maxNumberOfWithdrawalsToClaim) external;\r\n\r\n    /**\r\n     * @notice Called in order to withdraw delayed withdrawals made to the caller that have passed the `withdrawalDelayBlocks` period.\r\n     * @param maxNumberOfWithdrawalsToClaim Used to limit the maximum number of withdrawals to loop through claiming.\r\n     */\r\n    function claimDelayedWithdrawals(uint256 maxNumberOfWithdrawalsToClaim) external;\r\n\r\n    /// @notice Owner-only function for modifying the value of the `withdrawalDelayBlocks` variable.\r\n    function setWithdrawalDelayBlocks(uint256 newValue) external;\r\n\r\n    /// @notice Getter function for the mapping `_userWithdrawals`\r\n    function userWithdrawals(address user) external view returns (UserDelayedWithdrawals memory);\r\n\r\n    /// @notice Getter function to get all delayedWithdrawals of the `user`\r\n    function getUserDelayedWithdrawals(address user) external view returns (DelayedWithdrawal[] memory);\r\n\r\n    /// @notice Getter function to get all delayedWithdrawals that are currently claimable by the `user`\r\n    function getClaimableUserDelayedWithdrawals(address user) external view returns (DelayedWithdrawal[] memory);\r\n\r\n    /// @notice Getter function for fetching the delayedWithdrawal at the `index`th entry from the `_userWithdrawals[user].delayedWithdrawals` array\r\n    function userDelayedWithdrawalByIndex(address user, uint256 index) external view returns (DelayedWithdrawal memory);\r\n\r\n    /// @notice Getter function for fetching the length of the delayedWithdrawals array of a specific user\r\n    function userWithdrawalsLength(address user) external view returns (uint256);\r\n\r\n    /// @notice Convenience function for checking whether or not the delayedWithdrawal at the `index`th entry from the `_userWithdrawals[user].delayedWithdrawals` array is currently claimable\r\n    function canClaimDelayedWithdrawal(address user, uint256 index) external view returns (bool);\r\n\r\n    /**\r\n     * @notice Delay enforced by this contract for completing any delayedWithdrawal. Measured in blocks, and adjustable by this contract's owner,\r\n     * up to a maximum of `MAX_WITHDRAWAL_DELAY_BLOCKS`. Minimum value is 0 (i.e. no delay enforced).\r\n     */\r\n    function withdrawalDelayBlocks() external view returns (uint256);\r\n}\r\n"},"contracts/vendors/contracts/interfaces/IEigenPod.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity >=0.5.0;\r\n\r\nimport \"../libraries/BeaconChainProofs.sol\";\r\nimport \"./IEigenPodManager.sol\";\r\nimport \"./IBeaconChainOracle.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\n/**\r\n * @title The implementation contract used for restaking beacon chain ETH on EigenLayer\r\n * @author Layr Labs, Inc.\r\n * @notice Terms of Service: https://docs.eigenlayer.xyz/overview/terms-of-service\r\n * @notice The main functionalities are:\r\n * - creating new ETH validators with their withdrawal credentials pointed to this contract\r\n * - proving from beacon chain state roots that withdrawal credentials are pointed to this contract\r\n * - proving from beacon chain state roots the balances of ETH validators with their withdrawal credentials\r\n *   pointed to this contract\r\n * - updating aggregate balances in the EigenPodManager\r\n * - withdrawing eth when withdrawals are initiated\r\n * @dev Note that all beacon chain balances are stored as gwei within the beacon chain datastructures. We choose\r\n *   to account balances in terms of gwei in the EigenPod contract and convert to wei when making calls to other contracts\r\n */\r\ninterface IEigenPod {\r\n    enum VALIDATOR_STATUS {\r\n        INACTIVE, // doesnt exist\r\n        ACTIVE, // staked on ethpos and withdrawal credentials are pointed to the EigenPod\r\n        WITHDRAWN // withdrawn from the Beacon Chain\r\n    }\r\n\r\n    struct ValidatorInfo {\r\n        // index of the validator in the beacon chain\r\n        uint64 validatorIndex;\r\n        // amount of beacon chain ETH restaked on EigenLayer in gwei\r\n        uint64 restakedBalanceGwei;\r\n        //timestamp of the validator's most recent balance update\r\n        uint64 mostRecentBalanceUpdateTimestamp;\r\n        // status of the validator\r\n        VALIDATOR_STATUS status;\r\n    }\r\n\r\n    /**\r\n     * @notice struct used to store amounts related to proven withdrawals in memory. Used to help\r\n     * manage stack depth and optimize the number of external calls, when batching withdrawal operations.\r\n     */\r\n    struct VerifiedWithdrawal {\r\n        // amount to send to a podOwner from a proven withdrawal\r\n        uint256 amountToSendGwei;\r\n        // difference in shares to be recorded in the eigenPodManager, as a result of the withdrawal\r\n        int256 sharesDeltaGwei;\r\n    }\r\n\r\n\r\n    enum PARTIAL_WITHDRAWAL_CLAIM_STATUS {\r\n        REDEEMED,\r\n        PENDING,\r\n        FAILED\r\n    }\r\n\r\n    /// @notice Emitted when an ETH validator stakes via this eigenPod\r\n    event EigenPodStaked(bytes pubkey);\r\n\r\n    /// @notice Emitted when an ETH validator's withdrawal credentials are successfully verified to be pointed to this eigenPod\r\n    event ValidatorRestaked(uint40 validatorIndex);\r\n\r\n    /// @notice Emitted when an ETH validator's  balance is proven to be updated.  Here newValidatorBalanceGwei\r\n    //  is the validator's balance that is credited on EigenLayer.\r\n    event ValidatorBalanceUpdated(uint40 validatorIndex, uint64 balanceTimestamp, uint64 newValidatorBalanceGwei);\r\n\r\n    /// @notice Emitted when an ETH validator is prove to have withdrawn from the beacon chain\r\n    event FullWithdrawalRedeemed(\r\n        uint40 validatorIndex,\r\n        uint64 withdrawalTimestamp,\r\n        address indexed recipient,\r\n        uint64 withdrawalAmountGwei\r\n    );\r\n\r\n    /// @notice Emitted when a partial withdrawal claim is successfully redeemed\r\n    event PartialWithdrawalRedeemed(\r\n        uint40 validatorIndex,\r\n        uint64 withdrawalTimestamp,\r\n        address indexed recipient,\r\n        uint64 partialWithdrawalAmountGwei\r\n    );\r\n\r\n    /// @notice Emitted when restaked beacon chain ETH is withdrawn from the eigenPod.\r\n    event RestakedBeaconChainETHWithdrawn(address indexed recipient, uint256 amount);\r\n\r\n    /// @notice Emitted when podOwner enables restaking\r\n    event RestakingActivated(address indexed podOwner);\r\n\r\n    /// @notice Emitted when ETH is received via the `receive` fallback\r\n    event NonBeaconChainETHReceived(uint256 amountReceived);\r\n\r\n    /// @notice Emitted when ETH that was previously received via the `receive` fallback is withdrawn\r\n    event NonBeaconChainETHWithdrawn(address indexed recipient, uint256 amountWithdrawn);\r\n\r\n\r\n    /// @notice The max amount of eth, in gwei, that can be restaked per validator\r\n    function MAX_RESTAKED_BALANCE_GWEI_PER_VALIDATOR() external view returns (uint64);\r\n\r\n    /// @notice the amount of execution layer ETH in this contract that is staked in EigenLayer (i.e. withdrawn from beaconchain but not EigenLayer),\r\n    function withdrawableRestakedExecutionLayerGwei() external view returns (uint64);\r\n\r\n    /// @notice any ETH deposited into the EigenPod contract via the `receive` fallback function\r\n    function nonBeaconChainETHBalanceWei() external view returns (uint256);\r\n\r\n    /// @notice Used to initialize the pointers to contracts crucial to the pod's functionality, in beacon proxy construction from EigenPodManager\r\n    function initialize(address owner) external;\r\n\r\n    /// @notice Called by EigenPodManager when the owner wants to create another ETH validator.\r\n    function stake(bytes calldata pubkey, bytes calldata signature, bytes32 depositDataRoot) external payable;\r\n\r\n    /**\r\n     * @notice Transfers `amountWei` in ether from this contract to the specified `recipient` address\r\n     * @notice Called by EigenPodManager to withdrawBeaconChainETH that has been added to the EigenPod's balance due to a withdrawal from the beacon chain.\r\n     * @dev The podOwner must have already proved sufficient withdrawals, so that this pod's `withdrawableRestakedExecutionLayerGwei` exceeds the\r\n     * `amountWei` input (when converted to GWEI).\r\n     * @dev Reverts if `amountWei` is not a whole Gwei amount\r\n     */\r\n    function withdrawRestakedBeaconChainETH(address recipient, uint256 amount) external;\r\n\r\n    /// @notice The single EigenPodManager for EigenLayer\r\n    function eigenPodManager() external view returns (IEigenPodManager);\r\n\r\n    /// @notice The owner of this EigenPod\r\n    function podOwner() external view returns (address);\r\n\r\n    /// @notice an indicator of whether or not the podOwner has ever \"fully restaked\" by successfully calling `verifyCorrectWithdrawalCredentials`.\r\n    function hasRestaked() external view returns (bool);\r\n\r\n    /**\r\n     * @notice The latest timestamp at which the pod owner withdrew the balance of the pod, via calling `withdrawBeforeRestaking`.\r\n     * @dev This variable is only updated when the `withdrawBeforeRestaking` function is called, which can only occur before `hasRestaked` is set to true for this pod.\r\n     * Proofs for this pod are only valid against Beacon Chain state roots corresponding to timestamps after the stored `mostRecentWithdrawalTimestamp`.\r\n     */\r\n    function mostRecentWithdrawalTimestamp() external view returns (uint64);\r\n\r\n    /// @notice Returns the validatorInfo struct for the provided pubkeyHash\r\n    function validatorPubkeyHashToInfo(bytes32 validatorPubkeyHash) external view returns (ValidatorInfo memory);\r\n\r\n    /// @notice Returns the validatorInfo struct for the provided pubkey\r\n    function validatorPubkeyToInfo(bytes calldata validatorPubkey) external view returns (ValidatorInfo memory);\r\n\r\n    ///@notice mapping that tracks proven withdrawals\r\n    function provenWithdrawal(bytes32 validatorPubkeyHash, uint64 slot) external view returns (bool);\r\n\r\n    /// @notice This returns the status of a given validator\r\n    function validatorStatus(bytes32 pubkeyHash) external view returns (VALIDATOR_STATUS);\r\n\r\n    /// @notice This returns the status of a given validator pubkey\r\n    function validatorStatus(bytes calldata validatorPubkey) external view returns (VALIDATOR_STATUS);\r\n\r\n    /**\r\n     * @notice This function verifies that the withdrawal credentials of validator(s) owned by the podOwner are pointed to\r\n     * this contract. It also verifies the effective balance  of the validator.  It verifies the provided proof of the ETH validator against the beacon chain state\r\n     * root, marks the validator as 'active' in EigenLayer, and credits the restaked ETH in Eigenlayer.\r\n     * @param oracleTimestamp is the Beacon Chain timestamp whose state root the `proof` will be proven against.\r\n     * @param validatorIndices is the list of indices of the validators being proven, refer to consensus specs\r\n     * @param withdrawalCredentialProofs is an array of proofs, where each proof proves each ETH validator's balance and withdrawal credentials\r\n     * against a beacon chain state root\r\n     * @param validatorFields are the fields of the \"Validator Container\", refer to consensus specs\r\n     * for details: https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/beacon-chain.md#validator\r\n     */\r\n    function verifyWithdrawalCredentials(\r\n        uint64 oracleTimestamp,\r\n        BeaconChainProofs.StateRootProof calldata stateRootProof,\r\n        uint40[] calldata validatorIndices,\r\n        bytes[] calldata withdrawalCredentialProofs,\r\n        bytes32[][] calldata validatorFields\r\n    )\r\n        external;\r\n\r\n    /**\r\n     * @notice This function records an update (either increase or decrease) in the pod's balance in the StrategyManager.  \r\n               It also verifies a merkle proof of the validator's current beacon chain balance.  \r\n     * @param oracleTimestamp The oracleTimestamp whose state root the `proof` will be proven against.\r\n     *        Must be within `VERIFY_BALANCE_UPDATE_WINDOW_SECONDS` of the current block.\r\n     * @param validatorIndices is the list of indices of the validators being proven, refer to consensus specs \r\n     * @param validatorFieldsProofs proofs against the `beaconStateRoot` for each validator in `validatorFields`\r\n     * @param validatorFields are the fields of the \"Validator Container\", refer to consensus specs\r\n     * @dev For more details on the Beacon Chain spec, see: https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/beacon-chain.md#validator\r\n     */\r\n    function verifyBalanceUpdates(\r\n        uint64 oracleTimestamp,\r\n        uint40[] calldata validatorIndices,\r\n        BeaconChainProofs.StateRootProof calldata stateRootProof,\r\n        bytes[] calldata validatorFieldsProofs,\r\n        bytes32[][] calldata validatorFields\r\n    ) external;\r\n\r\n    /**\r\n     * @notice This function records full and partial withdrawals on behalf of one of the Ethereum validators for this EigenPod\r\n     * @param oracleTimestamp is the timestamp of the oracle slot that the withdrawal is being proven against\r\n     * @param withdrawalProofs is the information needed to check the veracity of the block numbers and withdrawals being proven\r\n     * @param validatorFieldsProofs is the proof of the validator's fields' in the validator tree\r\n     * @param withdrawalFields are the fields of the withdrawals being proven\r\n     * @param validatorFields are the fields of the validators being proven\r\n     */\r\n    function verifyAndProcessWithdrawals(\r\n        uint64 oracleTimestamp,\r\n        BeaconChainProofs.StateRootProof calldata stateRootProof,\r\n        BeaconChainProofs.WithdrawalProof[] calldata withdrawalProofs,\r\n        bytes[] calldata validatorFieldsProofs,\r\n        bytes32[][] calldata validatorFields,\r\n        bytes32[][] calldata withdrawalFields\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Called by the pod owner to activate restaking by withdrawing\r\n     * all existing ETH from the pod and preventing further withdrawals via\r\n     * \"withdrawBeforeRestaking()\"\r\n     */\r\n    function activateRestaking() external;\r\n\r\n    /// @notice Called by the pod owner to withdraw the balance of the pod when `hasRestaked` is set to false\r\n    function withdrawBeforeRestaking() external;\r\n\r\n    /// @notice Called by the pod owner to withdraw the nonBeaconChainETHBalanceWei\r\n    function withdrawNonBeaconChainETHBalanceWei(address recipient, uint256 amountToWithdraw) external;\r\n\r\n    /// @notice called by owner of a pod to remove any ERC20s deposited in the pod\r\n    function recoverTokens(IERC20[] memory tokenList, uint256[] memory amountsToWithdraw, address recipient) external;\r\n}\r\n"},"@openzeppelin/contracts/proxy/beacon/IBeacon.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"},"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"},"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"},"contracts/vendors/contracts/interfaces/IStrategy.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity >=0.5.0;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\n/**\r\n * @title Minimal interface for an `Strategy` contract.\r\n * @author Layr Labs, Inc.\r\n * @notice Terms of Service: https://docs.eigenlayer.xyz/overview/terms-of-service\r\n * @notice Custom `Strategy` implementations may expand extensively on this interface.\r\n */\r\ninterface IStrategy {\r\n    /**\r\n     * @notice Used to deposit tokens into this Strategy\r\n     * @param token is the ERC20 token being deposited\r\n     * @param amount is the amount of token being deposited\r\n     * @dev This function is only callable by the strategyManager contract. It is invoked inside of the strategyManager's\r\n     * `depositIntoStrategy` function, and individual share balances are recorded in the strategyManager as well.\r\n     * @return newShares is the number of new shares issued at the current exchange ratio.\r\n     */\r\n    function deposit(IERC20 token, uint256 amount) external returns (uint256);\r\n\r\n    /**\r\n     * @notice Used to withdraw tokens from this Strategy, to the `recipient`'s address\r\n     * @param recipient is the address to receive the withdrawn funds\r\n     * @param token is the ERC20 token being transferred out\r\n     * @param amountShares is the amount of shares being withdrawn\r\n     * @dev This function is only callable by the strategyManager contract. It is invoked inside of the strategyManager's\r\n     * other functions, and individual share balances are recorded in the strategyManager as well.\r\n     */\r\n    function withdraw(address recipient, IERC20 token, uint256 amountShares) external;\r\n\r\n    /**\r\n     * @notice Used to convert a number of shares to the equivalent amount of underlying tokens for this strategy.\r\n     * @notice In contrast to `sharesToUnderlyingView`, this function **may** make state modifications\r\n     * @param amountShares is the amount of shares to calculate its conversion into the underlying token\r\n     * @return The amount of underlying tokens corresponding to the input `amountShares`\r\n     * @dev Implementation for these functions in particular may vary significantly for different strategies\r\n     */\r\n    function sharesToUnderlying(uint256 amountShares) external returns (uint256);\r\n\r\n    /**\r\n     * @notice Used to convert an amount of underlying tokens to the equivalent amount of shares in this strategy.\r\n     * @notice In contrast to `underlyingToSharesView`, this function **may** make state modifications\r\n     * @param amountUnderlying is the amount of `underlyingToken` to calculate its conversion into strategy shares\r\n     * @return The amount of underlying tokens corresponding to the input `amountShares`\r\n     * @dev Implementation for these functions in particular may vary significantly for different strategies\r\n     */\r\n    function underlyingToShares(uint256 amountUnderlying) external returns (uint256);\r\n\r\n    /**\r\n     * @notice convenience function for fetching the current underlying value of all of the `user`'s shares in\r\n     * this strategy. In contrast to `userUnderlyingView`, this function **may** make state modifications\r\n     */\r\n    function userUnderlying(address user) external returns (uint256);\r\n\r\n    /**\r\n     * @notice convenience function for fetching the current total shares of `user` in this strategy, by\r\n     * querying the `strategyManager` contract\r\n     */\r\n    function shares(address user) external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Used to convert a number of shares to the equivalent amount of underlying tokens for this strategy.\r\n     * @notice In contrast to `sharesToUnderlying`, this function guarantees no state modifications\r\n     * @param amountShares is the amount of shares to calculate its conversion into the underlying token\r\n     * @return The amount of shares corresponding to the input `amountUnderlying`\r\n     * @dev Implementation for these functions in particular may vary significantly for different strategies\r\n     */\r\n    function sharesToUnderlyingView(uint256 amountShares) external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Used to convert an amount of underlying tokens to the equivalent amount of shares in this strategy.\r\n     * @notice In contrast to `underlyingToShares`, this function guarantees no state modifications\r\n     * @param amountUnderlying is the amount of `underlyingToken` to calculate its conversion into strategy shares\r\n     * @return The amount of shares corresponding to the input `amountUnderlying`\r\n     * @dev Implementation for these functions in particular may vary significantly for different strategies\r\n     */\r\n    function underlyingToSharesView(uint256 amountUnderlying) external view returns (uint256);\r\n\r\n    /**\r\n     * @notice convenience function for fetching the current underlying value of all of the `user`'s shares in\r\n     * this strategy. In contrast to `userUnderlying`, this function guarantees no state modifications\r\n     */\r\n    function userUnderlyingView(address user) external view returns (uint256);\r\n\r\n    /// @notice The underlying token for shares in this Strategy\r\n    function underlyingToken() external view returns (IERC20);\r\n\r\n    /// @notice The total number of extant shares in this Strategy\r\n    function totalShares() external view returns (uint256);\r\n\r\n    /// @notice Returns either a brief string explaining the strategy's goal & purpose, or a link to metadata that explains in more detail.\r\n    function explanation() external view returns (string memory);\r\n}\r\n"},"@prb/math/src/sd1x18/Errors.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport { SD1x18 } from \"./ValueType.sol\";\n\n/// @notice Emitted when trying to cast a SD1x18 number that doesn't fit in UD2x18.\nerror PRBMath_SD1x18_ToUD2x18_Underflow(SD1x18 x);\n\n/// @notice Emitted when trying to cast a SD1x18 number that doesn't fit in UD60x18.\nerror PRBMath_SD1x18_ToUD60x18_Underflow(SD1x18 x);\n\n/// @notice Emitted when trying to cast a SD1x18 number that doesn't fit in uint128.\nerror PRBMath_SD1x18_ToUint128_Underflow(SD1x18 x);\n\n/// @notice Emitted when trying to cast a SD1x18 number that doesn't fit in uint256.\nerror PRBMath_SD1x18_ToUint256_Underflow(SD1x18 x);\n\n/// @notice Emitted when trying to cast a SD1x18 number that doesn't fit in uint40.\nerror PRBMath_SD1x18_ToUint40_Overflow(SD1x18 x);\n\n/// @notice Emitted when trying to cast a SD1x18 number that doesn't fit in uint40.\nerror PRBMath_SD1x18_ToUint40_Underflow(SD1x18 x);\n"},"@prb/math/src/ud60x18/Errors.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport { UD60x18 } from \"./ValueType.sol\";\n\n/// @notice Emitted when ceiling a number overflows UD60x18.\nerror PRBMath_UD60x18_Ceil_Overflow(UD60x18 x);\n\n/// @notice Emitted when converting a basic integer to the fixed-point format overflows UD60x18.\nerror PRBMath_UD60x18_Convert_Overflow(uint256 x);\n\n/// @notice Emitted when taking the natural exponent of a base greater than 133.084258667509499441.\nerror PRBMath_UD60x18_Exp_InputTooBig(UD60x18 x);\n\n/// @notice Emitted when taking the binary exponent of a base greater than 192.\nerror PRBMath_UD60x18_Exp2_InputTooBig(UD60x18 x);\n\n/// @notice Emitted when taking the geometric mean of two numbers and multiplying them overflows UD60x18.\nerror PRBMath_UD60x18_Gm_Overflow(UD60x18 x, UD60x18 y);\n\n/// @notice Emitted when trying to cast an UD60x18 number that doesn't fit in SD1x18.\nerror PRBMath_UD60x18_IntoSD1x18_Overflow(UD60x18 x);\n\n/// @notice Emitted when trying to cast an UD60x18 number that doesn't fit in SD59x18.\nerror PRBMath_UD60x18_IntoSD59x18_Overflow(UD60x18 x);\n\n/// @notice Emitted when trying to cast an UD60x18 number that doesn't fit in UD2x18.\nerror PRBMath_UD60x18_IntoUD2x18_Overflow(UD60x18 x);\n\n/// @notice Emitted when trying to cast an UD60x18 number that doesn't fit in uint128.\nerror PRBMath_UD60x18_IntoUint128_Overflow(UD60x18 x);\n\n/// @notice Emitted when trying to cast an UD60x18 number that doesn't fit in uint40.\nerror PRBMath_UD60x18_IntoUint40_Overflow(UD60x18 x);\n\n/// @notice Emitted when taking the logarithm of a number less than 1.\nerror PRBMath_UD60x18_Log_InputTooSmall(UD60x18 x);\n\n/// @notice Emitted when calculating the square root overflows UD60x18.\nerror PRBMath_UD60x18_Sqrt_Overflow(UD60x18 x);\n"},"@prb/math/src/sd59x18/Math.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport { MAX_UINT128, MAX_UINT40, msb, mulDiv, mulDiv18, prbExp2, prbSqrt } from \"../Common.sol\";\nimport {\n    uHALF_UNIT,\n    uLOG2_10,\n    uLOG2_E,\n    uMAX_SD59x18,\n    uMAX_WHOLE_SD59x18,\n    uMIN_SD59x18,\n    uMIN_WHOLE_SD59x18,\n    UNIT,\n    uUNIT,\n    ZERO\n} from \"./Constants.sol\";\nimport {\n    PRBMath_SD59x18_Abs_MinSD59x18,\n    PRBMath_SD59x18_Ceil_Overflow,\n    PRBMath_SD59x18_Div_InputTooSmall,\n    PRBMath_SD59x18_Div_Overflow,\n    PRBMath_SD59x18_Exp_InputTooBig,\n    PRBMath_SD59x18_Exp2_InputTooBig,\n    PRBMath_SD59x18_Floor_Underflow,\n    PRBMath_SD59x18_Gm_Overflow,\n    PRBMath_SD59x18_Gm_NegativeProduct,\n    PRBMath_SD59x18_Log_InputTooSmall,\n    PRBMath_SD59x18_Mul_InputTooSmall,\n    PRBMath_SD59x18_Mul_Overflow,\n    PRBMath_SD59x18_Powu_Overflow,\n    PRBMath_SD59x18_Sqrt_NegativeInput,\n    PRBMath_SD59x18_Sqrt_Overflow\n} from \"./Errors.sol\";\nimport { unwrap, wrap } from \"./Helpers.sol\";\nimport { SD59x18 } from \"./ValueType.sol\";\n\n/// @notice Calculate the absolute value of x.\n///\n/// @dev Requirements:\n/// - x must be greater than `MIN_SD59x18`.\n///\n/// @param x The SD59x18 number for which to calculate the absolute value.\n/// @param result The absolute value of x as an SD59x18 number.\nfunction abs(SD59x18 x) pure returns (SD59x18 result) {\n    int256 xInt = unwrap(x);\n    if (xInt == uMIN_SD59x18) {\n        revert PRBMath_SD59x18_Abs_MinSD59x18();\n    }\n    result = xInt < 0 ? wrap(-xInt) : x;\n}\n\n/// @notice Calculates the arithmetic average of x and y, rounding towards zero.\n/// @param x The first operand as an SD59x18 number.\n/// @param y The second operand as an SD59x18 number.\n/// @return result The arithmetic average as an SD59x18 number.\nfunction avg(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\n    int256 xInt = unwrap(x);\n    int256 yInt = unwrap(y);\n\n    unchecked {\n        // This is equivalent to \"x / 2 +  y / 2\" but faster.\n        // This operation can never overflow.\n        int256 sum = (xInt >> 1) + (yInt >> 1);\n\n        if (sum < 0) {\n            // If at least one of x and y is odd, we add 1 to the result, since shifting negative numbers to the right rounds\n            // down to infinity. The right part is equivalent to \"sum + (x % 2 == 1 || y % 2 == 1)\" but faster.\n            assembly (\"memory-safe\") {\n                result := add(sum, and(or(xInt, yInt), 1))\n            }\n        } else {\n            // We need to add 1 if both x and y are odd to account for the double 0.5 remainder that is truncated after shifting.\n            result = wrap(sum + (xInt & yInt & 1));\n        }\n    }\n}\n\n/// @notice Yields the smallest whole SD59x18 number greater than or equal to x.\n///\n/// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\n/// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\n///\n/// Requirements:\n/// - x must be less than or equal to `MAX_WHOLE_SD59x18`.\n///\n/// @param x The SD59x18 number to ceil.\n/// @param result The least number greater than or equal to x, as an SD59x18 number.\nfunction ceil(SD59x18 x) pure returns (SD59x18 result) {\n    int256 xInt = unwrap(x);\n    if (xInt > uMAX_WHOLE_SD59x18) {\n        revert PRBMath_SD59x18_Ceil_Overflow(x);\n    }\n\n    int256 remainder = xInt % uUNIT;\n    if (remainder == 0) {\n        result = x;\n    } else {\n        unchecked {\n            // Solidity uses C fmod style, which returns a modulus with the same sign as x.\n            int256 resultInt = xInt - remainder;\n            if (xInt > 0) {\n                resultInt += uUNIT;\n            }\n            result = wrap(resultInt);\n        }\n    }\n}\n\n/// @notice Divides two SD59x18 numbers, returning a new SD59x18 number. Rounds towards zero.\n///\n/// @dev This is a variant of `mulDiv` that works with signed numbers. Works by computing the signs and the absolute values\n/// separately.\n///\n/// Requirements:\n/// - All from `Common.mulDiv`.\n/// - None of the inputs can be `MIN_SD59x18`.\n/// - The denominator cannot be zero.\n/// - The result must fit within int256.\n///\n/// Caveats:\n/// - All from `Common.mulDiv`.\n///\n/// @param x The numerator as an SD59x18 number.\n/// @param y The denominator as an SD59x18 number.\n/// @param result The quotient as an SD59x18 number.\nfunction div(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\n    int256 xInt = unwrap(x);\n    int256 yInt = unwrap(y);\n    if (xInt == uMIN_SD59x18 || yInt == uMIN_SD59x18) {\n        revert PRBMath_SD59x18_Div_InputTooSmall();\n    }\n\n    // Get hold of the absolute values of x and y.\n    uint256 xAbs;\n    uint256 yAbs;\n    unchecked {\n        xAbs = xInt < 0 ? uint256(-xInt) : uint256(xInt);\n        yAbs = yInt < 0 ? uint256(-yInt) : uint256(yInt);\n    }\n\n    // Compute the absolute value (x*UNIT)÷y. The resulting value must fit within int256.\n    uint256 resultAbs = mulDiv(xAbs, uint256(uUNIT), yAbs);\n    if (resultAbs > uint256(uMAX_SD59x18)) {\n        revert PRBMath_SD59x18_Div_Overflow(x, y);\n    }\n\n    // Check if x and y have the same sign. This works thanks to two's complement; the left-most bit is the sign bit.\n    bool sameSign = (xInt ^ yInt) > -1;\n\n    // If the inputs don't have the same sign, the result should be negative. Otherwise, it should be positive.\n    unchecked {\n        result = wrap(sameSign ? int256(resultAbs) : -int256(resultAbs));\n    }\n}\n\n/// @notice Calculates the natural exponent of x.\n///\n/// @dev Based on the formula:\n///\n/// $$\n/// e^x = 2^{x * log_2{e}}\n/// $$\n///\n/// Requirements:\n/// - All from `log2`.\n/// - x must be less than 133.084258667509499441.\n///\n/// Caveats:\n/// - All from `exp2`.\n/// - For any x less than -41.446531673892822322, the result is zero.\n///\n/// @param x The exponent as an SD59x18 number.\n/// @return result The result as an SD59x18 number.\nfunction exp(SD59x18 x) pure returns (SD59x18 result) {\n    int256 xInt = unwrap(x);\n    // Without this check, the value passed to `exp2` would be less than -59.794705707972522261.\n    if (xInt < -41_446531673892822322) {\n        return ZERO;\n    }\n\n    // Without this check, the value passed to `exp2` would be greater than 192.\n    if (xInt >= 133_084258667509499441) {\n        revert PRBMath_SD59x18_Exp_InputTooBig(x);\n    }\n\n    unchecked {\n        // Do the fixed-point multiplication inline to save gas.\n        int256 doubleUnitProduct = xInt * uLOG2_E;\n        result = exp2(wrap(doubleUnitProduct / uUNIT));\n    }\n}\n\n/// @notice Calculates the binary exponent of x using the binary fraction method.\n///\n/// @dev Based on the formula:\n///\n/// $$\n/// 2^{-x} = \\frac{1}{2^x}\n/// $$\n///\n/// See https://ethereum.stackexchange.com/q/79903/24693.\n///\n/// Requirements:\n/// - x must be 192 or less.\n/// - The result must fit within `MAX_SD59x18`.\n///\n/// Caveats:\n/// - For any x less than -59.794705707972522261, the result is zero.\n///\n/// @param x The exponent as an SD59x18 number.\n/// @return result The result as an SD59x18 number.\nfunction exp2(SD59x18 x) pure returns (SD59x18 result) {\n    int256 xInt = unwrap(x);\n    if (xInt < 0) {\n        // 2^59.794705707972522262 is the maximum number whose inverse does not truncate down to zero.\n        if (xInt < -59_794705707972522261) {\n            return ZERO;\n        }\n\n        unchecked {\n            // Do the fixed-point inversion $1/2^x$ inline to save gas. 1e36 is UNIT * UNIT.\n            result = wrap(1e36 / unwrap(exp2(wrap(-xInt))));\n        }\n    } else {\n        // 2^192 doesn't fit within the 192.64-bit format used internally in this function.\n        if (xInt >= 192e18) {\n            revert PRBMath_SD59x18_Exp2_InputTooBig(x);\n        }\n\n        unchecked {\n            // Convert x to the 192.64-bit fixed-point format.\n            uint256 x_192x64 = uint256((xInt << 64) / uUNIT);\n\n            // It is safe to convert the result to int256 with no checks because the maximum input allowed in this function is 192.\n            result = wrap(int256(prbExp2(x_192x64)));\n        }\n    }\n}\n\n/// @notice Yields the greatest whole SD59x18 number less than or equal to x.\n///\n/// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\n/// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\n///\n/// Requirements:\n/// - x must be greater than or equal to `MIN_WHOLE_SD59x18`.\n///\n/// @param x The SD59x18 number to floor.\n/// @param result The greatest integer less than or equal to x, as an SD59x18 number.\nfunction floor(SD59x18 x) pure returns (SD59x18 result) {\n    int256 xInt = unwrap(x);\n    if (xInt < uMIN_WHOLE_SD59x18) {\n        revert PRBMath_SD59x18_Floor_Underflow(x);\n    }\n\n    int256 remainder = xInt % uUNIT;\n    if (remainder == 0) {\n        result = x;\n    } else {\n        unchecked {\n            // Solidity uses C fmod style, which returns a modulus with the same sign as x.\n            int256 resultInt = xInt - remainder;\n            if (xInt < 0) {\n                resultInt -= uUNIT;\n            }\n            result = wrap(resultInt);\n        }\n    }\n}\n\n/// @notice Yields the excess beyond the floor of x for positive numbers and the part of the number to the right.\n/// of the radix point for negative numbers.\n/// @dev Based on the odd function definition. https://en.wikipedia.org/wiki/Fractional_part\n/// @param x The SD59x18 number to get the fractional part of.\n/// @param result The fractional part of x as an SD59x18 number.\nfunction frac(SD59x18 x) pure returns (SD59x18 result) {\n    result = wrap(unwrap(x) % uUNIT);\n}\n\n/// @notice Calculates the geometric mean of x and y, i.e. sqrt(x * y), rounding down.\n///\n/// @dev Requirements:\n/// - x * y must fit within `MAX_SD59x18`, lest it overflows.\n/// - x * y must not be negative, since this library does not handle complex numbers.\n///\n/// @param x The first operand as an SD59x18 number.\n/// @param y The second operand as an SD59x18 number.\n/// @return result The result as an SD59x18 number.\nfunction gm(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\n    int256 xInt = unwrap(x);\n    int256 yInt = unwrap(y);\n    if (xInt == 0 || yInt == 0) {\n        return ZERO;\n    }\n\n    unchecked {\n        // Equivalent to \"xy / x != y\". Checking for overflow this way is faster than letting Solidity do it.\n        int256 xyInt = xInt * yInt;\n        if (xyInt / xInt != yInt) {\n            revert PRBMath_SD59x18_Gm_Overflow(x, y);\n        }\n\n        // The product must not be negative, since this library does not handle complex numbers.\n        if (xyInt < 0) {\n            revert PRBMath_SD59x18_Gm_NegativeProduct(x, y);\n        }\n\n        // We don't need to multiply the result by `UNIT` here because the x*y product had picked up a factor of `UNIT`\n        // during multiplication. See the comments within the `prbSqrt` function.\n        uint256 resultUint = prbSqrt(uint256(xyInt));\n        result = wrap(int256(resultUint));\n    }\n}\n\n/// @notice Calculates 1 / x, rounding toward zero.\n///\n/// @dev Requirements:\n/// - x cannot be zero.\n///\n/// @param x The SD59x18 number for which to calculate the inverse.\n/// @return result The inverse as an SD59x18 number.\nfunction inv(SD59x18 x) pure returns (SD59x18 result) {\n    // 1e36 is UNIT * UNIT.\n    result = wrap(1e36 / unwrap(x));\n}\n\n/// @notice Calculates the natural logarithm of x.\n///\n/// @dev Based on the formula:\n///\n/// $$\n/// ln{x} = log_2{x} / log_2{e}$$.\n/// $$\n///\n/// Requirements:\n/// - All from `log2`.\n///\n/// Caveats:\n/// - All from `log2`.\n/// - This doesn't return exactly 1 for 2.718281828459045235, for that more fine-grained precision is needed.\n///\n/// @param x The SD59x18 number for which to calculate the natural logarithm.\n/// @return result The natural logarithm as an SD59x18 number.\nfunction ln(SD59x18 x) pure returns (SD59x18 result) {\n    // Do the fixed-point multiplication inline to save gas. This is overflow-safe because the maximum value that log2(x)\n    // can return is 195.205294292027477728.\n    result = wrap((unwrap(log2(x)) * uUNIT) / uLOG2_E);\n}\n\n/// @notice Calculates the common logarithm of x.\n///\n/// @dev First checks if x is an exact power of ten and it stops if yes. If it's not, calculates the common\n/// logarithm based on the formula:\n///\n/// $$\n/// log_{10}{x} = log_2{x} / log_2{10}\n/// $$\n///\n/// Requirements:\n/// - All from `log2`.\n///\n/// Caveats:\n/// - All from `log2`.\n///\n/// @param x The SD59x18 number for which to calculate the common logarithm.\n/// @return result The common logarithm as an SD59x18 number.\nfunction log10(SD59x18 x) pure returns (SD59x18 result) {\n    int256 xInt = unwrap(x);\n    if (xInt < 0) {\n        revert PRBMath_SD59x18_Log_InputTooSmall(x);\n    }\n\n    // Note that the `mul` in this block is the assembly mul operation, not the SD59x18 `mul`.\n    // prettier-ignore\n    assembly (\"memory-safe\") {\n        switch x\n        case 1 { result := mul(uUNIT, sub(0, 18)) }\n        case 10 { result := mul(uUNIT, sub(1, 18)) }\n        case 100 { result := mul(uUNIT, sub(2, 18)) }\n        case 1000 { result := mul(uUNIT, sub(3, 18)) }\n        case 10000 { result := mul(uUNIT, sub(4, 18)) }\n        case 100000 { result := mul(uUNIT, sub(5, 18)) }\n        case 1000000 { result := mul(uUNIT, sub(6, 18)) }\n        case 10000000 { result := mul(uUNIT, sub(7, 18)) }\n        case 100000000 { result := mul(uUNIT, sub(8, 18)) }\n        case 1000000000 { result := mul(uUNIT, sub(9, 18)) }\n        case 10000000000 { result := mul(uUNIT, sub(10, 18)) }\n        case 100000000000 { result := mul(uUNIT, sub(11, 18)) }\n        case 1000000000000 { result := mul(uUNIT, sub(12, 18)) }\n        case 10000000000000 { result := mul(uUNIT, sub(13, 18)) }\n        case 100000000000000 { result := mul(uUNIT, sub(14, 18)) }\n        case 1000000000000000 { result := mul(uUNIT, sub(15, 18)) }\n        case 10000000000000000 { result := mul(uUNIT, sub(16, 18)) }\n        case 100000000000000000 { result := mul(uUNIT, sub(17, 18)) }\n        case 1000000000000000000 { result := 0 }\n        case 10000000000000000000 { result := uUNIT }\n        case 100000000000000000000 { result := mul(uUNIT, 2) }\n        case 1000000000000000000000 { result := mul(uUNIT, 3) }\n        case 10000000000000000000000 { result := mul(uUNIT, 4) }\n        case 100000000000000000000000 { result := mul(uUNIT, 5) }\n        case 1000000000000000000000000 { result := mul(uUNIT, 6) }\n        case 10000000000000000000000000 { result := mul(uUNIT, 7) }\n        case 100000000000000000000000000 { result := mul(uUNIT, 8) }\n        case 1000000000000000000000000000 { result := mul(uUNIT, 9) }\n        case 10000000000000000000000000000 { result := mul(uUNIT, 10) }\n        case 100000000000000000000000000000 { result := mul(uUNIT, 11) }\n        case 1000000000000000000000000000000 { result := mul(uUNIT, 12) }\n        case 10000000000000000000000000000000 { result := mul(uUNIT, 13) }\n        case 100000000000000000000000000000000 { result := mul(uUNIT, 14) }\n        case 1000000000000000000000000000000000 { result := mul(uUNIT, 15) }\n        case 10000000000000000000000000000000000 { result := mul(uUNIT, 16) }\n        case 100000000000000000000000000000000000 { result := mul(uUNIT, 17) }\n        case 1000000000000000000000000000000000000 { result := mul(uUNIT, 18) }\n        case 10000000000000000000000000000000000000 { result := mul(uUNIT, 19) }\n        case 100000000000000000000000000000000000000 { result := mul(uUNIT, 20) }\n        case 1000000000000000000000000000000000000000 { result := mul(uUNIT, 21) }\n        case 10000000000000000000000000000000000000000 { result := mul(uUNIT, 22) }\n        case 100000000000000000000000000000000000000000 { result := mul(uUNIT, 23) }\n        case 1000000000000000000000000000000000000000000 { result := mul(uUNIT, 24) }\n        case 10000000000000000000000000000000000000000000 { result := mul(uUNIT, 25) }\n        case 100000000000000000000000000000000000000000000 { result := mul(uUNIT, 26) }\n        case 1000000000000000000000000000000000000000000000 { result := mul(uUNIT, 27) }\n        case 10000000000000000000000000000000000000000000000 { result := mul(uUNIT, 28) }\n        case 100000000000000000000000000000000000000000000000 { result := mul(uUNIT, 29) }\n        case 1000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 30) }\n        case 10000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 31) }\n        case 100000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 32) }\n        case 1000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 33) }\n        case 10000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 34) }\n        case 100000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 35) }\n        case 1000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 36) }\n        case 10000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 37) }\n        case 100000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 38) }\n        case 1000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 39) }\n        case 10000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 40) }\n        case 100000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 41) }\n        case 1000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 42) }\n        case 10000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 43) }\n        case 100000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 44) }\n        case 1000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 45) }\n        case 10000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 46) }\n        case 100000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 47) }\n        case 1000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 48) }\n        case 10000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 49) }\n        case 100000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 50) }\n        case 1000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 51) }\n        case 10000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 52) }\n        case 100000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 53) }\n        case 1000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 54) }\n        case 10000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 55) }\n        case 100000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 56) }\n        case 1000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 57) }\n        case 10000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 58) }\n        default {\n            result := uMAX_SD59x18\n        }\n    }\n\n    if (unwrap(result) == uMAX_SD59x18) {\n        unchecked {\n            // Do the fixed-point division inline to save gas.\n            result = wrap((unwrap(log2(x)) * uUNIT) / uLOG2_10);\n        }\n    }\n}\n\n/// @notice Calculates the binary logarithm of x.\n///\n/// @dev Based on the iterative approximation algorithm.\n/// https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation\n///\n/// Requirements:\n/// - x must be greater than zero.\n///\n/// Caveats:\n/// - The results are not perfectly accurate to the last decimal, due to the lossy precision of the iterative approximation.\n///\n/// @param x The SD59x18 number for which to calculate the binary logarithm.\n/// @return result The binary logarithm as an SD59x18 number.\nfunction log2(SD59x18 x) pure returns (SD59x18 result) {\n    int256 xInt = unwrap(x);\n    if (xInt <= 0) {\n        revert PRBMath_SD59x18_Log_InputTooSmall(x);\n    }\n\n    unchecked {\n        // This works because of:\n        //\n        // $$\n        // log_2{x} = -log_2{\\frac{1}{x}}\n        // $$\n        int256 sign;\n        if (xInt >= uUNIT) {\n            sign = 1;\n        } else {\n            sign = -1;\n            // Do the fixed-point inversion inline to save gas. The numerator is UNIT * UNIT.\n            xInt = 1e36 / xInt;\n        }\n\n        // Calculate the integer part of the logarithm and add it to the result and finally calculate $y = x * 2^(-n)$.\n        uint256 n = msb(uint256(xInt / uUNIT));\n\n        // This is the integer part of the logarithm as an SD59x18 number. The operation can't overflow\n        // because n is maximum 255, UNIT is 1e18 and sign is either 1 or -1.\n        int256 resultInt = int256(n) * uUNIT;\n\n        // This is $y = x * 2^{-n}$.\n        int256 y = xInt >> n;\n\n        // If y is 1, the fractional part is zero.\n        if (y == uUNIT) {\n            return wrap(resultInt * sign);\n        }\n\n        // Calculate the fractional part via the iterative approximation.\n        // The \"delta >>= 1\" part is equivalent to \"delta /= 2\", but shifting bits is faster.\n        int256 DOUBLE_UNIT = 2e18;\n        for (int256 delta = uHALF_UNIT; delta > 0; delta >>= 1) {\n            y = (y * y) / uUNIT;\n\n            // Is $y^2 > 2$ and so in the range [2,4)?\n            if (y >= DOUBLE_UNIT) {\n                // Add the 2^{-m} factor to the logarithm.\n                resultInt = resultInt + delta;\n\n                // Corresponds to z/2 on Wikipedia.\n                y >>= 1;\n            }\n        }\n        resultInt *= sign;\n        result = wrap(resultInt);\n    }\n}\n\n/// @notice Multiplies two SD59x18 numbers together, returning a new SD59x18 number.\n///\n/// @dev This is a variant of `mulDiv` that works with signed numbers and employs constant folding, i.e. the denominator\n/// is always 1e18.\n///\n/// Requirements:\n/// - All from `Common.mulDiv18`.\n/// - None of the inputs can be `MIN_SD59x18`.\n/// - The result must fit within `MAX_SD59x18`.\n///\n/// Caveats:\n/// - To understand how this works in detail, see the NatSpec comments in `Common.mulDivSigned`.\n///\n/// @param x The multiplicand as an SD59x18 number.\n/// @param y The multiplier as an SD59x18 number.\n/// @return result The product as an SD59x18 number.\nfunction mul(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\n    int256 xInt = unwrap(x);\n    int256 yInt = unwrap(y);\n    if (xInt == uMIN_SD59x18 || yInt == uMIN_SD59x18) {\n        revert PRBMath_SD59x18_Mul_InputTooSmall();\n    }\n\n    // Get hold of the absolute values of x and y.\n    uint256 xAbs;\n    uint256 yAbs;\n    unchecked {\n        xAbs = xInt < 0 ? uint256(-xInt) : uint256(xInt);\n        yAbs = yInt < 0 ? uint256(-yInt) : uint256(yInt);\n    }\n\n    uint256 resultAbs = mulDiv18(xAbs, yAbs);\n    if (resultAbs > uint256(uMAX_SD59x18)) {\n        revert PRBMath_SD59x18_Mul_Overflow(x, y);\n    }\n\n    // Check if x and y have the same sign. This works thanks to two's complement; the left-most bit is the sign bit.\n    bool sameSign = (xInt ^ yInt) > -1;\n\n    // If the inputs have the same sign, the result should be negative. Otherwise, it should be positive.\n    unchecked {\n        result = wrap(sameSign ? int256(resultAbs) : -int256(resultAbs));\n    }\n}\n\n/// @notice Raises x to the power of y.\n///\n/// @dev Based on the formula:\n///\n/// $$\n/// x^y = 2^{log_2{x} * y}\n/// $$\n///\n/// Requirements:\n/// - All from `exp2`, `log2` and `mul`.\n/// - x cannot be zero.\n///\n/// Caveats:\n/// - All from `exp2`, `log2` and `mul`.\n/// - Assumes 0^0 is 1.\n///\n/// @param x Number to raise to given power y, as an SD59x18 number.\n/// @param y Exponent to raise x to, as an SD59x18 number\n/// @return result x raised to power y, as an SD59x18 number.\nfunction pow(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\n    int256 xInt = unwrap(x);\n    int256 yInt = unwrap(y);\n\n    if (xInt == 0) {\n        result = yInt == 0 ? UNIT : ZERO;\n    } else {\n        if (yInt == uUNIT) {\n            result = x;\n        } else {\n            result = exp2(mul(log2(x), y));\n        }\n    }\n}\n\n/// @notice Raises x (an SD59x18 number) to the power y (unsigned basic integer) using the famous algorithm\n/// algorithm \"exponentiation by squaring\".\n///\n/// @dev See https://en.wikipedia.org/wiki/Exponentiation_by_squaring\n///\n/// Requirements:\n/// - All from `abs` and `Common.mulDiv18`.\n/// - The result must fit within `MAX_SD59x18`.\n///\n/// Caveats:\n/// - All from `Common.mulDiv18`.\n/// - Assumes 0^0 is 1.\n///\n/// @param x The base as an SD59x18 number.\n/// @param y The exponent as an uint256.\n/// @return result The result as an SD59x18 number.\nfunction powu(SD59x18 x, uint256 y) pure returns (SD59x18 result) {\n    uint256 xAbs = uint256(unwrap(abs(x)));\n\n    // Calculate the first iteration of the loop in advance.\n    uint256 resultAbs = y & 1 > 0 ? xAbs : uint256(uUNIT);\n\n    // Equivalent to \"for(y /= 2; y > 0; y /= 2)\" but faster.\n    uint256 yAux = y;\n    for (yAux >>= 1; yAux > 0; yAux >>= 1) {\n        xAbs = mulDiv18(xAbs, xAbs);\n\n        // Equivalent to \"y % 2 == 1\" but faster.\n        if (yAux & 1 > 0) {\n            resultAbs = mulDiv18(resultAbs, xAbs);\n        }\n    }\n\n    // The result must fit within `MAX_SD59x18`.\n    if (resultAbs > uint256(uMAX_SD59x18)) {\n        revert PRBMath_SD59x18_Powu_Overflow(x, y);\n    }\n\n    unchecked {\n        // Is the base negative and the exponent an odd number?\n        int256 resultInt = int256(resultAbs);\n        bool isNegative = unwrap(x) < 0 && y & 1 == 1;\n        if (isNegative) {\n            resultInt = -resultInt;\n        }\n        result = wrap(resultInt);\n    }\n}\n\n/// @notice Calculates the square root of x, rounding down. Only the positive root is returned.\n/// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\n///\n/// Requirements:\n/// - x cannot be negative, since this library does not handle complex numbers.\n/// - x must be less than `MAX_SD59x18` divided by `UNIT`.\n///\n/// @param x The SD59x18 number for which to calculate the square root.\n/// @return result The result as an SD59x18 number.\nfunction sqrt(SD59x18 x) pure returns (SD59x18 result) {\n    int256 xInt = unwrap(x);\n    if (xInt < 0) {\n        revert PRBMath_SD59x18_Sqrt_NegativeInput(x);\n    }\n    if (xInt > uMAX_SD59x18 / uUNIT) {\n        revert PRBMath_SD59x18_Sqrt_Overflow(x);\n    }\n\n    unchecked {\n        // Multiply x by `UNIT` to account for the factor of `UNIT` that is picked up when multiplying two SD59x18\n        // numbers together (in this case, the two numbers are both the square root).\n        uint256 resultUint = prbSqrt(uint256(xInt * uUNIT));\n        result = wrap(int256(resultUint));\n    }\n}\n"},"@prb/math/src/sd59x18/Constants.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport { SD59x18 } from \"./ValueType.sol\";\n\n/// NOTICE: the \"u\" prefix stands for \"unwrapped\".\n\n/// @dev Euler's number as an SD59x18 number.\nSD59x18 constant E = SD59x18.wrap(2_718281828459045235);\n\n/// @dev Half the UNIT number.\nint256 constant uHALF_UNIT = 0.5e18;\nSD59x18 constant HALF_UNIT = SD59x18.wrap(uHALF_UNIT);\n\n/// @dev log2(10) as an SD59x18 number.\nint256 constant uLOG2_10 = 3_321928094887362347;\nSD59x18 constant LOG2_10 = SD59x18.wrap(uLOG2_10);\n\n/// @dev log2(e) as an SD59x18 number.\nint256 constant uLOG2_E = 1_442695040888963407;\nSD59x18 constant LOG2_E = SD59x18.wrap(uLOG2_E);\n\n/// @dev The maximum value an SD59x18 number can have.\nint256 constant uMAX_SD59x18 = 57896044618658097711785492504343953926634992332820282019728_792003956564819967;\nSD59x18 constant MAX_SD59x18 = SD59x18.wrap(uMAX_SD59x18);\n\n/// @dev The maximum whole value an SD59x18 number can have.\nint256 constant uMAX_WHOLE_SD59x18 = 57896044618658097711785492504343953926634992332820282019728_000000000000000000;\nSD59x18 constant MAX_WHOLE_SD59x18 = SD59x18.wrap(uMAX_WHOLE_SD59x18);\n\n/// @dev The minimum value an SD59x18 number can have.\nint256 constant uMIN_SD59x18 = -57896044618658097711785492504343953926634992332820282019728_792003956564819968;\nSD59x18 constant MIN_SD59x18 = SD59x18.wrap(uMIN_SD59x18);\n\n/// @dev The minimum whole value an SD59x18 number can have.\nint256 constant uMIN_WHOLE_SD59x18 = -57896044618658097711785492504343953926634992332820282019728_000000000000000000;\nSD59x18 constant MIN_WHOLE_SD59x18 = SD59x18.wrap(uMIN_WHOLE_SD59x18);\n\n/// @dev PI as an SD59x18 number.\nSD59x18 constant PI = SD59x18.wrap(3_141592653589793238);\n\n/// @dev The unit amount that implies how many trailing decimals can be represented.\nint256 constant uUNIT = 1e18;\nSD59x18 constant UNIT = SD59x18.wrap(1e18);\n\n/// @dev Zero as an SD59x18 number.\nSD59x18 constant ZERO = SD59x18.wrap(0);\n"},"@prb/math/src/ud2x18/Errors.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport { UD2x18 } from \"./ValueType.sol\";\n\n/// @notice Emitted when trying to cast a UD2x18 number that doesn't fit in SD1x18.\nerror PRBMath_UD2x18_IntoSD1x18_Overflow(UD2x18 x);\n\n/// @notice Emitted when trying to cast a UD2x18 number that doesn't fit in uint40.\nerror PRBMath_UD2x18_IntoUint40_Overflow(UD2x18 x);\n"},"contracts/interfaces/IrswETH.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.16;\r\n\r\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\r\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\n/**\r\n * @title RswETH Interface\r\n * @dev This interface provides the methods to interact with the RswETH contract.\r\n */\r\ninterface IrswETH is IERC20Upgradeable {\r\n  // ***** Errors ******\r\n\r\n  /**\r\n   * @dev Error thrown when attempting to reprice with zero RswETH supply.\r\n   */\r\n  error CannotRepriceWithZeroRswETHSupply();\r\n\r\n  /**\r\n   * @dev Error thrown when passing a preRewardETHReserves value equal to 0 into the repricing function\r\n   */\r\n  error InvalidPreRewardETHReserves();\r\n\r\n  /**\r\n   * @dev Error thrown when updating the reward percentage for either the NOs or the swell treasury and the update will cause the NO percentage + swell treasury percentage to exceed 100%.\r\n   */\r\n  error RewardPercentageTotalOverflow();\r\n\r\n  /**\r\n   * @dev Thrown when calling the reprice function and not enough time has elapsed between the previous repriace and the current reprice.\r\n   * @param remainingTime Remaining time until reprice can be called\r\n   */\r\n  error NotEnoughTimeElapsedForReprice(uint256 remainingTime);\r\n\r\n  /**\r\n   * @dev Thrown when repricing the rate and the difference in reserves values is greater than expected\r\n   * @param repriceDiff The difference between the previous rswETH rate and what would be the updated rate\r\n   * @param maximumRepriceDiff The maximum allowed difference in rswETH rate\r\n   */\r\n  error RepriceDifferenceTooLarge(\r\n    uint256 repriceDiff,\r\n    uint256 maximumRepriceDiff\r\n  );\r\n\r\n  /**\r\n   * @dev Thrown during repricing when the difference in rswETH supplied to repricing compared to the actual supply is too great\r\n   * @param repriceRswETHDiff The difference between the rswETH supplied to repricing and actual supply\r\n   * @param maximumRswETHRepriceDiff The maximum allowed difference in rswETH supply\r\n   */\r\n  error RepriceRswETHDifferenceTooLarge(\r\n    uint256 repriceRswETHDiff,\r\n    uint256 maximumRswETHRepriceDiff\r\n  );\r\n\r\n  /**\r\n   * @dev Throw when the caller tries to burn 0 rswETH\r\n   */\r\n  error CannotBurnZeroRswETH();\r\n\r\n  /**\r\n   * @dev Error thrown when attempting to call a method that is only callable by the DepositManager contract.\r\n   */\r\n  error OnlyDepositManager();\r\n\r\n  /**\r\n   * @dev Error thrown when the amount of rswETH received in exchange for ETH is less than the minimum amount specified.\r\n   * @dev This can occur during depositViaDepositManager, as the flow must account for slippage.\r\n   * @param rswETHAmount The amount of rswETH resulting from the exchange rate conversion\r\n   * @param minRswETH The minimum amount of rswETH required\r\n   */\r\n  error InsufficientRswETHReceived(\r\n    uint256 rswETHAmount,\r\n    uint256 minRswETH\r\n  );\r\n\r\n  // ***** Events *****\r\n\r\n  /**\r\n   * @dev Event emitted when a user withdraws ETH for swETH\r\n   * @param to Address of the recipient.\r\n   * @param rswETHBurned Amount of RswETH burned in the transaction.\r\n   * @param ethReturned Amount of ETH returned in the transaction.\r\n   */\r\n  event ETHWithdrawn(\r\n    address indexed to,\r\n    uint256 rswETHBurned,\r\n    uint256 ethReturned\r\n  );\r\n\r\n  /**\r\n   * @dev Event emitted when the swell treasury reward percentage is updated.\r\n   * @dev Only callable by the platform admin\r\n   * @param oldPercentage The previous swell treasury reward percentage.\r\n   * @param newPercentage The new swell treasury reward percentage.\r\n   */\r\n  event SwellTreasuryRewardPercentageUpdate(\r\n    uint256 oldPercentage,\r\n    uint256 newPercentage\r\n  );\r\n\r\n  /**\r\n   * @dev Event emitted when the node operator reward percentage is updated.\r\n   * @dev Only callable by the platform admin\r\n   * @param oldPercentage The previous node operator reward percentage.\r\n   * @param newPercentage The new node operator reward percentage.\r\n   */\r\n  event NodeOperatorRewardPercentageUpdate(\r\n    uint256 oldPercentage,\r\n    uint256 newPercentage\r\n  );\r\n\r\n  /**\r\n   * @dev Event emitted when the rswETH - ETH rate is updated\r\n   * @param newEthReserves The new ETH reserves for the swell protocol\r\n   * @param newRswETHToETHRate The new RswETH to ETH rate.\r\n   * @param nodeOperatorRewards The rewards for the node operator's.\r\n   * @param swellTreasuryRewards The rewards for the swell treasury.\r\n   * @param totalETHDeposited Current total ETH staked at time of reprice.\r\n   */\r\n  event Reprice(\r\n    uint256 newEthReserves,\r\n    uint256 newRswETHToETHRate,\r\n    uint256 nodeOperatorRewards,\r\n    uint256 swellTreasuryRewards,\r\n    uint256 totalETHDeposited\r\n  );\r\n\r\n  /**\r\n   * @dev Event is fired when some contracts receive ETH\r\n   * @param from The account that sent the ETH\r\n   * @param rswETHMinted The amount of rswETH minted to the caller\r\n   * @param amount The amount of ETH received\r\n   * @param referral The referrer's address\r\n   */\r\n  event ETHDepositReceived(\r\n    address indexed from,\r\n    uint256 amount,\r\n    uint256 rswETHMinted,\r\n    uint256 newTotalETHDeposited,\r\n    address indexed referral\r\n  );\r\n\r\n  /**\r\n   * @dev Event emitted on a successful call to setMinimumRepriceTime\r\n   * @param _oldMinimumRepriceTime The old reprice time\r\n   * @param _newMinimumRepriceTime The new updated reprice time\r\n   */\r\n  event MinimumRepriceTimeUpdated(\r\n    uint256 _oldMinimumRepriceTime,\r\n    uint256 _newMinimumRepriceTime\r\n  );\r\n\r\n  /**\r\n   * @dev Event emitted on a successful call to setMaximumRepriceRswETHDifferencePercentage\r\n   * @param _oldMaximumRepriceRswETHDifferencePercentage The old maximum rswETH supply difference\r\n   * @param _newMaximumRepriceRswETHDifferencePercentage The new updated rswETH supply difference\r\n   */\r\n  event MaximumRepriceRswETHDifferencePercentageUpdated(\r\n    uint256 _oldMaximumRepriceRswETHDifferencePercentage,\r\n    uint256 _newMaximumRepriceRswETHDifferencePercentage\r\n  );\r\n\r\n  /**\r\n   * @dev Event emitted on a successful call to setMaximumRepriceDifferencePercentage\r\n   * @param _oldMaximumRepriceDifferencePercentage The old maximum reprice difference\r\n   * @param _newMaximumRepriceDifferencePercentage The new updated maximum reprice difference\r\n   */\r\n  event MaximumRepriceDifferencePercentageUpdated(\r\n    uint256 _oldMaximumRepriceDifferencePercentage,\r\n    uint256 _newMaximumRepriceDifferencePercentage\r\n  );\r\n\r\n  /**\r\n   * @dev Event emitted on successful call from the DepositManager to mint rswETH to a LST depositor\r\n   * @param _receiver The person receiving the rswETH. Should be the same person who deposited their LST's in the DepositManager\r\n   * @param _ethSpent The amount of ETH their LST's were worth at the time of deposit. Used to mint rswETH.\r\n   * @param _rswETHReceived The amount of rswETH received by the user\r\n   */\r\n  event DepoistManagerDeposit(\r\n    address _receiver,\r\n    uint256 _ethSpent,\r\n    uint256 _rswETHReceived\r\n  );\r\n\r\n  // ************************************\r\n  // ***** External Methods ******\r\n\r\n  /**\r\n   * @dev This method withdraws contract's _token balance to a platform admin\r\n   * @param _token The ERC20 token to withdraw from the contract\r\n   */\r\n  function withdrawERC20(IERC20 _token) external;\r\n\r\n  /**\r\n   * @dev Returns the ETH reserves that were provided in the most recent call to the reprice function\r\n   * @return The last recorded ETH reserves\r\n   */\r\n  function lastRepriceETHReserves() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the last time the reprice method was called in UNIX\r\n   * @return The UNIX timestamp of the last time reprice was called\r\n   */\r\n  function lastRepriceUNIX() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the total ETH that has been deposited over the protocols lifespan\r\n   * @return The current total amount of ETH that has been deposited\r\n   */\r\n  function totalETHDeposited() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the current swell treasury reward percentage.\r\n   * @return The current swell treasury reward percentage.\r\n   */\r\n  function swellTreasuryRewardPercentage() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the current node operator reward percentage.\r\n   * @return The current node operator reward percentage.\r\n   */\r\n  function nodeOperatorRewardPercentage() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the current RswETH to ETH rate, returns 1:1 if no reprice has occurred otherwise it returns the rswETHToETHRateFixed rate.\r\n   * @return The current RswETH to ETH rate.\r\n   */\r\n  function rswETHToETHRate() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the current ETH to RswETH rate.\r\n   * @return The current ETH to RswETH rate.\r\n   */\r\n  function ethToRswETHRate() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the minimum reprice time\r\n   * @return The minimum reprice time\r\n   */\r\n  function minimumRepriceTime() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the maximum percentage difference with 1e18 precision\r\n   * @return The maximum percentage difference\r\n   */\r\n  function maximumRepriceDifferencePercentage() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the maximum percentage difference with 1e18 precision\r\n   * @return The maximum percentage difference in suppled and actual swETH supply\r\n   */\r\n  function maximumRepriceRswETHDifferencePercentage()\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  /**\r\n   * @dev Sets the new swell treasury reward percentage.\r\n   * @notice Only a platform admin can call this function.\r\n   * @param _newSwellTreasuryRewardPercentage The new swell treasury reward percentage to set.\r\n   */\r\n  function setSwellTreasuryRewardPercentage(\r\n    uint256 _newSwellTreasuryRewardPercentage\r\n  ) external;\r\n\r\n  /**\r\n   * @dev Sets the new node operator reward percentage.\r\n   * @notice Only a platform admin can call this function.\r\n   * @param _newNodeOperatorRewardPercentage The new node operator reward percentage to set.\r\n   */\r\n  function setNodeOperatorRewardPercentage(\r\n    uint256 _newNodeOperatorRewardPercentage\r\n  ) external;\r\n\r\n  /**\r\n   * @dev Sets the minimum permitted time between successful repricing calls using the block timestamp.\r\n   * @notice Only a platform admin can call this function.\r\n   * @param _minimumRepriceTime The new minimum time between successful repricing calls\r\n   */\r\n  function setMinimumRepriceTime(uint256 _minimumRepriceTime) external;\r\n\r\n  /**\r\n   * @dev Sets the maximum percentage allowable difference in rswETH supplied to repricing compared to current rswETH supply.\r\n   * @notice Only a platform admin can call this function.\r\n   * @param _maximumRepriceRswETHDifferencePercentage The new maximum percentage rswETH supply difference allowed.\r\n   */\r\n  function setMaximumRepriceRswETHDifferencePercentage(\r\n    uint256 _maximumRepriceRswETHDifferencePercentage\r\n  ) external;\r\n\r\n  /**\r\n   * @dev Sets the maximum percentage allowable difference in swETH to ETH price changes for a repricing call.\r\n   * @notice Only a platform admin can call this function.\r\n   * @param _maximumRepriceDifferencePercentage The new maximum percentage difference in repricing rate.\r\n   */\r\n  function setMaximumRepriceDifferencePercentage(\r\n    uint256 _maximumRepriceDifferencePercentage\r\n  ) external;\r\n\r\n  /**\r\n   * @dev Deposits ETH into the contract\r\n   * @notice The amount of ETH deposited will be converted to RswETH at the current RswETH to ETH rate\r\n   */\r\n  function deposit() external payable;\r\n\r\n  /**\r\n   * @dev Deposits ETH into the contract\r\n   * @param referral The referrer's address\r\n   * @notice The amount of ETH deposited will be converted to RswETH at the current RswETH to ETH rate\r\n   */\r\n  function depositWithReferral(address referral) external payable;\r\n\r\n  /**\r\n   * @dev Called when a user deposits a LST into the deposit manager.\r\n   * @param _amount The amount of ETH to mint rswETH for.\r\n   * @param _to The address to mint rswETH for.\r\n   * @param _minRsweTH The minimum amount of rswETH to mint.\r\n   * @notice Calculates the current LST -> ETH exhange rate and mints the equivalent amount of rswETH to the depositor.\r\n   * @notice Does not actually deposit ETH into the DepositManager.\r\n   */\r\n  function depositViaDepositManager(\r\n    uint256 _amount,\r\n    address _to,\r\n    uint256 _minRsweTH\r\n  ) external;\r\n\r\n  /**\r\n   * @dev Burns the requested amount of rswETH, it does not return any ETH to the caller\r\n   * @param amount The amount of rswETH to burn\r\n   */\r\n  function burn(uint256 amount) external;\r\n\r\n  /**\r\n   * @dev This method reprices the rswETH -> ETH rate, this will be called via an offchain service on a regular interval, likely ~1 day. The rswETH total supply is passed as an argument to avoid a potential race conditions between the off-chain reserve calculations and the on-chain repricing\r\n   * @dev This method also mints a percentage of rswETH as rewards to be claimed by NO's and the swell treasury. The formula for determining the amount of rswETH to mint is the following: rswETHToMint = (rswETHSupply * newETHRewards * feeRate) / (preRewardETHReserves - newETHRewards * feeRate + newETHRewards)\r\n   * @dev The formula is quite complicated because it needs to factor in the updated exchange rate whilst it calculates the amount of rswETH rewards to mint. This ensures the rewards aren't double-minted and are backed by ETH.\r\n   * @param _preRewardETHReserves The PoR value exclusive of the new ETH rewards earned\r\n   * @param _newETHRewards The total amount of new ETH earnt over the period.\r\n   * @param _rswETHTotalSupply The total rswETH supply at the time of off-chain reprice calculation\r\n   */\r\n  function reprice(\r\n    uint256 _preRewardETHReserves,\r\n    uint256 _newETHRewards,\r\n    uint256 _rswETHTotalSupply\r\n  ) external;\r\n}\r\n"},"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSetUpgradeable {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"},"contracts/vendors/contracts/interfaces/ISignatureUtils.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity >=0.5.0;\r\n\r\n/**\r\n * @title The interface for common signature utilities.\r\n * @author Layr Labs, Inc.\r\n * @notice Terms of Service: https://docs.eigenlayer.xyz/overview/terms-of-service\r\n */\r\ninterface ISignatureUtils {\r\n    // @notice Struct that bundles together a signature and an expiration time for the signature. Used primarily for stack management.\r\n    struct SignatureWithExpiry {\r\n        // the signature itself, formatted as a single bytes object\r\n        bytes signature;\r\n        // the expiration timestamp (UTC) of the signature\r\n        uint256 expiry;\r\n    }\r\n\r\n    // @notice Struct that bundles together a signature, a salt for uniqueness, and an expiration time for the signature. Used primarily for stack management.\r\n    struct SignatureWithSaltAndExpiry {\r\n        // the signature itself, formatted as a single bytes object\r\n        bytes signature;\r\n        // the salt used to generate the signature\r\n        bytes32 salt;\r\n        // the expiration timestamp (UTC) of the signature\r\n        uint256 expiry;\r\n    }\r\n}"},"@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControlUpgradeable {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"},"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"},"@prb/math/src/sd59x18/Errors.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport { SD59x18 } from \"./ValueType.sol\";\n\n/// @notice Emitted when taking the absolute value of `MIN_SD59x18`.\nerror PRBMath_SD59x18_Abs_MinSD59x18();\n\n/// @notice Emitted when ceiling a number overflows SD59x18.\nerror PRBMath_SD59x18_Ceil_Overflow(SD59x18 x);\n\n/// @notice Emitted when converting a basic integer to the fixed-point format overflows SD59x18.\nerror PRBMath_SD59x18_Convert_Overflow(int256 x);\n\n/// @notice Emitted when converting a basic integer to the fixed-point format underflows SD59x18.\nerror PRBMath_SD59x18_Convert_Underflow(int256 x);\n\n/// @notice Emitted when dividing two numbers and one of them is `MIN_SD59x18`.\nerror PRBMath_SD59x18_Div_InputTooSmall();\n\n/// @notice Emitted when dividing two numbers and one of the intermediary unsigned results overflows SD59x18.\nerror PRBMath_SD59x18_Div_Overflow(SD59x18 x, SD59x18 y);\n\n/// @notice Emitted when taking the natural exponent of a base greater than 133.084258667509499441.\nerror PRBMath_SD59x18_Exp_InputTooBig(SD59x18 x);\n\n/// @notice Emitted when taking the binary exponent of a base greater than 192.\nerror PRBMath_SD59x18_Exp2_InputTooBig(SD59x18 x);\n\n/// @notice Emitted when flooring a number underflows SD59x18.\nerror PRBMath_SD59x18_Floor_Underflow(SD59x18 x);\n\n/// @notice Emitted when taking the geometric mean of two numbers and their product is negative.\nerror PRBMath_SD59x18_Gm_NegativeProduct(SD59x18 x, SD59x18 y);\n\n/// @notice Emitted when taking the geometric mean of two numbers and multiplying them overflows SD59x18.\nerror PRBMath_SD59x18_Gm_Overflow(SD59x18 x, SD59x18 y);\n\n/// @notice Emitted when trying to cast an UD60x18 number that doesn't fit in SD1x18.\nerror PRBMath_SD59x18_IntoSD1x18_Overflow(SD59x18 x);\n\n/// @notice Emitted when trying to cast an UD60x18 number that doesn't fit in SD1x18.\nerror PRBMath_SD59x18_IntoSD1x18_Underflow(SD59x18 x);\n\n/// @notice Emitted when trying to cast an UD60x18 number that doesn't fit in UD2x18.\nerror PRBMath_SD59x18_IntoUD2x18_Overflow(SD59x18 x);\n\n/// @notice Emitted when trying to cast an UD60x18 number that doesn't fit in UD2x18.\nerror PRBMath_SD59x18_IntoUD2x18_Underflow(SD59x18 x);\n\n/// @notice Emitted when trying to cast an UD60x18 number that doesn't fit in UD60x18.\nerror PRBMath_SD59x18_IntoUD60x18_Underflow(SD59x18 x);\n\n/// @notice Emitted when trying to cast an UD60x18 number that doesn't fit in uint128.\nerror PRBMath_SD59x18_IntoUint128_Overflow(SD59x18 x);\n\n/// @notice Emitted when trying to cast an UD60x18 number that doesn't fit in uint128.\nerror PRBMath_SD59x18_IntoUint128_Underflow(SD59x18 x);\n\n/// @notice Emitted when trying to cast an UD60x18 number that doesn't fit in uint256.\nerror PRBMath_SD59x18_IntoUint256_Underflow(SD59x18 x);\n\n/// @notice Emitted when trying to cast an UD60x18 number that doesn't fit in uint40.\nerror PRBMath_SD59x18_IntoUint40_Overflow(SD59x18 x);\n\n/// @notice Emitted when trying to cast an UD60x18 number that doesn't fit in uint40.\nerror PRBMath_SD59x18_IntoUint40_Underflow(SD59x18 x);\n\n/// @notice Emitted when taking the logarithm of a number less than or equal to zero.\nerror PRBMath_SD59x18_Log_InputTooSmall(SD59x18 x);\n\n/// @notice Emitted when multiplying two numbers and one of the inputs is `MIN_SD59x18`.\nerror PRBMath_SD59x18_Mul_InputTooSmall();\n\n/// @notice Emitted when multiplying two numbers and the intermediary absolute result overflows SD59x18.\nerror PRBMath_SD59x18_Mul_Overflow(SD59x18 x, SD59x18 y);\n\n/// @notice Emitted when raising a number to a power and hte intermediary absolute result overflows SD59x18.\nerror PRBMath_SD59x18_Powu_Overflow(SD59x18 x, uint256 y);\n\n/// @notice Emitted when taking the square root of a negative number.\nerror PRBMath_SD59x18_Sqrt_NegativeInput(SD59x18 x);\n\n/// @notice Emitted when the calculating the square root overflows SD59x18.\nerror PRBMath_SD59x18_Sqrt_Overflow(SD59x18 x);\n"},"@prb/math/src/ud2x18/Casting.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport { MAX_UINT40 } from \"../Common.sol\";\nimport { uMAX_SD1x18 } from \"../sd1x18/Constants.sol\";\nimport { SD1x18 } from \"../sd1x18/ValueType.sol\";\nimport { SD59x18 } from \"../sd59x18/ValueType.sol\";\nimport { UD2x18 } from \"../ud2x18/ValueType.sol\";\nimport { UD60x18 } from \"../ud60x18/ValueType.sol\";\nimport { PRBMath_UD2x18_IntoSD1x18_Overflow, PRBMath_UD2x18_IntoUint40_Overflow } from \"./Errors.sol\";\nimport { UD2x18 } from \"./ValueType.sol\";\n\n/// @notice Casts an UD2x18 number into SD1x18.\n/// - x must be less than or equal to `uMAX_SD1x18`.\nfunction intoSD1x18(UD2x18 x) pure returns (SD1x18 result) {\n    uint64 xUint = UD2x18.unwrap(x);\n    if (xUint > uint64(uMAX_SD1x18)) {\n        revert PRBMath_UD2x18_IntoSD1x18_Overflow(x);\n    }\n    result = SD1x18.wrap(int64(xUint));\n}\n\n/// @notice Casts an UD2x18 number into SD59x18.\n/// @dev There is no overflow check because the domain of UD2x18 is a subset of SD59x18.\nfunction intoSD59x18(UD2x18 x) pure returns (SD59x18 result) {\n    result = SD59x18.wrap(int256(uint256(UD2x18.unwrap(x))));\n}\n\n/// @notice Casts an UD2x18 number into UD60x18.\n/// @dev There is no overflow check because the domain of UD2x18 is a subset of UD60x18.\nfunction intoUD60x18(UD2x18 x) pure returns (UD60x18 result) {\n    result = UD60x18.wrap(UD2x18.unwrap(x));\n}\n\n/// @notice Casts an UD2x18 number into uint128.\n/// @dev There is no overflow check because the domain of UD2x18 is a subset of uint128.\nfunction intoUint128(UD2x18 x) pure returns (uint128 result) {\n    result = uint128(UD2x18.unwrap(x));\n}\n\n/// @notice Casts an UD2x18 number into uint256.\n/// @dev There is no overflow check because the domain of UD2x18 is a subset of uint256.\nfunction intoUint256(UD2x18 x) pure returns (uint256 result) {\n    result = uint256(UD2x18.unwrap(x));\n}\n\n/// @notice Casts an UD2x18 number into uint40.\n/// @dev Requirements:\n/// - x must be less than or equal to `MAX_UINT40`.\nfunction intoUint40(UD2x18 x) pure returns (uint40 result) {\n    uint64 xUint = UD2x18.unwrap(x);\n    if (xUint > uint64(MAX_UINT40)) {\n        revert PRBMath_UD2x18_IntoUint40_Overflow(x);\n    }\n    result = uint40(xUint);\n}\n\n/// @notice Alias for the `wrap` function.\nfunction ud2x18(uint64 x) pure returns (UD2x18 result) {\n    result = wrap(x);\n}\n\n/// @notice Unwrap an UD2x18 number into uint64.\nfunction unwrap(UD2x18 x) pure returns (uint64 result) {\n    result = UD2x18.unwrap(x);\n}\n\n/// @notice Wraps an uint64 number into the UD2x18 value type.\nfunction wrap(uint64 x) pure returns (UD2x18 result) {\n    result = UD2x18.wrap(x);\n}\n"},"contracts/interfaces/INodeOperatorRegistry.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.16;\r\n\r\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\nimport {IAccessControlManager} from \"../interfaces/IAccessControlManager.sol\";\r\n\r\nimport {IPoRAddresses} from \"../vendors/IPoRAddresses.sol\";\r\n\r\n/**\r\n * @title INodeOperatorRegistry\r\n * @author https://github.com/max-taylor\r\n * @notice Interface for the Node Operator Registry contract.\r\n */\r\ninterface INodeOperatorRegistry is IPoRAddresses {\r\n  /**\r\n   * @dev  Struct containing the required details to setup a validator on the beacon chain\r\n   * @param pubKey Public key of the validator\r\n   * @param signature The signature of the validator\r\n   */\r\n  struct ValidatorDetails {\r\n    bytes pubKey;\r\n    bytes signature;\r\n  }\r\n\r\n  /**\r\n   * @dev  Struct containing operator details\r\n   * @param enabled Flag indicating if the operator is enabled or disabled\r\n   * @param rewardAddress Address to sending repricing rewards to\r\n   * @param controllingAddress The address that can control the operator account\r\n   * @param name The name of the operator\r\n   * @param activeValidators The amount of active validators for the operator\r\n   */\r\n  struct Operator {\r\n    bool enabled;\r\n    address rewardAddress;\r\n    address controllingAddress;\r\n    string name;\r\n    uint128 activeValidators;\r\n  }\r\n\r\n  // ***** Events *****\r\n  /**\r\n   * @dev  Emitted when a new operator is added.\r\n   * @param operatorAddress  The address of the newly added operator.\r\n   * @param rewardAddress    The address associated with the reward for the operator.\r\n   */\r\n  event OperatorAdded(address operatorAddress, address rewardAddress);\r\n\r\n  /**\r\n   * @dev  Emitted when an operator is enabled.\r\n   * @param operator  The address of the operator that was enabled.\r\n   */\r\n  event OperatorEnabled(address indexed operator);\r\n\r\n  /**\r\n   * @dev  Emitted when an operator is disabled.\r\n   * @param operator  The address of the operator that was disabled.\r\n   */\r\n  event OperatorDisabled(address indexed operator);\r\n\r\n  /**\r\n   * @dev  Emitted when the validator details for an operator are added.\r\n   * @param operator  The address of the operator for which the validator details were added.\r\n   * @param pubKeys   An array of `ValidatorDetails` for the operator.\r\n   */\r\n  event OperatorAddedValidatorDetails(\r\n    address indexed operator,\r\n    ValidatorDetails[] pubKeys\r\n  );\r\n\r\n  /**\r\n   * @dev  Emitted when active public keys are deleted.\r\n   * @param pubKeys  An array of public keys that were deleted.\r\n   */\r\n  event ActivePubKeysDeleted(bytes[] pubKeys);\r\n\r\n  /**\r\n   * @dev  Emitted when pending public keys are deleted.\r\n   * @param pubKeys  An array of public keys that were deleted.\r\n   */\r\n  event PendingPubKeysDeleted(bytes[] pubKeys);\r\n\r\n  /**\r\n   * @dev  Emitted when public keys are used for validator setup.\r\n   * @param pubKeys  An array of public keys that were used for validator setup.\r\n   */\r\n  event PubKeysUsedForValidatorSetup(bytes[] pubKeys);\r\n\r\n  /**\r\n   * @dev  Emitted when the controlling address for an operator is updated.\r\n   * @param oldControllingAddress  The old controlling address for the operator.\r\n   * @param newControllingAddress  The new controlling address for the operator.\r\n   */\r\n  event OperatorControllingAddressUpdated(\r\n    address indexed oldControllingAddress,\r\n    address indexed newControllingAddress\r\n  );\r\n\r\n  /**\r\n   * @dev  Emitted when the reward address for an operator is updated.\r\n   * @param operator  The address of the operator for which the reward address was updated.\r\n   * @param newRewardAddress  The new reward address for the operator.\r\n   * @param oldRewardAddress  The old reward address for the operator.\r\n   */\r\n  event OperatorRewardAddressUpdated(\r\n    address indexed operator,\r\n    address indexed newRewardAddress,\r\n    address indexed oldRewardAddress\r\n  );\r\n\r\n  /**\r\n   * @dev  Emitted when the name for an operator is updated.\r\n   * @param operator  The address of the operator for which the name was updated.\r\n   * @param newName  The new name for the operator.\r\n   * @param oldName  The old name for the operator.\r\n   */\r\n  event OperatorNameUpdated(\r\n    address indexed operator,\r\n    string newName,\r\n    string oldName\r\n  );\r\n\r\n  // ***** Errors *****\r\n  /**\r\n   * @dev Thrown when an operator is not found.\r\n   * @param operator  The address of the operator that was not found.\r\n   */\r\n  error NoOperatorFound(address operator);\r\n\r\n  /**\r\n   * @dev Thrown when an operator already exists.\r\n   * @param operator The address of the operator that already exists.\r\n   */\r\n  error OperatorAlreadyExists(address operator);\r\n\r\n  /**\r\n   * @dev Thrown when an operator is already enabled.\r\n   */\r\n  error OperatorAlreadyEnabled();\r\n\r\n  /**\r\n   * @dev Thrown when an operator is already disabled.\r\n   */\r\n  error OperatorAlreadyDisabled();\r\n\r\n  /**\r\n   * @dev Thrown when an array length of zero is invalid.\r\n   */\r\n  error InvalidArrayLengthOfZero();\r\n\r\n  /**\r\n   * @dev Thrown when an operator is adding new validator details and this causes the total amount of operator's validator details to exceed uint128\r\n   */\r\n  error AmountOfValidatorDetailsExceedsLimit();\r\n\r\n  /**\r\n   * @dev Thrown during setup of new validators, when comparing the next operator's public key to the provided public key they should match. This ensures consistency in the tracking of the active and pending validator details.\r\n   * @param foundPubKey The operator's next available public key\r\n   * @param providedPubKey The public key that was passed in as an argument\r\n   */\r\n  error NextOperatorPubKeyMismatch(bytes foundPubKey, bytes providedPubKey);\r\n\r\n  /**\r\n   * @dev Thrown during the setup of new validators and when the operator that has no pending details left to use\r\n   */\r\n  error OperatorOutOfPendingKeys();\r\n\r\n  /**\r\n   * @dev Thrown when the given pubKey hasn't been added to the registry and cannot be found\r\n   * @param pubKey  The public key that was not found.\r\n   */\r\n  error NoPubKeyFound(bytes pubKey);\r\n\r\n  /**\r\n   * @dev Thrown when an operator tries to use the node operator registry whilst they are disabled\r\n   */\r\n  error CannotUseDisabledOperator();\r\n\r\n  /**\r\n   * @dev Thrown when a duplicate public key is added.\r\n   * @param existingKey  The public key that already exists.\r\n   */\r\n  error CannotAddDuplicatePubKey(bytes existingKey);\r\n\r\n  /**\r\n   * @dev Thrown when the given pubKey doesn't exist in the pending validator details sets\r\n   * @param pubKey  The missing pubKey\r\n   */\r\n  error MissingPendingValidatorDetails(bytes pubKey);\r\n\r\n  /**\r\n   * @dev Thrown when the pubKey doesn't exist in the active validator details set\r\n   * @param pubKey  The missing pubKey\r\n   */\r\n  error MissingActiveValidatorDetails(bytes pubKey);\r\n\r\n  /**\r\n   * @dev Throw when the msg.sender isn't the Deposit Manager contract\r\n   */\r\n  error InvalidPubKeySetupCaller();\r\n\r\n  /**\r\n   * @dev Thrown when an operator is trying to add validator details and a provided pubKey isn't the correct length\r\n   */\r\n  error InvalidPubKeyLength();\r\n\r\n  /**\r\n   * @dev Thrown when an operator is trying to add validator details and a provided signature isn't the correct length\r\n   */\r\n  error InvalidSignatureLength();\r\n\r\n  /**\r\n   * @dev Thrown when calling the delete active validators method from an address that doens't have the PLATFORM_ADMIN or DELETE_ACTIVE_VALIDATORS role\r\n   */\r\n  error InvalidCallerToDeleteActiveValidators();\r\n\r\n  /**\r\n   * @dev Thrown when trying to update the controlling address for an operator and the new controlling address is the same as the current controlling address\r\n   */\r\n  error CannotSetOperatorControllingAddressToSameAddress();\r\n\r\n  /**\r\n   * @dev Thrown when trying to update the controlling address for an operator and the new controlling address is already assigned to another operator\r\n   */\r\n  error CannotUpdateOperatorControllingAddressToAlreadyAssignedAddress();\r\n\r\n  // ************************************\r\n  // ***** External  methods ******\r\n\r\n  /**\r\n   * @dev This method withdraws contract's _token balance to a PLATFORM_ADMIN\r\n   * @param _token The ERC20 token to withdraw from the contract\r\n   */\r\n  function withdrawERC20(IERC20 _token) external;\r\n\r\n  /**\r\n   * @dev  Gets the next available validator details, ordered by operators with the least amount of active validators. There may be less available validators then the provided _numNewValidators amount, in that case the function will return an array of length equal to _numNewValidators but all indexes after the second return value; foundValidators, will be 0x0 values\r\n   * @param _numNewValidators The number of new validators to get details for.\r\n   * @return An array of ValidatorDetails and the length of the array of non-zero validator details\r\n   * @notice This method tries to return enough validator details to equal the provided _numNewValidators, but if there aren't enough validator details to find, it will simply return what it found, and the caller will need to check for empty values.\r\n   */\r\n  function getNextValidatorDetails(\r\n    uint256 _numNewValidators\r\n  ) external view returns (ValidatorDetails[] memory, uint256 foundValidators);\r\n\r\n  /**\r\n   * @dev  Allows the DepositManager to move provided _pubKeys from the pending validator details arrays into the active validator details array. It also returns the validator details, so that the DepositManager can pass the signature along to the ETH2 deposit contract.\r\n   * @param _pubKeys Array of public keys to use for validator setup.\r\n   * @return validatorDetails The associated validator details for the given public keys\r\n   * @notice This method will be called when the DepositManager is setting up new validators.\r\n   */\r\n  function usePubKeysForValidatorSetup(\r\n    bytes[] calldata _pubKeys\r\n  ) external returns (ValidatorDetails[] memory validatorDetails);\r\n\r\n  // ** Operator management methods **\r\n\r\n  /**\r\n   * @dev  Adds new validator details to the registry.\r\n  /**\r\n   * @dev  Callable by node operator's to add their validator details to the setup queue\r\n   * @param _validatorDetails Array of ValidatorDetails to add.\r\n  */\r\n  function addNewValidatorDetails(\r\n    ValidatorDetails[] calldata _validatorDetails\r\n  ) external;\r\n\r\n  // ** PLATFORM_ADMIN management methods **\r\n\r\n  /**\r\n   * @dev  Adds a new operator to the registry.\r\n   * @param _name Name of the operator.\r\n   * @param _operatorAddress Address of the operator.\r\n   * @param _rewardAddress Address of the reward recipient for this operator.\r\n   * @notice Throws if an operator already exists with the given _operatorAddress\r\n   */\r\n  function addOperator(\r\n    string calldata _name,\r\n    address _operatorAddress,\r\n    address _rewardAddress\r\n  ) external;\r\n\r\n  /**\r\n   * @dev  Enables an operator in the registry.\r\n   * @param _operatorAddress Address of the operator to enable.\r\n   * @notice Throws NoOperatorFound if the operator address is not found in the registry\r\n   */\r\n  function enableOperator(address _operatorAddress) external;\r\n\r\n  /**\r\n   * @dev  Disables an operator in the registry.\r\n   * @param _operatorAddress Address of the operator to disable.\r\n   * @notice Throws NoOperatorFound if the operator address is not found in the registry\r\n   */\r\n  function disableOperator(address _operatorAddress) external;\r\n\r\n  /**\r\n   * @dev  Updates the controlling address of an operator in the registry.\r\n   * @param _operatorAddress Current address of the operator.\r\n   * @param _newOperatorAddress New address of the operator.\r\n   * @notice Throws NoOperatorFound if the operator address is not found in the registry\r\n   */\r\n  function updateOperatorControllingAddress(\r\n    address _operatorAddress,\r\n    address _newOperatorAddress\r\n  ) external;\r\n\r\n  /**\r\n   * @dev  Updates the reward address of an operator in the registry.\r\n   * @param _operatorAddress Address of the operator to update.\r\n   * @param _newRewardAddress New reward address for the operator.\r\n   * @notice Throws NoOperatorFound if the operator address is not found in the registry\r\n   */\r\n  function updateOperatorRewardAddress(\r\n    address _operatorAddress,\r\n    address _newRewardAddress\r\n  ) external;\r\n\r\n  /**\r\n   * @dev  Updates the name of an operator in the registry\r\n   * @param _operatorAddress The address of the operator to update\r\n   * @param _name The new name for the operator\r\n   * @notice Throws NoOperatorFound if the operator address is not found in the registry\r\n   */\r\n  function updateOperatorName(\r\n    address _operatorAddress,\r\n    string calldata _name\r\n  ) external;\r\n\r\n  /**\r\n   * @dev  Allows the PLATFORM_ADMIN to delete validators that are pending. This is likely to be called via an admin if a public key fails the front-running checks\r\n   * @notice Throws InvalidArrayLengthOfZero if the length of _pubKeys is 0\r\n   * @notice Throws NoPubKeyFound if any of the provided pubKeys is not found in the pending validators set\r\n   * @param _pubKeys The public keys of the pending validators to delete\r\n   */\r\n  function deletePendingValidators(bytes[] calldata _pubKeys) external;\r\n\r\n  /**\r\n   * @dev  Allows the PLATFORM_ADMIN to delete validator public keys that have been used to setup a validator and that validator has now exited\r\n   * @notice Throws NoPubKeyFound if any of the provided pubKeys is not found in the active validators set\r\n   * @notice Throws InvalidArrayLengthOfZero if the length of _pubKeys is 0\r\n   * @param _pubKeys The public keys of the active validators to delete\r\n   */\r\n  function deleteActiveValidators(bytes[] calldata _pubKeys) external;\r\n\r\n  /**\r\n   * @dev  Returns the address of the AccessControlManager contract\r\n   */\r\n  function AccessControlManager() external returns (IAccessControlManager);\r\n\r\n  /**\r\n   * @dev  Returns the operator details for a given operator address\r\n   * @notice Throws NoOperatorFound if the operator address is not found in the registry\r\n   * @param _operatorAddress The address of the operator to retrieve\r\n   * @return operator The operator details, including name, reward address, and enabled status\r\n   * @return totalValidatorDetails The total amount of validator details for an operator\r\n   * @return operatorId The operator's Id\r\n   */\r\n  function getOperator(\r\n    address _operatorAddress\r\n  )\r\n    external\r\n    view\r\n    returns (\r\n      Operator memory operator,\r\n      uint128 totalValidatorDetails,\r\n      uint128 operatorId\r\n    );\r\n\r\n  /**\r\n   * @dev  Returns the pending validator details for a given operator address\r\n   * @notice Throws NoOperatorFound if the operator address is not found in the registry\r\n   * @param _operatorAddress The address of the operator to retrieve pending validator details for\r\n   * @return validatorDetails The pending validator details for the given operator\r\n   */\r\n  function getOperatorsPendingValidatorDetails(\r\n    address _operatorAddress\r\n  ) external returns (ValidatorDetails[] memory);\r\n\r\n  /**\r\n   * @dev  Returns the active validator details for a given operator address\r\n   * @notice Throws NoOperatorFound if the operator address is not found in the registry\r\n   * @param _operatorAddress The address of the operator to retrieve active validator details for\r\n   * @return validatorDetails The active validator details for the given operator\r\n   */\r\n  function getOperatorsActiveValidatorDetails(\r\n    address _operatorAddress\r\n  ) external returns (ValidatorDetails[] memory validatorDetails);\r\n\r\n  /**\r\n   * @dev  Returns the reward details for a given operator Id, this method is used in the rswETH contract when paying rswETH rewards\r\n   * @param _operatorId The operator Id to get the reward details for\r\n   * @return rewardAddress The reward address of the operator\r\n   * @return activeValidators The amount of active validators for the operator\r\n   */\r\n  function getRewardDetailsForOperatorId(\r\n    uint128 _operatorId\r\n  ) external returns (address rewardAddress, uint128 activeValidators);\r\n\r\n  /**\r\n   * @dev  Returns the number of operators in the registry\r\n   */\r\n  function numOperators() external returns (uint128);\r\n\r\n  /**\r\n   * @dev  Returns the amount of pending validator keys in the registry\r\n   */\r\n  function numPendingValidators() external returns (uint256);\r\n\r\n  /**\r\n   * @dev  Returns the operator ID for a given operator address\r\n   * @notice Throws NoOperatorFound if the operator address is not found in the registry\r\n   * @param _operator The address of the operator to retrieve the operator ID for\r\n   * @return _operatorId The operator ID for the given operator\r\n   */\r\n  function getOperatorIdForAddress(\r\n    address _operator\r\n  ) external returns (uint128 _operatorId);\r\n\r\n  /**\r\n   * @dev Returns the `operatorId` associated with the given `pubKey`.\r\n   * @param pubKey  The public key to lookup the `operatorId` for.\r\n   * @notice Returns 0 if no operatorId controls the pubKey\r\n   */\r\n  function getOperatorIdForPubKey(\r\n    bytes calldata pubKey\r\n  ) external returns (uint128);\r\n}\r\n"},"contracts/vendors/contracts/interfaces/IDelegationManager.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity >=0.5.0;\r\n\r\nimport \"./IStrategy.sol\";\r\nimport \"./ISignatureUtils.sol\";\r\nimport \"./IStrategyManager.sol\";\r\n\r\n/**\r\n * @title DelegationManager\r\n * @author Layr Labs, Inc.\r\n * @notice Terms of Service: https://docs.eigenlayer.xyz/overview/terms-of-service\r\n * @notice  This is the contract for delegation in EigenLayer. The main functionalities of this contract are\r\n * - enabling anyone to register as an operator in EigenLayer\r\n * - allowing operators to specify parameters related to stakers who delegate to them\r\n * - enabling any staker to delegate its stake to the operator of its choice (a given staker can only delegate to a single operator at a time)\r\n * - enabling a staker to undelegate its assets from the operator it is delegated to (performed as part of the withdrawal process, initiated through the StrategyManager)\r\n */\r\ninterface IDelegationManager is ISignatureUtils {\r\n    // @notice Struct used for storing information about a single operator who has registered with EigenLayer\r\n    struct OperatorDetails {\r\n        // @notice address to receive the rewards that the operator earns via serving applications built on EigenLayer.\r\n        address earningsReceiver;\r\n        /**\r\n         * @notice Address to verify signatures when a staker wishes to delegate to the operator, as well as controlling \"forced undelegations\".\r\n         * @dev Signature verification follows these rules:\r\n         * 1) If this address is left as address(0), then any staker will be free to delegate to the operator, i.e. no signature verification will be performed.\r\n         * 2) If this address is an EOA (i.e. it has no code), then we follow standard ECDSA signature verification for delegations to the operator.\r\n         * 3) If this address is a contract (i.e. it has code) then we forward a call to the contract and verify that it returns the correct EIP-1271 \"magic value\".\r\n         */\r\n        address delegationApprover;\r\n        /**\r\n         * @notice A minimum delay -- measured in blocks -- enforced between:\r\n         * 1) the operator signalling their intent to register for a service, via calling `Slasher.optIntoSlashing`\r\n         * and\r\n         * 2) the operator completing registration for the service, via the service ultimately calling `Slasher.recordFirstStakeUpdate`\r\n         * @dev note that for a specific operator, this value *cannot decrease*, i.e. if the operator wishes to modify their OperatorDetails,\r\n         * then they are only allowed to either increase this value or keep it the same.\r\n         */\r\n        uint32 stakerOptOutWindowBlocks;\r\n    }\r\n\r\n    /**\r\n     * @notice Abstract struct used in calculating an EIP712 signature for a staker to approve that they (the staker themselves) delegate to a specific operator.\r\n     * @dev Used in computing the `STAKER_DELEGATION_TYPEHASH` and as a reference in the computation of the stakerDigestHash in the `delegateToBySignature` function.\r\n     */\r\n    struct StakerDelegation {\r\n        // the staker who is delegating\r\n        address staker;\r\n        // the operator being delegated to\r\n        address operator;\r\n        // the staker's nonce\r\n        uint256 nonce;\r\n        // the expiration timestamp (UTC) of the signature\r\n        uint256 expiry;\r\n    }\r\n\r\n    /**\r\n     * @notice Abstract struct used in calculating an EIP712 signature for an operator's delegationApprover to approve that a specific staker delegate to the operator.\r\n     * @dev Used in computing the `DELEGATION_APPROVAL_TYPEHASH` and as a reference in the computation of the approverDigestHash in the `_delegate` function.\r\n     */\r\n    struct DelegationApproval {\r\n        // the staker who is delegating\r\n        address staker;\r\n        // the operator being delegated to\r\n        address operator;\r\n        // the operator's provided salt\r\n        bytes32 salt;\r\n        // the expiration timestamp (UTC) of the signature\r\n        uint256 expiry;\r\n    }\r\n\r\n    /**\r\n     * Struct type used to specify an existing queued withdrawal. Rather than storing the entire struct, only a hash is stored.\r\n     * In functions that operate on existing queued withdrawals -- e.g. completeQueuedWithdrawal`, the data is resubmitted and the hash of the submitted\r\n     * data is computed by `calculateWithdrawalRoot` and checked against the stored hash in order to confirm the integrity of the submitted data.\r\n     */\r\n    struct Withdrawal {\r\n        // The address that originated the Withdrawal\r\n        address staker;\r\n        // The address that the staker was delegated to at the time that the Withdrawal was created\r\n        address delegatedTo;\r\n        // The address that can complete the Withdrawal + will receive funds when completing the withdrawal\r\n        address withdrawer;\r\n        // Nonce used to guarantee that otherwise identical withdrawals have unique hashes\r\n        uint256 nonce;\r\n        // Block number when the Withdrawal was created\r\n        uint32 startBlock;\r\n        // Array of strategies that the Withdrawal contains\r\n        IStrategy[] strategies;\r\n        // Array containing the amount of shares in each Strategy in the `strategies` array\r\n        uint256[] shares;\r\n    }\r\n\r\n    struct QueuedWithdrawalParams {\r\n        // Array of strategies that the QueuedWithdrawal contains\r\n        IStrategy[] strategies;\r\n        // Array containing the amount of shares in each Strategy in the `strategies` array\r\n        uint256[] shares;\r\n        // The address of the withdrawer\r\n        address withdrawer;\r\n    }\r\n\r\n    // @notice Emitted when a new operator registers in EigenLayer and provides their OperatorDetails.\r\n    event OperatorRegistered(address indexed operator, OperatorDetails operatorDetails);\r\n\r\n    /// @notice Emitted when an operator updates their OperatorDetails to @param newOperatorDetails\r\n    event OperatorDetailsModified(address indexed operator, OperatorDetails newOperatorDetails);\r\n\r\n    /**\r\n     * @notice Emitted when @param operator indicates that they are updating their MetadataURI string\r\n     * @dev Note that these strings are *never stored in storage* and are instead purely emitted in events for off-chain indexing\r\n     */\r\n    event OperatorMetadataURIUpdated(address indexed operator, string metadataURI);\r\n\r\n    /// @notice Emitted whenever an operator's shares are increased for a given strategy. Note that shares is the delta in the operator's shares.\r\n    event OperatorSharesIncreased(address indexed operator, address staker, IStrategy strategy, uint256 shares);\r\n\r\n    /// @notice Emitted whenever an operator's shares are decreased for a given strategy. Note that shares is the delta in the operator's shares.\r\n    event OperatorSharesDecreased(address indexed operator, address staker, IStrategy strategy, uint256 shares);\r\n\r\n    /// @notice Emitted when @param staker delegates to @param operator.\r\n    event StakerDelegated(address indexed staker, address indexed operator);\r\n\r\n    /// @notice Emitted when @param staker undelegates from @param operator.\r\n    event StakerUndelegated(address indexed staker, address indexed operator);\r\n\r\n    /// @notice Emitted when @param staker is undelegated via a call not originating from the staker themself\r\n    event StakerForceUndelegated(address indexed staker, address indexed operator);\r\n\r\n    /**\r\n     * @notice Emitted when a new withdrawal is queued.\r\n     * @param withdrawalRoot Is the hash of the `withdrawal`.\r\n     * @param withdrawal Is the withdrawal itself.\r\n     */\r\n    event WithdrawalQueued(bytes32 withdrawalRoot, Withdrawal withdrawal);\r\n\r\n    /// @notice Emitted when a queued withdrawal is completed\r\n    event WithdrawalCompleted(bytes32 withdrawalRoot);\r\n\r\n    /// @notice Emitted when a queued withdrawal is *migrated* from the StrategyManager to the DelegationManager\r\n    event WithdrawalMigrated(bytes32 oldWithdrawalRoot, bytes32 newWithdrawalRoot);\r\n    \r\n    /// @notice Emitted when the `minWithdrawalDelayBlocks` variable is modified from `previousValue` to `newValue`.\r\n    event MinWithdrawalDelayBlocksSet(uint256 previousValue, uint256 newValue);\r\n\r\n    /// @notice Emitted when the `strategyWithdrawalDelayBlocks` variable is modified from `previousValue` to `newValue`.\r\n    event StrategyWithdrawalDelayBlocksSet(IStrategy strategy, uint256 previousValue, uint256 newValue);\r\n\r\n    /**\r\n     * @notice Registers the caller as an operator in EigenLayer.\r\n     * @param registeringOperatorDetails is the `OperatorDetails` for the operator.\r\n     * @param metadataURI is a URI for the operator's metadata, i.e. a link providing more details on the operator.\r\n     *\r\n     * @dev Once an operator is registered, they cannot 'deregister' as an operator, and they will forever be considered \"delegated to themself\".\r\n     * @dev This function will revert if the caller attempts to set their `earningsReceiver` to address(0).\r\n     * @dev Note that the `metadataURI` is *never stored * and is only emitted in the `OperatorMetadataURIUpdated` event\r\n     */\r\n    function registerAsOperator(\r\n        OperatorDetails calldata registeringOperatorDetails,\r\n        string calldata metadataURI\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Updates an operator's stored `OperatorDetails`.\r\n     * @param newOperatorDetails is the updated `OperatorDetails` for the operator, to replace their current OperatorDetails`.\r\n     *\r\n     * @dev The caller must have previously registered as an operator in EigenLayer.\r\n     * @dev This function will revert if the caller attempts to set their `earningsReceiver` to address(0).\r\n     */\r\n    function modifyOperatorDetails(OperatorDetails calldata newOperatorDetails) external;\r\n\r\n    /**\r\n     * @notice Called by an operator to emit an `OperatorMetadataURIUpdated` event indicating the information has updated.\r\n     * @param metadataURI The URI for metadata associated with an operator\r\n     * @dev Note that the `metadataURI` is *never stored * and is only emitted in the `OperatorMetadataURIUpdated` event\r\n     */\r\n    function updateOperatorMetadataURI(string calldata metadataURI) external;\r\n\r\n    /**\r\n     * @notice Caller delegates their stake to an operator.\r\n     * @param operator The account (`msg.sender`) is delegating its assets to for use in serving applications built on EigenLayer.\r\n     * @param approverSignatureAndExpiry Verifies the operator approves of this delegation\r\n     * @param approverSalt A unique single use value tied to an individual signature.\r\n     * @dev The approverSignatureAndExpiry is used in the event that:\r\n     *          1) the operator's `delegationApprover` address is set to a non-zero value.\r\n     *                  AND\r\n     *          2) neither the operator nor their `delegationApprover` is the `msg.sender`, since in the event that the operator\r\n     *             or their delegationApprover is the `msg.sender`, then approval is assumed.\r\n     * @dev In the event that `approverSignatureAndExpiry` is not checked, its content is ignored entirely; it's recommended to use an empty input\r\n     * in this case to save on complexity + gas costs\r\n     */\r\n    function delegateTo(\r\n        address operator,\r\n        SignatureWithExpiry memory approverSignatureAndExpiry,\r\n        bytes32 approverSalt\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Caller delegates a staker's stake to an operator with valid signatures from both parties.\r\n     * @param staker The account delegating stake to an `operator` account\r\n     * @param operator The account (`staker`) is delegating its assets to for use in serving applications built on EigenLayer.\r\n     * @param stakerSignatureAndExpiry Signed data from the staker authorizing delegating stake to an operator\r\n     * @param approverSignatureAndExpiry is a parameter that will be used for verifying that the operator approves of this delegation action in the event that:\r\n     * @param approverSalt Is a salt used to help guarantee signature uniqueness. Each salt can only be used once by a given approver.\r\n     *\r\n     * @dev If `staker` is an EOA, then `stakerSignature` is verified to be a valid ECDSA stakerSignature from `staker`, indicating their intention for this action.\r\n     * @dev If `staker` is a contract, then `stakerSignature` will be checked according to EIP-1271.\r\n     * @dev the operator's `delegationApprover` address is set to a non-zero value.\r\n     * @dev neither the operator nor their `delegationApprover` is the `msg.sender`, since in the event that the operator or their delegationApprover\r\n     * is the `msg.sender`, then approval is assumed.\r\n     * @dev This function will revert if the current `block.timestamp` is equal to or exceeds the expiry\r\n     * @dev In the case that `approverSignatureAndExpiry` is not checked, its content is ignored entirely; it's recommended to use an empty input\r\n     * in this case to save on complexity + gas costs\r\n     */\r\n    function delegateToBySignature(\r\n        address staker,\r\n        address operator,\r\n        SignatureWithExpiry memory stakerSignatureAndExpiry,\r\n        SignatureWithExpiry memory approverSignatureAndExpiry,\r\n        bytes32 approverSalt\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Undelegates the staker from the operator who they are delegated to. Puts the staker into the \"undelegation limbo\" mode of the EigenPodManager\r\n     * and queues a withdrawal of all of the staker's shares in the StrategyManager (to the staker), if necessary.\r\n     * @param staker The account to be undelegated.\r\n     * @return withdrawalRoot The root of the newly queued withdrawal, if a withdrawal was queued. Otherwise just bytes32(0).\r\n     *\r\n     * @dev Reverts if the `staker` is also an operator, since operators are not allowed to undelegate from themselves.\r\n     * @dev Reverts if the caller is not the staker, nor the operator who the staker is delegated to, nor the operator's specified \"delegationApprover\"\r\n     * @dev Reverts if the `staker` is already undelegated.\r\n     */\r\n    function undelegate(address staker) external returns (bytes32[] memory withdrawalRoot);\r\n\r\n    /**\r\n     * Allows a staker to withdraw some shares. Withdrawn shares/strategies are immediately removed\r\n     * from the staker. If the staker is delegated, withdrawn shares/strategies are also removed from\r\n     * their operator.\r\n     *\r\n     * All withdrawn shares/strategies are placed in a queue and can be fully withdrawn after a delay.\r\n     */\r\n    function queueWithdrawals(\r\n        QueuedWithdrawalParams[] calldata queuedWithdrawalParams\r\n    ) external returns (bytes32[] memory);\r\n\r\n    /**\r\n     * @notice Used to complete the specified `withdrawal`. The caller must match `withdrawal.withdrawer`\r\n     * @param withdrawal The Withdrawal to complete.\r\n     * @param tokens Array in which the i-th entry specifies the `token` input to the 'withdraw' function of the i-th Strategy in the `withdrawal.strategies` array.\r\n     * This input can be provided with zero length if `receiveAsTokens` is set to 'false' (since in that case, this input will be unused)\r\n     * @param middlewareTimesIndex is the index in the operator that the staker who triggered the withdrawal was delegated to's middleware times array\r\n     * @param receiveAsTokens If true, the shares specified in the withdrawal will be withdrawn from the specified strategies themselves\r\n     * and sent to the caller, through calls to `withdrawal.strategies[i].withdraw`. If false, then the shares in the specified strategies\r\n     * will simply be transferred to the caller directly.\r\n     * @dev middlewareTimesIndex should be calculated off chain before calling this function by finding the first index that satisfies `slasher.canWithdraw`\r\n     * @dev beaconChainETHStrategy shares are non-transferrable, so if `receiveAsTokens = false` and `withdrawal.withdrawer != withdrawal.staker`, note that\r\n     * any beaconChainETHStrategy shares in the `withdrawal` will be _returned to the staker_, rather than transferred to the withdrawer, unlike shares in\r\n     * any other strategies, which will be transferred to the withdrawer.\r\n     */\r\n    function completeQueuedWithdrawal(\r\n        Withdrawal calldata withdrawal,\r\n        IERC20[] calldata tokens,\r\n        uint256 middlewareTimesIndex,\r\n        bool receiveAsTokens\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Array-ified version of `completeQueuedWithdrawal`.\r\n     * Used to complete the specified `withdrawals`. The function caller must match `withdrawals[...].withdrawer`\r\n     * @param withdrawals The Withdrawals to complete.\r\n     * @param tokens Array of tokens for each Withdrawal. See `completeQueuedWithdrawal` for the usage of a single array.\r\n     * @param middlewareTimesIndexes One index to reference per Withdrawal. See `completeQueuedWithdrawal` for the usage of a single index.\r\n     * @param receiveAsTokens Whether or not to complete each withdrawal as tokens. See `completeQueuedWithdrawal` for the usage of a single boolean.\r\n     * @dev See `completeQueuedWithdrawal` for relevant dev tags\r\n     */\r\n    function completeQueuedWithdrawals(\r\n        Withdrawal[] calldata withdrawals,\r\n        IERC20[][] calldata tokens,\r\n        uint256[] calldata middlewareTimesIndexes,\r\n        bool[] calldata receiveAsTokens\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Increases a staker's delegated share balance in a strategy.\r\n     * @param staker The address to increase the delegated shares for their operator.\r\n     * @param strategy The strategy in which to increase the delegated shares.\r\n     * @param shares The number of shares to increase.\r\n     *\r\n     * @dev *If the staker is actively delegated*, then increases the `staker`'s delegated shares in `strategy` by `shares`. Otherwise does nothing.\r\n     * @dev Callable only by the StrategyManager or EigenPodManager.\r\n     */\r\n    function increaseDelegatedShares(\r\n        address staker,\r\n        IStrategy strategy,\r\n        uint256 shares\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Decreases a staker's delegated share balance in a strategy.\r\n     * @param staker The address to increase the delegated shares for their operator.\r\n     * @param strategy The strategy in which to decrease the delegated shares.\r\n     * @param shares The number of shares to decrease.\r\n     *\r\n     * @dev *If the staker is actively delegated*, then decreases the `staker`'s delegated shares in `strategy` by `shares`. Otherwise does nothing.\r\n     * @dev Callable only by the StrategyManager or EigenPodManager.\r\n     */\r\n    function decreaseDelegatedShares(\r\n        address staker,\r\n        IStrategy strategy,\r\n        uint256 shares\r\n    ) external;\r\n\r\n    /**\r\n     * @notice returns the address of the operator that `staker` is delegated to.\r\n     * @notice Mapping: staker => operator whom the staker is currently delegated to.\r\n     * @dev Note that returning address(0) indicates that the staker is not actively delegated to any operator.\r\n     */\r\n    function delegatedTo(address staker) external view returns (address);\r\n\r\n    /**\r\n     * @notice Returns the OperatorDetails struct associated with an `operator`.\r\n     */\r\n    function operatorDetails(address operator) external view returns (OperatorDetails memory);\r\n\r\n    /*\r\n     * @notice Returns the earnings receiver address for an operator\r\n     */\r\n    function earningsReceiver(address operator) external view returns (address);\r\n\r\n    /**\r\n     * @notice Returns the delegationApprover account for an operator\r\n     */\r\n    function delegationApprover(address operator) external view returns (address);\r\n\r\n    /**\r\n     * @notice Returns the stakerOptOutWindowBlocks for an operator\r\n     */\r\n    function stakerOptOutWindowBlocks(address operator) external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Given array of strategies, returns array of shares for the operator\r\n     */\r\n    function getOperatorShares(\r\n        address operator,\r\n        IStrategy[] memory strategies\r\n    ) external view returns (uint256[] memory);\r\n\r\n    /**\r\n     * @notice Given a list of strategies, return the minimum number of blocks that must pass to withdraw\r\n     * from all the inputted strategies. Return value is >= minWithdrawalDelayBlocks as this is the global min withdrawal delay.\r\n     * @param strategies The strategies to check withdrawal delays for\r\n     */\r\n    function getWithdrawalDelay(IStrategy[] calldata strategies) external view returns (uint256);\r\n\r\n    /**\r\n     * @notice returns the total number of shares in `strategy` that are delegated to `operator`.\r\n     * @notice Mapping: operator => strategy => total number of shares in the strategy delegated to the operator.\r\n     * @dev By design, the following invariant should hold for each Strategy:\r\n     * (operator's shares in delegation manager) = sum (shares above zero of all stakers delegated to operator)\r\n     * = sum (delegateable shares of all stakers delegated to the operator)\r\n     */\r\n    function operatorShares(address operator, IStrategy strategy) external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Returns 'true' if `staker` *is* actively delegated, and 'false' otherwise.\r\n     */\r\n    function isDelegated(address staker) external view returns (bool);\r\n\r\n    /**\r\n     * @notice Returns true is an operator has previously registered for delegation.\r\n     */\r\n    function isOperator(address operator) external view returns (bool);\r\n\r\n    /// @notice Mapping: staker => number of signed delegation nonces (used in `delegateToBySignature`) from the staker that the contract has already checked\r\n    function stakerNonce(address staker) external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Mapping: delegationApprover => 32-byte salt => whether or not the salt has already been used by the delegationApprover.\r\n     * @dev Salts are used in the `delegateTo` and `delegateToBySignature` functions. Note that these functions only process the delegationApprover's\r\n     * signature + the provided salt if the operator being delegated to has specified a nonzero address as their `delegationApprover`.\r\n     */\r\n    function delegationApproverSaltIsSpent(address _delegationApprover, bytes32 salt) external view returns (bool);\r\n\r\n    /**\r\n     * @notice Minimum delay enforced by this contract for completing queued withdrawals. Measured in blocks, and adjustable by this contract's owner,\r\n     * up to a maximum of `MAX_WITHDRAWAL_DELAY_BLOCKS`. Minimum value is 0 (i.e. no delay enforced).\r\n     * Note that strategies each have a separate withdrawal delay, which can be greater than this value. So the minimum number of blocks that must pass\r\n     * to withdraw a strategy is MAX(minWithdrawalDelayBlocks, strategyWithdrawalDelayBlocks[strategy])\r\n     */\r\n    function minWithdrawalDelayBlocks() external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Minimum delay enforced by this contract per Strategy for completing queued withdrawals. Measured in blocks, and adjustable by this contract's owner,\r\n     * up to a maximum of `MAX_WITHDRAWAL_DELAY_BLOCKS`. Minimum value is 0 (i.e. no delay enforced).\r\n     */\r\n    function strategyWithdrawalDelayBlocks(IStrategy strategy) external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Calculates the digestHash for a `staker` to sign to delegate to an `operator`\r\n     * @param staker The signing staker\r\n     * @param operator The operator who is being delegated to\r\n     * @param expiry The desired expiry time of the staker's signature\r\n     */\r\n    function calculateCurrentStakerDelegationDigestHash(\r\n        address staker,\r\n        address operator,\r\n        uint256 expiry\r\n    ) external view returns (bytes32);\r\n\r\n    /**\r\n     * @notice Calculates the digest hash to be signed and used in the `delegateToBySignature` function\r\n     * @param staker The signing staker\r\n     * @param _stakerNonce The nonce of the staker. In practice we use the staker's current nonce, stored at `stakerNonce[staker]`\r\n     * @param operator The operator who is being delegated to\r\n     * @param expiry The desired expiry time of the staker's signature\r\n     */\r\n    function calculateStakerDelegationDigestHash(\r\n        address staker,\r\n        uint256 _stakerNonce,\r\n        address operator,\r\n        uint256 expiry\r\n    ) external view returns (bytes32);\r\n\r\n    /**\r\n     * @notice Calculates the digest hash to be signed by the operator's delegationApprove and used in the `delegateTo` and `delegateToBySignature` functions.\r\n     * @param staker The account delegating their stake\r\n     * @param operator The account receiving delegated stake\r\n     * @param _delegationApprover the operator's `delegationApprover` who will be signing the delegationHash (in general)\r\n     * @param approverSalt A unique and single use value associated with the approver signature.\r\n     * @param expiry Time after which the approver's signature becomes invalid\r\n     */\r\n    function calculateDelegationApprovalDigestHash(\r\n        address staker,\r\n        address operator,\r\n        address _delegationApprover,\r\n        bytes32 approverSalt,\r\n        uint256 expiry\r\n    ) external view returns (bytes32);\r\n\r\n    /// @notice The EIP-712 typehash for the contract's domain\r\n    function DOMAIN_TYPEHASH() external view returns (bytes32);\r\n\r\n    /// @notice The EIP-712 typehash for the StakerDelegation struct used by the contract\r\n    function STAKER_DELEGATION_TYPEHASH() external view returns (bytes32);\r\n\r\n    /// @notice The EIP-712 typehash for the DelegationApproval struct used by the contract\r\n    function DELEGATION_APPROVAL_TYPEHASH() external view returns (bytes32);\r\n\r\n    /**\r\n     * @notice Getter function for the current EIP-712 domain separator for this contract.\r\n     *\r\n     * @dev The domain separator will change in the event of a fork that changes the ChainID.\r\n     * @dev By introducing a domain separator the DApp developers are guaranteed that there can be no signature collision.\r\n     * for more detailed information please read EIP-712.\r\n     */\r\n    function domainSeparator() external view returns (bytes32);\r\n    \r\n    /// @notice Mapping: staker => cumulative number of queued withdrawals they have ever initiated.\r\n    /// @dev This only increments (doesn't decrement), and is used to help ensure that otherwise identical withdrawals have unique hashes.\r\n    function cumulativeWithdrawalsQueued(address staker) external view returns (uint256);\r\n\r\n    /// @notice Returns the keccak256 hash of `withdrawal`.\r\n    function calculateWithdrawalRoot(Withdrawal memory withdrawal) external pure returns (bytes32);\r\n\r\n    function migrateQueuedWithdrawals(IStrategyManager.DeprecatedStruct_QueuedWithdrawal[] memory withdrawalsToQueue) external;\r\n}\r\n"},"contracts/vendors/IPoRAddresses.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.16;\r\n\r\n/**\r\n * @title Chainlink Proof-of-Reserve address list interface.\r\n * @notice This interface enables Chainlink nodes to get the list addresses to be used in a PoR feed. A single\r\n * contract that implements this interface can only store an address list for a single PoR feed.\r\n * @dev All functions in this interface are expected to be called off-chain, so gas usage is not a big concern.\r\n * This makes it possible to store addresses in optimized data types and convert them to human-readable strings\r\n * in `getPoRAddressList()`.\r\n */\r\ninterface IPoRAddresses {\r\n  /**\r\n   * @notice Get total number of addresses in the list.\r\n   * @return The array length\r\n   */\r\n  function getPoRAddressListLength() external view returns (uint256);\r\n\r\n  /**\r\n   * @notice Get a batch of human-readable addresses from the address list.\r\n   * @dev Due to limitations of gas usage in off-chain calls, we need to support fetching the addresses in batches.\r\n   * EVM addresses need to be converted to human-readable strings. The address strings need to be in the same format\r\n   * that would be used when querying the balance of that address.\r\n   * @param startIndex The index of the first address in the batch.\r\n   * @param endIndex The index of the last address in the batch. If `endIndex > getPoRAddressListLength()-1`,\r\n   * endIndex need to default to `getPoRAddressListLength()-1`. If `endIndex < startIndex`, the result would be an\r\n   * empty array.\r\n   * @return Array of addresses as strings.\r\n   */\r\n  function getPoRAddressList(\r\n    uint256 startIndex,\r\n    uint256 endIndex\r\n  ) external view returns (string[] memory);\r\n}\r\n"},"contracts/vendors/contracts/interfaces/IEigenPodManager.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity >=0.5.0;\r\n\r\nimport \"@openzeppelin/contracts/proxy/beacon/IBeacon.sol\";\r\nimport \"./IETHPOSDeposit.sol\";\r\nimport \"./IStrategyManager.sol\";\r\nimport \"./IEigenPod.sol\";\r\nimport \"./IBeaconChainOracle.sol\";\r\nimport \"./IPausable.sol\";\r\nimport \"./ISlasher.sol\";\r\nimport \"./IStrategy.sol\";\r\n\r\n/**\r\n * @title Interface for factory that creates and manages solo staking pods that have their withdrawal credentials pointed to EigenLayer.\r\n * @author Layr Labs, Inc.\r\n * @notice Terms of Service: https://docs.eigenlayer.xyz/overview/terms-of-service\r\n */\r\n\r\ninterface IEigenPodManager is IPausable {\r\n    /// @notice Emitted to notify the update of the beaconChainOracle address\r\n    event BeaconOracleUpdated(address indexed newOracleAddress);\r\n\r\n    /// @notice Emitted to notify the deployment of an EigenPod\r\n    event PodDeployed(address indexed eigenPod, address indexed podOwner);\r\n\r\n    /// @notice Emitted to notify a deposit of beacon chain ETH recorded in the strategy manager\r\n    event BeaconChainETHDeposited(address indexed podOwner, uint256 amount);\r\n\r\n    /// @notice Emitted when `maxPods` value is updated from `previousValue` to `newValue`\r\n    event MaxPodsUpdated(uint256 previousValue, uint256 newValue);\r\n\r\n    /// @notice Emitted when the balance of an EigenPod is updated\r\n    event PodSharesUpdated(address indexed podOwner, int256 sharesDelta);\r\n\r\n    /// @notice Emitted when a withdrawal of beacon chain ETH is completed\r\n    event BeaconChainETHWithdrawalCompleted(\r\n        address indexed podOwner,\r\n        uint256 shares,\r\n        uint96 nonce,\r\n        address delegatedAddress,\r\n        address withdrawer,\r\n        bytes32 withdrawalRoot\r\n    );\r\n\r\n    event DenebForkTimestampUpdated(uint64 newValue);\r\n\r\n    /**\r\n     * @notice Creates an EigenPod for the sender.\r\n     * @dev Function will revert if the `msg.sender` already has an EigenPod.\r\n     * @dev Returns EigenPod address \r\n     */\r\n    function createPod() external returns (address);\r\n\r\n    /**\r\n     * @notice Stakes for a new beacon chain validator on the sender's EigenPod.\r\n     * Also creates an EigenPod for the sender if they don't have one already.\r\n     * @param pubkey The 48 bytes public key of the beacon chain validator.\r\n     * @param signature The validator's signature of the deposit data.\r\n     * @param depositDataRoot The root/hash of the deposit data for the validator's deposit.\r\n     */\r\n    function stake(bytes calldata pubkey, bytes calldata signature, bytes32 depositDataRoot) external payable;\r\n\r\n    /**\r\n     * @notice Changes the `podOwner`'s shares by `sharesDelta` and performs a call to the DelegationManager\r\n     * to ensure that delegated shares are also tracked correctly\r\n     * @param podOwner is the pod owner whose balance is being updated.\r\n     * @param sharesDelta is the change in podOwner's beaconChainETHStrategy shares\r\n     * @dev Callable only by the podOwner's EigenPod contract.\r\n     * @dev Reverts if `sharesDelta` is not a whole Gwei amount\r\n     */\r\n    function recordBeaconChainETHBalanceUpdate(address podOwner, int256 sharesDelta) external;\r\n\r\n    /**\r\n     * @notice Updates the oracle contract that provides the beacon chain state root\r\n     * @param newBeaconChainOracle is the new oracle contract being pointed to\r\n     * @dev Callable only by the owner of this contract (i.e. governance)\r\n     */\r\n    function updateBeaconChainOracle(IBeaconChainOracle newBeaconChainOracle) external;\r\n\r\n    /// @notice Returns the address of the `podOwner`'s EigenPod if it has been deployed.\r\n    function ownerToPod(address podOwner) external view returns (IEigenPod);\r\n\r\n    /// @notice Returns the address of the `podOwner`'s EigenPod (whether it is deployed yet or not).\r\n    function getPod(address podOwner) external view returns (IEigenPod);\r\n\r\n    /// @notice The ETH2 Deposit Contract\r\n    function ethPOS() external view returns (IETHPOSDeposit);\r\n\r\n    /// @notice Beacon proxy to which the EigenPods point\r\n    function eigenPodBeacon() external view returns (IBeacon);\r\n\r\n    /// @notice Oracle contract that provides updates to the beacon chain's state\r\n    function beaconChainOracle() external view returns (IBeaconChainOracle);\r\n\r\n    /// @notice Returns the beacon block root at `timestamp`. Reverts if the Beacon block root at `timestamp` has not yet been finalized.\r\n    function getBlockRootAtTimestamp(uint64 timestamp) external view returns (bytes32);\r\n\r\n    /// @notice EigenLayer's StrategyManager contract\r\n    function strategyManager() external view returns (IStrategyManager);\r\n\r\n    /// @notice EigenLayer's Slasher contract\r\n    function slasher() external view returns (ISlasher);\r\n\r\n    /// @notice Returns 'true' if the `podOwner` has created an EigenPod, and 'false' otherwise.\r\n    function hasPod(address podOwner) external view returns (bool);\r\n\r\n    /// @notice Returns the number of EigenPods that have been created\r\n    function numPods() external view returns (uint256);\r\n\r\n    /// @notice Returns the maximum number of EigenPods that can be created\r\n    function maxPods() external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Mapping from Pod owner owner to the number of shares they have in the virtual beacon chain ETH strategy.\r\n     * @dev The share amount can become negative. This is necessary to accommodate the fact that a pod owner's virtual beacon chain ETH shares can\r\n     * decrease between the pod owner queuing and completing a withdrawal.\r\n     * When the pod owner's shares would otherwise increase, this \"deficit\" is decreased first _instead_.\r\n     * Likewise, when a withdrawal is completed, this \"deficit\" is decreased and the withdrawal amount is decreased; We can think of this\r\n     * as the withdrawal \"paying off the deficit\".\r\n     */\r\n    function podOwnerShares(address podOwner) external view returns (int256);\r\n\r\n    /// @notice returns canonical, virtual beaconChainETH strategy\r\n    function beaconChainETHStrategy() external view returns (IStrategy);\r\n\r\n    /**\r\n     * @notice Used by the DelegationManager to remove a pod owner's shares while they're in the withdrawal queue.\r\n     * Simply decreases the `podOwner`'s shares by `shares`, down to a minimum of zero.\r\n     * @dev This function reverts if it would result in `podOwnerShares[podOwner]` being less than zero, i.e. it is forbidden for this function to\r\n     * result in the `podOwner` incurring a \"share deficit\". This behavior prevents a Staker from queuing a withdrawal which improperly removes excessive\r\n     * shares from the operator to whom the staker is delegated.\r\n     * @dev Reverts if `shares` is not a whole Gwei amount\r\n     */\r\n    function removeShares(address podOwner, uint256 shares) external;\r\n\r\n    /**\r\n     * @notice Increases the `podOwner`'s shares by `shares`, paying off deficit if possible.\r\n     * Used by the DelegationManager to award a pod owner shares on exiting the withdrawal queue\r\n     * @dev Returns the number of shares added to `podOwnerShares[podOwner]` above zero, which will be less than the `shares` input\r\n     * in the event that the podOwner has an existing shares deficit (i.e. `podOwnerShares[podOwner]` starts below zero)\r\n     * @dev Reverts if `shares` is not a whole Gwei amount\r\n     */\r\n    function addShares(address podOwner, uint256 shares) external returns (uint256);\r\n\r\n    /**\r\n     * @notice Used by the DelegationManager to complete a withdrawal, sending tokens to some destination address\r\n     * @dev Prioritizes decreasing the podOwner's share deficit, if they have one\r\n     * @dev Reverts if `shares` is not a whole Gwei amount\r\n     */\r\n    function withdrawSharesAsTokens(address podOwner, address destination, uint256 shares) external;\r\n\r\n    /**\r\n     * @notice the deneb hard fork timestamp used to determine which proof path to use for proving a withdrawal\r\n     */\r\n    function denebForkTimestamp() external view returns (uint64);\r\n\r\n     /**\r\n     * setting the deneb hard fork timestamp by the eigenPodManager owner\r\n     * @dev this function is designed to be called twice.  Once, it is set to type(uint64).max \r\n     * prior to the actual deneb fork timestamp being set, and then the second time it is set \r\n     * to the actual deneb fork timestamp.\r\n     */\r\n    function setDenebForkTimestamp(uint64 newDenebForkTimestamp) external;\r\n\r\n}\r\n"},"contracts/vendors/contracts/interfaces/IPauserRegistry.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity >=0.5.0;\r\n\r\n/**\r\n * @title Interface for the `PauserRegistry` contract.\r\n * @author Layr Labs, Inc.\r\n * @notice Terms of Service: https://docs.eigenlayer.xyz/overview/terms-of-service\r\n */\r\ninterface IPauserRegistry {\r\n    event PauserStatusChanged(address pauser, bool canPause);\r\n\r\n    event UnpauserChanged(address previousUnpauser, address newUnpauser);\r\n    \r\n    /// @notice Mapping of addresses to whether they hold the pauser role.\r\n    function isPauser(address pauser) external view returns (bool);\r\n\r\n    /// @notice Unique address that holds the unpauser role. Capable of changing *both* the pauser and unpauser addresses.\r\n    function unpauser() external view returns (address);\r\n}\r\n"},"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"},"@prb/math/src/ud60x18/Helpers.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport { unwrap, wrap } from \"./Casting.sol\";\nimport { UD60x18 } from \"./ValueType.sol\";\n\n/// @notice Implements the checked addition operation (+) in the UD60x18 type.\nfunction add(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\n    result = wrap(unwrap(x) + unwrap(y));\n}\n\n/// @notice Implements the AND (&) bitwise operation in the UD60x18 type.\nfunction and(UD60x18 x, uint256 bits) pure returns (UD60x18 result) {\n    result = wrap(unwrap(x) & bits);\n}\n\n/// @notice Implements the equal operation (==) in the UD60x18 type.\nfunction eq(UD60x18 x, UD60x18 y) pure returns (bool result) {\n    result = unwrap(x) == unwrap(y);\n}\n\n/// @notice Implements the greater than operation (>) in the UD60x18 type.\nfunction gt(UD60x18 x, UD60x18 y) pure returns (bool result) {\n    result = unwrap(x) > unwrap(y);\n}\n\n/// @notice Implements the greater than or equal to operation (>=) in the UD60x18 type.\nfunction gte(UD60x18 x, UD60x18 y) pure returns (bool result) {\n    result = unwrap(x) >= unwrap(y);\n}\n\n/// @notice Implements a zero comparison check function in the UD60x18 type.\nfunction isZero(UD60x18 x) pure returns (bool result) {\n    // This wouldn't work if x could be negative.\n    result = unwrap(x) == 0;\n}\n\n/// @notice Implements the left shift operation (<<) in the UD60x18 type.\nfunction lshift(UD60x18 x, uint256 bits) pure returns (UD60x18 result) {\n    result = wrap(unwrap(x) << bits);\n}\n\n/// @notice Implements the lower than operation (<) in the UD60x18 type.\nfunction lt(UD60x18 x, UD60x18 y) pure returns (bool result) {\n    result = unwrap(x) < unwrap(y);\n}\n\n/// @notice Implements the lower than or equal to operation (<=) in the UD60x18 type.\nfunction lte(UD60x18 x, UD60x18 y) pure returns (bool result) {\n    result = unwrap(x) <= unwrap(y);\n}\n\n/// @notice Implements the checked modulo operation (%) in the UD60x18 type.\nfunction mod(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\n    result = wrap(unwrap(x) % unwrap(y));\n}\n\n/// @notice Implements the not equal operation (!=) in the UD60x18 type\nfunction neq(UD60x18 x, UD60x18 y) pure returns (bool result) {\n    result = unwrap(x) != unwrap(y);\n}\n\n/// @notice Implements the OR (|) bitwise operation in the UD60x18 type.\nfunction or(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\n    result = wrap(unwrap(x) | unwrap(y));\n}\n\n/// @notice Implements the right shift operation (>>) in the UD60x18 type.\nfunction rshift(UD60x18 x, uint256 bits) pure returns (UD60x18 result) {\n    result = wrap(unwrap(x) >> bits);\n}\n\n/// @notice Implements the checked subtraction operation (-) in the UD60x18 type.\nfunction sub(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\n    result = wrap(unwrap(x) - unwrap(y));\n}\n\n/// @notice Implements the unchecked addition operation (+) in the UD60x18 type.\nfunction uncheckedAdd(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\n    unchecked {\n        result = wrap(unwrap(x) + unwrap(y));\n    }\n}\n\n/// @notice Implements the unchecked subtraction operation (-) in the UD60x18 type.\nfunction uncheckedSub(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\n    unchecked {\n        result = wrap(unwrap(x) - unwrap(y));\n    }\n}\n\n/// @notice Implements the XOR (^) bitwise operation in the UD60x18 type.\nfunction xor(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\n    result = wrap(unwrap(x) ^ unwrap(y));\n}\n"},"contracts/interfaces/IDepositManager.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.16;\r\n\r\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport {INodeOperatorRegistry} from \"./INodeOperatorRegistry.sol\";\r\nimport {IEigenLayerManager} from \"./IEigenLayerManager.sol\";\r\n\r\n/**\r\n * @title IDepositManager\r\n * @notice The interface for the deposit manager contract\r\n */\r\ninterface IDepositManager {\r\n  // ***** Errors ******\r\n  /**\r\n   * @dev Error thrown when delegating to an operator who is not registered correctly for EigenLayer\r\n   */\r\n  error OperatorNotVerified();\r\n\r\n  /**\r\n   * @dev Error thrown when calling the withdrawETH method from an account that isn't the rswETH contract\r\n   */\r\n  error InvalidETHWithdrawCaller();\r\n\r\n  /**\r\n   * @dev Error thrown when the depositDataRoot parameter in the setupValidators contract doesn't match the onchain deposit data root from the deposit contract\r\n   */\r\n  error InvalidDepositDataRoot();\r\n\r\n  /**\r\n   * @dev Error thrown when setting up new validators and the contract doesn't hold enough ETH to be able to set them up.\r\n   */\r\n  error InsufficientETHBalance();\r\n\r\n  /**\r\n   * @dev Error thrown when the transferETHForWithdrawRequests method is called from an account other than rswEXIT\r\n   */\r\n  error OnlyRswEXITCanWithdrawETH();\r\n\r\n  /**\r\n   * @dev Error thrown when the transferETHForEigenLayerDeposits method is called from an account other than the EigenLayerManager\r\n   */\r\n  error OnlyEigenLayerManagerCanWithdrawETH();\r\n\r\n  /**\r\n   * @dev Error thrown when the transferTokenForDepositIntoStrategy method is called from an account other than the EigenLayerManager\r\n   * @notice This method can only be called by the EigenLayerManager contract\r\n   */\r\n  error OnlyEigenLayerManagerCanWithdrawTokens();\r\n\r\n  /**\r\n   * @dev Error thrown when the admin has not set a LST Rate Provider\r\n   */\r\n  error NoRateProviderSet();\r\n\r\n  /**\r\n   * @dev Error thrown when a user tries to deposit an amount of zero\r\n   */\r\n  error CannotDepositZero();\r\n\r\n  /**\r\n   * @dev Error thrown when no public keys have been provided for validator setup\r\n   */\r\n  error NoPubKeysProvided();\r\n\r\n  /**\r\n   * @dev Error thrown when the EigenPod has not been created\r\n   */\r\n  error EigenPodNotCreated();\r\n\r\n  // ***** Events ******\r\n  /**\r\n   * Emitted when new validators are setup\r\n   * @param pubKeys The pubKeys that have been used for validator setup\r\n   */\r\n  event ValidatorsSetup(bytes[] pubKeys);\r\n\r\n  /**\r\n   * @dev Event is fired when some contracts receive ETH\r\n   * @param from The account that sent the ETH\r\n   * @param amount The amount of ETH received\r\n   */\r\n  event ETHReceived(address indexed from, uint256 amount);\r\n\r\n  /**\r\n   * @dev Event fired when the admin succesfully sets an exchange rate provider\r\n   * @param token The address of the LST for which the exchange rate provider provides a rate\r\n   * @param exchangeRateProvider The address of the exchange rate provider contract\r\n   */\r\n  event ExchangeRateProviderSet(\r\n    address indexed token,\r\n    address indexed exchangeRateProvider\r\n  );\r\n\r\n  /**\r\n   * @dev Event is fired when the DepositManager sends ETH, this will currently only happen when rswEXIT calls transferETHForWithdrawRequests to get ETH for fulfill withdraw requests\r\n   * @param to The account that is receiving the ETH\r\n   * @param amount The amount of ETH sent\r\n   */\r\n  event EthSent(address indexed to, uint256 amount);\r\n\r\n  /**\r\n   * @dev Event fired when a user succesfully deposits an LST's into the Swell Deposit Manager\r\n   * @param token The address of the LST deposited\r\n   * @param tokenAmount The amount of the LST deposited\r\n   */\r\n  event LSTDeposited(address indexed token, uint256 tokenAmount);\r\n\r\n  /**\r\n   * @dev Event fired when the admin succesfully sets the EigenLayerManager contract\r\n   * @param eigenLayerManager The address of the EigenLayerManager contract\r\n   */\r\n  event EigenLayerManagerSet(address eigenLayerManager);\r\n\r\n  // ************************************\r\n\r\n  // ***** External methods ******\r\n\r\n\r\n  /**\r\n   * @return The address of the EigenLayerManager contract\r\n   */\r\n  function eigenLayerManager() external view returns (IEigenLayerManager);\r\n\r\n  /**\r\n   * @dev Allows the admin to set the EigenLayer staking admin contract\r\n   * @param _eigenLayerManager The address of the EigenLayerManager contract\r\n   * @notice This method can only be called by the admin\r\n   */\r\n  function setEigenLayerManager(address _eigenLayerManager) external;\r\n  \r\n  /**\r\n   * @dev This method is called by rswEXIT when it needs ETH to fulfill withdraw requests\r\n   * @param _amount The amount of ETH to transfer to rswEXIT\r\n   */\r\n  function transferETHForWithdrawRequests(uint256 _amount) external;\r\n\r\n  /**\r\n   * @dev This method is called by the EigenLayerManager contract when it needs ETH to fulfill deposit requests onto EigenLayer\r\n   * @param _pubKeys An array of public keys for operators registered on the Swell Network\r\n   * @param _depositDataRoot The deposit data root\r\n   * @return An array of ValidatorDetails\r\n   */\r\n  function transferETHForEigenLayerDeposits(\r\n    bytes[] calldata _pubKeys,\r\n    bytes32 _depositDataRoot\r\n  ) external returns (INodeOperatorRegistry.ValidatorDetails[] memory);\r\n\r\n  /**\r\n   * @dev This method is called by the EigenLayerManager contract when it needs to transfer tokens to a StakerProxy to deposit into a strategy\r\n   * @param _token The ERC20 token to transfer\r\n   * @param _amount The amount of tokens to transfer\r\n   * @param _stakerProxyAddress The address of the staker proxy contract who will receive the tokens to deposit\r\n   */\r\n  function transferTokenForDepositIntoStrategy(\r\n    address _token,\r\n    uint256 _amount,\r\n    address _stakerProxyAddress\r\n  ) external;\r\n\r\n  /**\r\n   * @dev This method withdraws the Deposit Manager contract's _token balance to a platform admin\r\n   * @param _token The ERC20 token to withdraw from the contract\r\n   */\r\n  function withdrawERC20(IERC20 _token) external;\r\n\r\n  /**\r\n   * @dev Allows Users to Deposit liquid staking tokens into Swell Deposit Manager.\r\n   * @param _token The LST token address.\r\n   * @param _amount The amount of LST to deposit.\r\n   * @param _minRswETH The minimum amount of RswETH to receive for the LST deposited.\r\n   */\r\n  function depositLST(address _token, uint256 _amount, uint256 _minRswETH) external;\r\n}\r\n"},"contracts/interfaces/IrswEXIT.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.16;\r\n\r\nimport {IERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\r\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\n/**\r\n * @title RswEXIT Interface\r\n * @dev This interface provides the methods to interact with the SwEXIT contract.\r\n */\r\ninterface IrswEXIT is IERC721Upgradeable {\r\n  /**\r\n   * @dev Struct representing a withdrawal request.\r\n   * @param timestamp The timestamp of the withdrawal request.\r\n   * @param amount The amount of RswETH that was requested to be withdrawn.\r\n   * @param lastTokenIdProcessed The last token ID processed when the withdraw request was created, required later on when fetching the rates.\r\n   * @param rateWhenCreated The rate when the withdrawal request was created.\r\n   */\r\n  struct WithdrawRequest {\r\n    uint256 amount;\r\n    uint256 lastTokenIdProcessed;\r\n    uint256 rateWhenCreated;\r\n  }\r\n\r\n  /**\r\n   * @dev Thrown when the withdrawal request is too large\r\n   * @param amount The withdrawal request amount.\r\n   * @param limit The withdrawal request limit.\r\n   */\r\n  error WithdrawRequestTooLarge(uint256 amount, uint256 limit);\r\n\r\n  /**\r\n   * @dev Thrown when the withdrawal request amount is less than the minimum.\r\n   * @param amount The withdrawal request amount.\r\n   * @param minimum The withdrawal request minimum.\r\n   */\r\n  error WithdrawRequestTooSmall(uint256 amount, uint256 minimum);\r\n\r\n  /**\r\n   * @dev Thrown when trying to claim withdrawals for a token that doesn't exist\r\n   */\r\n  error WithdrawalRequestDoesNotExist();\r\n\r\n  /**\r\n   * @dev Thrown when trying to claim withdrawals and the requested token has not been processed.\r\n   */\r\n  error WithdrawalRequestNotProcessed();\r\n\r\n  /**\r\n   * @dev Thrown when processing withdrawals and the provided _lastRequestIdToProcess hasn't been minted\r\n   */\r\n  error CannotProcessWithdrawalsForNonExistentToken();\r\n\r\n  /**\r\n   * @dev Thrown when processing withdrawals and the provided _lastRequestIdToProcess is less than the previous token ID processed\r\n   */\r\n  error LastTokenIdToProcessMustBeGreaterOrEqualThanPrevious();\r\n\r\n  /**\r\n   * @dev Thrown when calling a withdrawal method and the withdrawals are paused.\r\n   */\r\n  error WithdrawalsPaused();\r\n\r\n  /**\r\n   * @dev Thrown when trying to update the withdrawal request minimum to be less than the withdrawal request maximum.\r\n   */\r\n  error WithdrawRequestMinimumMustBeLessOrEqualToMaximum();\r\n\r\n  /**\r\n   * @dev Thrown when trying to update the withdrawal request maximum to be less than the withdrawal request minimum.\r\n   */\r\n  error WithdrawRequestMaximumMustBeGreaterOrEqualToMinimum();\r\n\r\n  /**\r\n   * @dev Thrown when anyone except the owner tries to finalize a withdrawal request\r\n   */\r\n  error WithdrawalRequestFinalizationOnlyAllowedForNFTOwner();\r\n\r\n  /**\r\n   * @dev Emitted when the base URI is updated.\r\n   * @param oldBaseURI The old base URI.\r\n   * @param newBaseURI The new base URI.\r\n   */\r\n  event BaseURIUpdated(string oldBaseURI, string newBaseURI);\r\n\r\n  /**\r\n   * @dev Emitted when a withdrawal request is created.\r\n   * @param tokenId The token ID of the withdrawal request.\r\n   * @param amount The amount of RswETH to withdraw.\r\n   * @param timestamp The timestamp of the withdrawal request.\r\n   * @param lastTokenIdProcessed The last token ID processed, required later on when fetching the rates.\r\n   * @param rateWhenCreated The rate when the withdrawal request was created.\r\n   * @param owner The owner of the withdrawal request.\r\n   */\r\n  event WithdrawRequestCreated(\r\n    uint256 tokenId,\r\n    uint256 amount,\r\n    uint256 timestamp,\r\n    uint256 indexed lastTokenIdProcessed,\r\n    uint256 rateWhenCreated,\r\n    address indexed owner\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted when a withdrawal request is claimed.\r\n   * @param owner The owner of the withdrawal request.\r\n   * @param tokenId The token ID of the withdrawal request.\r\n   * @param exitClaimedETH The amount of ETH the owner received.\r\n   */\r\n  event WithdrawalClaimed(\r\n    address indexed owner,\r\n    uint256 tokenId,\r\n    uint256 exitClaimedETH\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted when withdrawals are processed.\r\n   * @param fromTokenId The first token ID to process.\r\n   * @param toTokenId The last token ID to process.\r\n   * @param processedRate The rate that the withdrawal requests were processed at, not the finalised rate when claiming just the processed rate\r\n   * @param processedExitingETH The amount of exiting ETH accumulated when processing withdrawals.\r\n   * @param processedExitedETH The amount of exited ETH accumulated when processing withdrawals.\r\n   */\r\n  event WithdrawalsProcessed(\r\n    uint256 fromTokenId,\r\n    uint256 toTokenId,\r\n    uint256 processedRate,\r\n    uint256 processedExitingETH,\r\n    uint256 processedExitedETH\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted when the withdrawal request limit is updated.\r\n   * @param oldLimit The old withdrawal request limit.\r\n   * @param newLimit The new withdrawal request limit.\r\n   */\r\n  event WithdrawalRequestMaximumUpdated(uint256 oldLimit, uint256 newLimit);\r\n\r\n  /**\r\n   * @dev Emitted when the withdrawal request minimum is updated.\r\n   * @param oldMinimum The old withdrawal request minimum.\r\n   * @param newMinimum The new withdrawal request minimum.\r\n   */\r\n  event WithdrawalRequestMinimumUpdated(uint256 oldMinimum, uint256 newMinimum);\r\n\r\n  /**\r\n   * @dev Emitted when ETH is received.\r\n   * @param sender The sender of the ETH.\r\n   * @param amount The amount of ETH received.\r\n   */\r\n  event ETHReceived(address indexed sender, uint256 amount);\r\n\r\n  /**\r\n   * @dev Returns the base URI.\r\n   */\r\n  function baseURI() external view returns (string memory);\r\n\r\n  /**\r\n   * @dev This method withdraws contract's _token balance to a platform admin\r\n   * @param _token The ERC20 token to withdraw from the contract\r\n   */\r\n  function withdrawERC20(IERC20 _token) external;\r\n\r\n  /**\r\n   * @dev Returns the withdrawal request maximum size.\r\n   * @return The withdrawal request maximum size.\r\n   */\r\n  function withdrawRequestMaximum() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the withdrawal request minimum.\r\n   * @return The withdrawal request minimum.\r\n   */\r\n  function withdrawRequestMinimum() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the amount of exiting ETH, which is has not yet been processed for withdrawals.\r\n   * @dev This value is increased by new withdrawal requests and decreased when withdrawals are processed.\r\n   * @dev The amount is given by (amount * rate when requested), where amount is the amount of withdrawn rswETH.\r\n   * @return The current amount of exiting ETH.\r\n   */\r\n  function exitingETH() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the total amount of exited ETH to date. Exited ETH is ETH that was processed in a withdrawal request.\r\n   * @dev When ETH is processed in a withdrawal request, the amount of exited ETH is given by (amount * finalRate), where finalRate is the lesser of the rate when requested and the processed rate, and amount is the amount of withdrawn rswETH.\r\n   * @return The exited ETH.\r\n   */\r\n  function totalETHExited() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Allows the platform admin to update the base URI.\r\n   * @param _baseURI The new base URI.\r\n   */\r\n  function setBaseURI(string memory _baseURI) external;\r\n\r\n  /**\r\n   * @dev Allows the platform admin to update the withdrawal request maximum.\r\n   * @param _withdrawRequestMaximum The new withdrawal request maximum.\r\n   */\r\n  function setWithdrawRequestMaximum(uint256 _withdrawRequestMaximum) external;\r\n\r\n  /**\r\n   * @dev Allows the platform admin to update the withdrawal request minimum.\r\n   * @param _withdrawRequestMinimum The new withdrawal request minimum.\r\n   */\r\n  function setWithdrawRequestMinimum(uint256 _withdrawRequestMinimum) external;\r\n\r\n  /**\r\n   * @dev Processes withdrawals for a given range of token IDs.\r\n   * @param _lastTokenIdToProcess The last token Id to process.\r\n   */\r\n  function processWithdrawals(uint256 _lastTokenIdToProcess) external;\r\n\r\n  /**\r\n   * @dev Creates a new withdrawal request.\r\n   * @param amount The amount of RswETH to withdraw.\r\n   */\r\n  function createWithdrawRequest(uint256 amount) external;\r\n\r\n  /**\r\n   * @dev Finalizes a withdrawal request, sending the ETH to the owner of the request. This is callable by anyone.\r\n   * @param tokenId The token ID of the withdrawal request to claim.\r\n   */\r\n  function finalizeWithdrawal(uint256 tokenId) external;\r\n\r\n  /**\r\n   * @dev Checks if the provided token ID has been processed and returns the rate it was processed at. NOTE: This isn't the final rate that the user will receive, it's just the rate that the withdrawal request was processed at.\r\n   * @param tokenId The token ID to check.\r\n   * @return isProcessed A boolean indicating whether or not the token ID has been processed.\r\n   * @return processedRate The processed rate for the given token ID.\r\n   */\r\n  function getProcessedRateForTokenId(\r\n    uint256 tokenId\r\n  ) external view returns (bool isProcessed, uint256 processedRate);\r\n\r\n  /**\r\n   * @dev Returns the last token ID that was processed.\r\n   * @return The last token ID processed.\r\n   */\r\n  function getLastTokenIdProcessed() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the last token ID that was created.\r\n   * @return The last token ID created.\r\n   */\r\n  function getLastTokenIdCreated() external view returns (uint256);\r\n}\r\n"},"@prb/math/src/sd1x18/Constants.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport { SD1x18 } from \"./ValueType.sol\";\n\n/// @dev Euler's number as an SD1x18 number.\nSD1x18 constant E = SD1x18.wrap(2_718281828459045235);\n\n/// @dev The maximum value an SD1x18 number can have.\nint64 constant uMAX_SD1x18 = 9_223372036854775807;\nSD1x18 constant MAX_SD1x18 = SD1x18.wrap(uMAX_SD1x18);\n\n/// @dev The maximum value an SD1x18 number can have.\nint64 constant uMIN_SD1x18 = -9_223372036854775808;\nSD1x18 constant MIN_SD1x18 = SD1x18.wrap(uMIN_SD1x18);\n\n/// @dev PI as an SD1x18 number.\nSD1x18 constant PI = SD1x18.wrap(3_141592653589793238);\n\n/// @dev The unit amount that implies how many trailing decimals can be represented.\nSD1x18 constant UNIT = SD1x18.wrap(1e18);\nint256 constant uUNIT = 1e18;\n"},"@prb/math/src/ud2x18/ValueType.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport \"./Casting.sol\" as C;\n\n/// @notice The unsigned 2.18-decimal fixed-point number representation, which can have up to 2 digits and up to 18 decimals.\n/// The values of this are bound by the minimum and the maximum values permitted by the underlying Solidity type uint64.\n/// This is useful when end users want to use uint64 to save gas, e.g. with tight variable packing in contract storage.\ntype UD2x18 is uint64;\n\n/*//////////////////////////////////////////////////////////////////////////\n                                    CASTING\n//////////////////////////////////////////////////////////////////////////*/\n\nusing { C.intoSD1x18, C.intoSD59x18, C.intoUD60x18, C.intoUint256, C.intoUint128, C.intoUint40, C.unwrap } for UD2x18 global;\n"},"contracts/vendors/contracts/interfaces/IETHPOSDeposit.sol":{"content":"// ┏━━━┓━┏┓━┏┓━━┏━━━┓━━┏━━━┓━━━━┏━━━┓━━━━━━━━━━━━━━━━━━━┏┓━━━━━┏━━━┓━━━━━━━━━┏┓━━━━━━━━━━━━━━┏┓━\r\n// ┃┏━━┛┏┛┗┓┃┃━━┃┏━┓┃━━┃┏━┓┃━━━━┗┓┏┓┃━━━━━━━━━━━━━━━━━━┏┛┗┓━━━━┃┏━┓┃━━━━━━━━┏┛┗┓━━━━━━━━━━━━┏┛┗┓\r\n// ┃┗━━┓┗┓┏┛┃┗━┓┗┛┏┛┃━━┃┃━┃┃━━━━━┃┃┃┃┏━━┓┏━━┓┏━━┓┏━━┓┏┓┗┓┏┛━━━━┃┃━┗┛┏━━┓┏━┓━┗┓┏┛┏━┓┏━━┓━┏━━┓┗┓┏┛\r\n// ┃┏━━┛━┃┃━┃┏┓┃┏━┛┏┛━━┃┃━┃┃━━━━━┃┃┃┃┃┏┓┃┃┏┓┃┃┏┓┃┃━━┫┣┫━┃┃━━━━━┃┃━┏┓┃┏┓┃┃┏┓┓━┃┃━┃┏┛┗━┓┃━┃┏━┛━┃┃━\r\n// ┃┗━━┓━┃┗┓┃┃┃┃┃┃┗━┓┏┓┃┗━┛┃━━━━┏┛┗┛┃┃┃━┫┃┗┛┃┃┗┛┃┣━━┃┃┃━┃┗┓━━━━┃┗━┛┃┃┗┛┃┃┃┃┃━┃┗┓┃┃━┃┗┛┗┓┃┗━┓━┃┗┓\r\n// ┗━━━┛━┗━┛┗┛┗┛┗━━━┛┗┛┗━━━┛━━━━┗━━━┛┗━━┛┃┏━┛┗━━┛┗━━┛┗┛━┗━┛━━━━┗━━━┛┗━━┛┗┛┗┛━┗━┛┗┛━┗━━━┛┗━━┛━┗━┛\r\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┃┃━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\r\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┗┛━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\r\n\r\n// SPDX-License-Identifier: CC0-1.0\r\n\r\npragma solidity >=0.5.0;\r\n\r\n// This interface is designed to be compatible with the Vyper version.\r\n/// @notice This is the Ethereum 2.0 deposit contract interface.\r\n/// For more information see the Phase 0 specification under https://github.com/ethereum/eth2.0-specs\r\ninterface IETHPOSDeposit {\r\n    /// @notice A processed deposit event.\r\n    event DepositEvent(bytes pubkey, bytes withdrawal_credentials, bytes amount, bytes signature, bytes index);\r\n\r\n    /// @notice Submit a Phase 0 DepositData object.\r\n    /// @param pubkey A BLS12-381 public key.\r\n    /// @param withdrawal_credentials Commitment to a public key for withdrawals.\r\n    /// @param signature A BLS12-381 signature.\r\n    /// @param deposit_data_root The SHA-256 hash of the SSZ-encoded DepositData object.\r\n    /// Used as a protection against malformed input.\r\n    function deposit(\r\n        bytes calldata pubkey,\r\n        bytes calldata withdrawal_credentials,\r\n        bytes calldata signature,\r\n        bytes32 deposit_data_root\r\n    ) external payable;\r\n\r\n    /// @notice Query the current deposit root hash.\r\n    /// @return The deposit root hash.\r\n    function get_deposit_root() external view returns (bytes32);\r\n\r\n    /// @notice Query the current deposit count.\r\n    /// @return The deposit count encoded as a little endian 64-bit number.\r\n    function get_deposit_count() external view returns (bytes memory);\r\n}\r\n"},"contracts/vendors/contracts/libraries/Merkle.sol":{"content":"// SPDX-License-Identifier: MIT\r\n// Adapted from OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/MerkleProof.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev These functions deal with verification of Merkle Tree proofs.\r\n *\r\n * The tree and the proofs can be generated using our\r\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\r\n * You will find a quickstart guide in the readme.\r\n *\r\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\r\n * hashing, or use a hash function other than keccak256 for hashing leaves.\r\n * This is because the concatenation of a sorted pair of internal nodes in\r\n * the merkle tree could be reinterpreted as a leaf value.\r\n * OpenZeppelin's JavaScript library generates merkle trees that are safe\r\n * against this attack out of the box.\r\n */\r\nlibrary Merkle {\r\n    /**\r\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\r\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\r\n     * hash matches the root of the tree. The tree is built assuming `leaf` is\r\n     * the 0 indexed `index`'th leaf from the bottom left of the tree.\r\n     *\r\n     * Note this is for a Merkle tree using the keccak/sha3 hash function\r\n     */\r\n    function verifyInclusionKeccak(\r\n        bytes memory proof,\r\n        bytes32 root,\r\n        bytes32 leaf,\r\n        uint256 index\r\n    ) internal pure returns (bool) {\r\n        return processInclusionProofKeccak(proof, leaf, index) == root;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\r\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\r\n     * hash matches the root of the tree. The tree is built assuming `leaf` is\r\n     * the 0 indexed `index`'th leaf from the bottom left of the tree.\r\n     *\r\n     * _Available since v4.4._\r\n     *\r\n     * Note this is for a Merkle tree using the keccak/sha3 hash function\r\n     */\r\n    function processInclusionProofKeccak(\r\n        bytes memory proof,\r\n        bytes32 leaf,\r\n        uint256 index\r\n    ) internal pure returns (bytes32) {\r\n        require(\r\n            proof.length != 0 && proof.length % 32 == 0,\r\n            \"Merkle.processInclusionProofKeccak: proof length should be a non-zero multiple of 32\"\r\n        );\r\n        bytes32 computedHash = leaf;\r\n        for (uint256 i = 32; i <= proof.length; i += 32) {\r\n            if (index % 2 == 0) {\r\n                // if ith bit of index is 0, then computedHash is a left sibling\r\n                assembly {\r\n                    mstore(0x00, computedHash)\r\n                    mstore(0x20, mload(add(proof, i)))\r\n                    computedHash := keccak256(0x00, 0x40)\r\n                    index := div(index, 2)\r\n                }\r\n            } else {\r\n                // if ith bit of index is 1, then computedHash is a right sibling\r\n                assembly {\r\n                    mstore(0x00, mload(add(proof, i)))\r\n                    mstore(0x20, computedHash)\r\n                    computedHash := keccak256(0x00, 0x40)\r\n                    index := div(index, 2)\r\n                }\r\n            }\r\n        }\r\n        return computedHash;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\r\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\r\n     * hash matches the root of the tree. The tree is built assuming `leaf` is\r\n     * the 0 indexed `index`'th leaf from the bottom left of the tree.\r\n     *\r\n     * Note this is for a Merkle tree using the sha256 hash function\r\n     */\r\n    function verifyInclusionSha256(\r\n        bytes memory proof,\r\n        bytes32 root,\r\n        bytes32 leaf,\r\n        uint256 index\r\n    ) internal view returns (bool) {\r\n        return processInclusionProofSha256(proof, leaf, index) == root;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\r\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\r\n     * hash matches the root of the tree. The tree is built assuming `leaf` is\r\n     * the 0 indexed `index`'th leaf from the bottom left of the tree.\r\n     *\r\n     * _Available since v4.4._\r\n     *\r\n     * Note this is for a Merkle tree using the sha256 hash function\r\n     */\r\n    function processInclusionProofSha256(\r\n        bytes memory proof,\r\n        bytes32 leaf,\r\n        uint256 index\r\n    ) internal view returns (bytes32) {\r\n        require(\r\n            proof.length != 0 && proof.length % 32 == 0,\r\n            \"Merkle.processInclusionProofSha256: proof length should be a non-zero multiple of 32\"\r\n        );\r\n        bytes32[1] memory computedHash = [leaf];\r\n        for (uint256 i = 32; i <= proof.length; i += 32) {\r\n            if (index % 2 == 0) {\r\n                // if ith bit of index is 0, then computedHash is a left sibling\r\n                assembly {\r\n                    mstore(0x00, mload(computedHash))\r\n                    mstore(0x20, mload(add(proof, i)))\r\n                    if iszero(staticcall(sub(gas(), 2000), 2, 0x00, 0x40, computedHash, 0x20)) {\r\n                        revert(0, 0)\r\n                    }\r\n                    index := div(index, 2)\r\n                }\r\n            } else {\r\n                // if ith bit of index is 1, then computedHash is a right sibling\r\n                assembly {\r\n                    mstore(0x00, mload(add(proof, i)))\r\n                    mstore(0x20, mload(computedHash))\r\n                    if iszero(staticcall(sub(gas(), 2000), 2, 0x00, 0x40, computedHash, 0x20)) {\r\n                        revert(0, 0)\r\n                    }\r\n                    index := div(index, 2)\r\n                }\r\n            }\r\n        }\r\n        return computedHash[0];\r\n    }\r\n\r\n    /**\r\n     @notice this function returns the merkle root of a tree created from a set of leaves using sha256 as its hash function\r\n     @param leaves the leaves of the merkle tree\r\n     @return The computed Merkle root of the tree.\r\n     @dev A pre-condition to this function is that leaves.length is a power of two.  If not, the function will merkleize the inputs incorrectly.\r\n     */\r\n    function merkleizeSha256(bytes32[] memory leaves) internal pure returns (bytes32) {\r\n        //there are half as many nodes in the layer above the leaves\r\n        uint256 numNodesInLayer = leaves.length / 2;\r\n        //create a layer to store the internal nodes\r\n        bytes32[] memory layer = new bytes32[](numNodesInLayer);\r\n        //fill the layer with the pairwise hashes of the leaves\r\n        for (uint256 i = 0; i < numNodesInLayer; i++) {\r\n            layer[i] = sha256(abi.encodePacked(leaves[2 * i], leaves[2 * i + 1]));\r\n        }\r\n        //the next layer above has half as many nodes\r\n        numNodesInLayer /= 2;\r\n        //while we haven't computed the root\r\n        while (numNodesInLayer != 0) {\r\n            //overwrite the first numNodesInLayer nodes in layer with the pairwise hashes of their children\r\n            for (uint256 i = 0; i < numNodesInLayer; i++) {\r\n                layer[i] = sha256(abi.encodePacked(layer[2 * i], layer[2 * i + 1]));\r\n            }\r\n            //the next layer above has half as many nodes\r\n            numNodesInLayer /= 2;\r\n        }\r\n        //the first node in the layer is the root\r\n        return layer[0];\r\n    }\r\n}\r\n"},"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"}},"settings":{"optimizer":{"enabled":true,"runs":200},"outputSelection":{"*":{"*":["evm.bytecode","evm.deployedBytecode","devdoc","userdoc","metadata","abi"]}},"metadata":{"useLiteralContent":true},"libraries":{}}},"ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"AddressAlreadyInWhitelist\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"AddressMissingFromWhitelist\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CannotBeZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CannotBurnZeroRswETH\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CannotReferSelf\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CannotRepriceWithZeroRswETHSupply\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CoreMethodsPaused\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rswETHAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minRswETH\",\"type\":\"uint256\"}],\"name\":\"InsufficientRswETHReceived\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidETHDeposit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidMethodCall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidPreRewardETHReserves\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoTokensToWithdraw\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"remainingTime\",\"type\":\"uint256\"}],\"name\":\"NotEnoughTimeElapsedForReprice\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotInWhitelist\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyDepositManager\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"PRBMath_MulDiv18_Overflow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"denominator\",\"type\":\"uint256\"}],\"name\":\"PRBMath_MulDiv_Overflow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"repriceDiff\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumRepriceDiff\",\"type\":\"uint256\"}],\"name\":\"RepriceDifferenceTooLarge\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"repriceRswETHDiff\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumRswETHRepriceDiff\",\"type\":\"uint256\"}],\"name\":\"RepriceRswETHDifferenceTooLarge\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RewardPercentageTotalOverflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WhitelistAlreadyDisabled\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WhitelistAlreadyEnabled\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"AddedToWhitelist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_ethSpent\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_rswETHReceived\",\"type\":\"uint256\"}],\"name\":\"DepoistManagerDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rswETHMinted\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newTotalETHDeposited\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"}],\"name\":\"ETHDepositReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rswETHBurned\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethReturned\",\"type\":\"uint256\"}],\"name\":\"ETHWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_oldMaximumRepriceDifferencePercentage\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_newMaximumRepriceDifferencePercentage\",\"type\":\"uint256\"}],\"name\":\"MaximumRepriceDifferencePercentageUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_oldMaximumRepriceRswETHDifferencePercentage\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_newMaximumRepriceRswETHDifferencePercentage\",\"type\":\"uint256\"}],\"name\":\"MaximumRepriceRswETHDifferencePercentageUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_oldMinimumRepriceTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_newMinimumRepriceTime\",\"type\":\"uint256\"}],\"name\":\"MinimumRepriceTimeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldPercentage\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newPercentage\",\"type\":\"uint256\"}],\"name\":\"NodeOperatorRewardPercentageUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"RemovedFromWhitelist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newEthReserves\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newRswETHToETHRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nodeOperatorRewards\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"swellTreasuryRewards\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalETHDeposited\",\"type\":\"uint256\"}],\"name\":\"Reprice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldPercentage\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newPercentage\",\"type\":\"uint256\"}],\"name\":\"SwellTreasuryRewardPercentageUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"WhitelistDisabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"WhitelistEnabled\",\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"AccessControlManager\",\"outputs\":[{\"internalType\":\"contract IAccessControlManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"addToWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_addresses\",\"type\":\"address[]\"}],\"name\":\"batchAddToWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_addresses\",\"type\":\"address[]\"}],\"name\":\"batchRemoveFromWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_minRswETH\",\"type\":\"uint256\"}],\"name\":\"depositViaDepositManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"}],\"name\":\"depositWithReferral\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ethToRswETHRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IAccessControlManager\",\"name\":\"_accessControlManager\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastRepriceETHReserves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastRepriceUNIX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maximumRepriceDifferencePercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maximumRepriceRswETHDifferencePercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumRepriceTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nodeOperatorRewardPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"removeFromWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_preRewardETHReserves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newETHRewards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rswETHTotalSupply\",\"type\":\"uint256\"}],\"name\":\"reprice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rswETHToETHRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maximumRepriceDifferencePercentage\",\"type\":\"uint256\"}],\"name\":\"setMaximumRepriceDifferencePercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maximumRepriceRswETHDifferencePercentage\",\"type\":\"uint256\"}],\"name\":\"setMaximumRepriceRswETHDifferencePercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minimumRepriceTime\",\"type\":\"uint256\"}],\"name\":\"setMinimumRepriceTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newNodeOperatorRewardPercentage\",\"type\":\"uint256\"}],\"name\":\"setNodeOperatorRewardPercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newSwellTreasuryRewardPercentage\",\"type\":\"uint256\"}],\"name\":\"setSwellTreasuryRewardPercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swellTreasuryRewardPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalETHDeposited\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whitelistEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelistedAddresses\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"withdrawERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"RswETH","CompilerVersion":"v0.8.16+commit.07a7930e","OptimizationUsed":1,"Runs":200,"ConstructorArguments":"0x","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":0,"SwarmSource":""}]}