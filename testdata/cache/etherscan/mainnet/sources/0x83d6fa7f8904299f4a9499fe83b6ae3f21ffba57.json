{"expiry":1725830228,"data":[{"SourceCode":{"language":"Solidity","sources":{"contracts/pendle/contracts/core/libraries/Errors.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\nlibrary Errors {\n    // BulkSeller\n    error BulkInsufficientSyForTrade(uint256 currentAmount, uint256 requiredAmount);\n    error BulkInsufficientTokenForTrade(uint256 currentAmount, uint256 requiredAmount);\n    error BulkInSufficientSyOut(uint256 actualSyOut, uint256 requiredSyOut);\n    error BulkInSufficientTokenOut(uint256 actualTokenOut, uint256 requiredTokenOut);\n    error BulkInsufficientSyReceived(uint256 actualBalance, uint256 requiredBalance);\n    error BulkNotMaintainer();\n    error BulkNotAdmin();\n    error BulkSellerAlreadyExisted(address token, address SY, address bulk);\n    error BulkSellerInvalidToken(address token, address SY);\n    error BulkBadRateTokenToSy(uint256 actualRate, uint256 currentRate, uint256 eps);\n    error BulkBadRateSyToToken(uint256 actualRate, uint256 currentRate, uint256 eps);\n\n    // APPROX\n    error ApproxFail();\n    error ApproxParamsInvalid(uint256 guessMin, uint256 guessMax, uint256 eps);\n    error ApproxBinarySearchInputInvalid(\n        uint256 approxGuessMin,\n        uint256 approxGuessMax,\n        uint256 minGuessMin,\n        uint256 maxGuessMax\n    );\n\n    // MARKET + MARKET MATH CORE\n    error MarketExpired();\n    error MarketZeroAmountsInput();\n    error MarketZeroAmountsOutput();\n    error MarketZeroLnImpliedRate();\n    error MarketInsufficientPtForTrade(int256 currentAmount, int256 requiredAmount);\n    error MarketInsufficientPtReceived(uint256 actualBalance, uint256 requiredBalance);\n    error MarketInsufficientSyReceived(uint256 actualBalance, uint256 requiredBalance);\n    error MarketZeroTotalPtOrTotalAsset(int256 totalPt, int256 totalAsset);\n    error MarketExchangeRateBelowOne(int256 exchangeRate);\n    error MarketProportionMustNotEqualOne();\n    error MarketRateScalarBelowZero(int256 rateScalar);\n    error MarketScalarRootBelowZero(int256 scalarRoot);\n    error MarketProportionTooHigh(int256 proportion, int256 maxProportion);\n\n    error OracleUninitialized();\n    error OracleTargetTooOld(uint32 target, uint32 oldest);\n    error OracleZeroCardinality();\n\n    error MarketFactoryExpiredPt();\n    error MarketFactoryInvalidPt();\n    error MarketFactoryMarketExists();\n\n    error MarketFactoryLnFeeRateRootTooHigh(uint80 lnFeeRateRoot, uint256 maxLnFeeRateRoot);\n    error MarketFactoryOverriddenFeeTooHigh(uint80 overriddenFee, uint256 marketLnFeeRateRoot);\n    error MarketFactoryReserveFeePercentTooHigh(uint8 reserveFeePercent, uint8 maxReserveFeePercent);\n    error MarketFactoryZeroTreasury();\n    error MarketFactoryInitialAnchorTooLow(int256 initialAnchor, int256 minInitialAnchor);\n    error MFNotPendleMarket(address addr);\n\n    // ROUTER\n    error RouterInsufficientLpOut(uint256 actualLpOut, uint256 requiredLpOut);\n    error RouterInsufficientSyOut(uint256 actualSyOut, uint256 requiredSyOut);\n    error RouterInsufficientPtOut(uint256 actualPtOut, uint256 requiredPtOut);\n    error RouterInsufficientYtOut(uint256 actualYtOut, uint256 requiredYtOut);\n    error RouterInsufficientPYOut(uint256 actualPYOut, uint256 requiredPYOut);\n    error RouterInsufficientTokenOut(uint256 actualTokenOut, uint256 requiredTokenOut);\n    error RouterInsufficientSyRepay(uint256 actualSyRepay, uint256 requiredSyRepay);\n    error RouterInsufficientPtRepay(uint256 actualPtRepay, uint256 requiredPtRepay);\n    error RouterNotAllSyUsed(uint256 netSyDesired, uint256 netSyUsed);\n\n    error RouterTimeRangeZero();\n    error RouterCallbackNotPendleMarket(address caller);\n    error RouterInvalidAction(bytes4 selector);\n    error RouterInvalidFacet(address facet);\n\n    error RouterKyberSwapDataZero();\n\n    error SimulationResults(bool success, bytes res);\n\n    // YIELD CONTRACT\n    error YCExpired();\n    error YCNotExpired();\n    error YieldContractInsufficientSy(uint256 actualSy, uint256 requiredSy);\n    error YCNothingToRedeem();\n    error YCPostExpiryDataNotSet();\n    error YCNoFloatingSy();\n\n    // YieldFactory\n    error YCFactoryInvalidExpiry();\n    error YCFactoryYieldContractExisted();\n    error YCFactoryZeroExpiryDivisor();\n    error YCFactoryZeroTreasury();\n    error YCFactoryInterestFeeRateTooHigh(uint256 interestFeeRate, uint256 maxInterestFeeRate);\n    error YCFactoryRewardFeeRateTooHigh(uint256 newRewardFeeRate, uint256 maxRewardFeeRate);\n\n    // SY\n    error SYInvalidTokenIn(address token);\n    error SYInvalidTokenOut(address token);\n    error SYZeroDeposit();\n    error SYZeroRedeem();\n    error SYInsufficientSharesOut(uint256 actualSharesOut, uint256 requiredSharesOut);\n    error SYInsufficientTokenOut(uint256 actualTokenOut, uint256 requiredTokenOut);\n\n    // SY-specific\n    error SYQiTokenMintFailed(uint256 errCode);\n    error SYQiTokenRedeemFailed(uint256 errCode);\n    error SYQiTokenRedeemRewardsFailed(uint256 rewardAccruedType0, uint256 rewardAccruedType1);\n    error SYQiTokenBorrowRateTooHigh(uint256 borrowRate, uint256 borrowRateMax);\n\n    error SYCurveInvalidPid();\n    error SYCurve3crvPoolNotFound();\n\n    error SYApeDepositAmountTooSmall(uint256 amountDeposited);\n    error SYBalancerInvalidPid();\n    error SYInvalidRewardToken(address token);\n\n    error SYStargateRedeemCapExceeded(uint256 amountLpDesired, uint256 amountLpRedeemable);\n\n    error SYBalancerReentrancy();\n\n    error NotFromTrustedRemote(uint16 srcChainId, bytes path);\n\n    error ApxETHNotEnoughBuffer();\n\n    // Liquidity Mining\n    error VCInactivePool(address pool);\n    error VCPoolAlreadyActive(address pool);\n    error VCZeroVePendle(address user);\n    error VCExceededMaxWeight(uint256 totalWeight, uint256 maxWeight);\n    error VCEpochNotFinalized(uint256 wTime);\n    error VCPoolAlreadyAddAndRemoved(address pool);\n\n    error VEInvalidNewExpiry(uint256 newExpiry);\n    error VEExceededMaxLockTime();\n    error VEInsufficientLockTime();\n    error VENotAllowedReduceExpiry();\n    error VEZeroAmountLocked();\n    error VEPositionNotExpired();\n    error VEZeroPosition();\n    error VEZeroSlope(uint128 bias, uint128 slope);\n    error VEReceiveOldSupply(uint256 msgTime);\n\n    error GCNotPendleMarket(address caller);\n    error GCNotVotingController(address caller);\n\n    error InvalidWTime(uint256 wTime);\n    error ExpiryInThePast(uint256 expiry);\n    error ChainNotSupported(uint256 chainId);\n\n    error FDTotalAmountFundedNotMatch(uint256 actualTotalAmount, uint256 expectedTotalAmount);\n    error FDEpochLengthMismatch();\n    error FDInvalidPool(address pool);\n    error FDPoolAlreadyExists(address pool);\n    error FDInvalidNewFinishedEpoch(uint256 oldFinishedEpoch, uint256 newFinishedEpoch);\n    error FDInvalidStartEpoch(uint256 startEpoch);\n    error FDInvalidWTimeFund(uint256 lastFunded, uint256 wTime);\n    error FDFutureFunding(uint256 lastFunded, uint256 currentWTime);\n\n    error BDInvalidEpoch(uint256 epoch, uint256 startTime);\n\n    // Cross-Chain\n    error MsgNotFromSendEndpoint(uint16 srcChainId, bytes path);\n    error MsgNotFromReceiveEndpoint(address sender);\n    error InsufficientFeeToSendMsg(uint256 currentFee, uint256 requiredFee);\n    error ApproxDstExecutionGasNotSet();\n    error InvalidRetryData();\n\n    // GENERIC MSG\n    error ArrayLengthMismatch();\n    error ArrayEmpty();\n    error ArrayOutOfBounds();\n    error ZeroAddress();\n    error FailedToSendEther();\n    error InvalidMerkleProof();\n\n    error OnlyLayerZeroEndpoint();\n    error OnlyYT();\n    error OnlyYCFactory();\n    error OnlyWhitelisted();\n\n    // Swap Aggregator\n    error SAInsufficientTokenIn(address tokenIn, uint256 amountExpected, uint256 amountActual);\n    error UnsupportedSelector(uint256 aggregatorType, bytes4 selector);\n}\n"},"contracts/pendle/contracts/core/Market/OracleLib.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\nimport \"../libraries/Errors.sol\";\n\n/// Adapted from UniswapV3's Oracle\n\nlibrary OracleLib {\n    struct Observation {\n        uint32 blockTimestamp;\n        uint216 lnImpliedRateCumulative;\n        bool initialized;\n        // 1 SLOT = 256 bits\n    }\n\n    function transform(\n        Observation memory last,\n        uint32 blockTimestamp,\n        uint96 lnImpliedRate\n    ) public pure returns (Observation memory) {\n        return\n            Observation({\n                blockTimestamp: blockTimestamp,\n                lnImpliedRateCumulative: last.lnImpliedRateCumulative +\n                    uint216(lnImpliedRate) *\n                    (blockTimestamp - last.blockTimestamp),\n                initialized: true\n            });\n    }\n\n    function initialize(\n        Observation[65535] storage self,\n        uint32 time\n    ) public returns (uint16 cardinality, uint16 cardinalityNext) {\n        self[0] = Observation({blockTimestamp: time, lnImpliedRateCumulative: 0, initialized: true});\n        return (1, 1);\n    }\n\n    function write(\n        Observation[65535] storage self,\n        uint16 index,\n        uint32 blockTimestamp,\n        uint96 lnImpliedRate,\n        uint16 cardinality,\n        uint16 cardinalityNext\n    ) public returns (uint16 indexUpdated, uint16 cardinalityUpdated) {\n        Observation memory last = self[index];\n\n        // early return if we've already written an observation this block\n        if (last.blockTimestamp == blockTimestamp) return (index, cardinality);\n\n        // if the conditions are right, we can bump the cardinality\n        if (cardinalityNext > cardinality && index == (cardinality - 1)) {\n            cardinalityUpdated = cardinalityNext;\n        } else {\n            cardinalityUpdated = cardinality;\n        }\n\n        indexUpdated = (index + 1) % cardinalityUpdated;\n        self[indexUpdated] = transform(last, blockTimestamp, lnImpliedRate);\n    }\n\n    function grow(Observation[65535] storage self, uint16 current, uint16 next) public returns (uint16) {\n        if (current == 0) revert Errors.OracleUninitialized();\n        // no-op if the passed next value isn't greater than the current next value\n        if (next <= current) return current;\n        // store in each slot to prevent fresh SSTOREs in swaps\n        // this data will not be used because the initialized boolean is still false\n        for (uint16 i = current; i != next; ) {\n            self[i].blockTimestamp = 1;\n            unchecked {\n                ++i;\n            }\n        }\n        return next;\n    }\n\n    function binarySearch(\n        Observation[65535] storage self,\n        uint32 target,\n        uint16 index,\n        uint16 cardinality\n    ) public view returns (Observation memory beforeOrAt, Observation memory atOrAfter) {\n        uint256 l = (index + 1) % cardinality; // oldest observation\n        uint256 r = l + cardinality - 1; // newest observation\n        uint256 i;\n        while (true) {\n            i = (l + r) / 2;\n\n            beforeOrAt = self[i % cardinality];\n\n            // we've landed on an uninitialized observation, keep searching higher (more recently)\n            if (!beforeOrAt.initialized) {\n                l = i + 1;\n                continue;\n            }\n\n            atOrAfter = self[(i + 1) % cardinality];\n\n            bool targetAtOrAfter = beforeOrAt.blockTimestamp <= target;\n\n            // check if we've found the answer!\n            if (targetAtOrAfter && target <= atOrAfter.blockTimestamp) break;\n\n            if (!targetAtOrAfter) r = i - 1;\n            else l = i + 1;\n        }\n    }\n\n    function getSurroundingObservations(\n        Observation[65535] storage self,\n        uint32 target,\n        uint96 lnImpliedRate,\n        uint16 index,\n        uint16 cardinality\n    ) public view returns (Observation memory beforeOrAt, Observation memory atOrAfter) {\n        // optimistically set before to the newest observation\n        beforeOrAt = self[index];\n\n        // if the target is chronologically at or after the newest observation, we can early return\n        if (beforeOrAt.blockTimestamp <= target) {\n            if (beforeOrAt.blockTimestamp == target) {\n                // if newest observation equals target, we're in the same block, so we can ignore atOrAfter\n                return (beforeOrAt, atOrAfter);\n            } else {\n                // otherwise, we need to transform\n                return (beforeOrAt, transform(beforeOrAt, target, lnImpliedRate));\n            }\n        }\n\n        // now, set beforeOrAt to the oldest observation\n        beforeOrAt = self[(index + 1) % cardinality];\n        if (!beforeOrAt.initialized) beforeOrAt = self[0];\n\n        // ensure that the target is chronologically at or after the oldest observation\n        if (target < beforeOrAt.blockTimestamp) revert Errors.OracleTargetTooOld(target, beforeOrAt.blockTimestamp);\n\n        // if we've reached this point, we have to binary search\n        return binarySearch(self, target, index, cardinality);\n    }\n\n    function observeSingle(\n        Observation[65535] storage self,\n        uint32 time,\n        uint32 secondsAgo,\n        uint96 lnImpliedRate,\n        uint16 index,\n        uint16 cardinality\n    ) public view returns (uint216 lnImpliedRateCumulative) {\n        if (secondsAgo == 0) {\n            Observation memory last = self[index];\n            if (last.blockTimestamp != time) {\n                return transform(last, time, lnImpliedRate).lnImpliedRateCumulative;\n            }\n            return last.lnImpliedRateCumulative;\n        }\n\n        uint32 target = time - secondsAgo;\n\n        (Observation memory beforeOrAt, Observation memory atOrAfter) = getSurroundingObservations(\n            self,\n            target,\n            lnImpliedRate,\n            index,\n            cardinality\n        );\n\n        if (target == beforeOrAt.blockTimestamp) {\n            // we're at the left boundary\n            return beforeOrAt.lnImpliedRateCumulative;\n        } else if (target == atOrAfter.blockTimestamp) {\n            // we're at the right boundary\n            return atOrAfter.lnImpliedRateCumulative;\n        } else {\n            // we're in the middle\n            return (beforeOrAt.lnImpliedRateCumulative +\n                uint216(\n                    (uint256(atOrAfter.lnImpliedRateCumulative - beforeOrAt.lnImpliedRateCumulative) *\n                        (target - beforeOrAt.blockTimestamp)) / (atOrAfter.blockTimestamp - beforeOrAt.blockTimestamp)\n                ));\n        }\n    }\n\n    function observe(\n        Observation[65535] storage self,\n        uint32 time,\n        uint32[] memory secondsAgos,\n        uint96 lnImpliedRate,\n        uint16 index,\n        uint16 cardinality\n    ) public view returns (uint216[] memory lnImpliedRateCumulative) {\n        if (cardinality == 0) revert Errors.OracleZeroCardinality();\n\n        lnImpliedRateCumulative = new uint216[](secondsAgos.length);\n        for (uint256 i = 0; i < lnImpliedRateCumulative.length; ++i) {\n            lnImpliedRateCumulative[i] = observeSingle(self, time, secondsAgos[i], lnImpliedRate, index, cardinality);\n        }\n    }\n}\n"}},"settings":{"optimizer":{"enabled":true,"runs":1000000},"viaIR":true,"evmVersion":"paris","outputSelection":{"*":{"*":["evm.bytecode","evm.deployedBytecode","devdoc","userdoc","metadata","abi"]}},"libraries":{}}},"ABI":"[{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"target\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"oldest\",\"type\":\"uint32\"}],\"name\":\"OracleTargetTooOld\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OracleUninitialized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OracleZeroCardinality\",\"type\":\"error\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"blockTimestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint216\",\"name\":\"lnImpliedRateCumulative\",\"type\":\"uint216\"},{\"internalType\":\"bool\",\"name\":\"initialized\",\"type\":\"bool\"}],\"internalType\":\"struct OracleLib.Observation\",\"name\":\"last\",\"type\":\"tuple\"},{\"internalType\":\"uint32\",\"name\":\"blockTimestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint96\",\"name\":\"lnImpliedRate\",\"type\":\"uint96\"}],\"name\":\"transform\",\"outputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"blockTimestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint216\",\"name\":\"lnImpliedRateCumulative\",\"type\":\"uint216\"},{\"internalType\":\"bool\",\"name\":\"initialized\",\"type\":\"bool\"}],\"internalType\":\"struct OracleLib.Observation\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"OracleLib","CompilerVersion":"v0.8.24+commit.e11b9ed9","OptimizationUsed":1,"Runs":1000000,"ConstructorArguments":"0x","EVMVersion":"paris","Library":"","LicenseType":"","Proxy":0,"SwarmSource":""}]}