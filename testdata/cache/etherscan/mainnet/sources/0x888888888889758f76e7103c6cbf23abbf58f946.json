{"expiry":1725830229,"data":[{"SourceCode":{"language":"Solidity","sources":{"@openzeppelin/contracts/proxy/Proxy.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overridden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"},"contracts/pendle/contracts/router/PendleRouterV4.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.17;\n\nimport \"@openzeppelin/contracts/proxy/Proxy.sol\";\nimport \"../interfaces/IPActionStorageV4.sol\";\nimport \"./RouterStorage.sol\";\n\ncontract PendleRouterV4 is Proxy, RouterStorage {\n    constructor(address _owner, address actionStorage) {\n        RouterStorage.CoreStorage storage $ = _getCoreStorage();\n        $.owner = _owner;\n        $.selectorToFacet[IPActionStorageV4.setSelectorToFacets.selector] = actionStorage;\n    }\n\n    function _implementation() internal view override returns (address) {\n        RouterStorage.CoreStorage storage $ = _getCoreStorage();\n        address facet = $.selectorToFacet[msg.sig];\n        require(facet != address(0), \"INVALID_SELECTOR\");\n        return facet;\n    }\n\n    receive() external payable override {}\n}\n"},"contracts/pendle/contracts/router/RouterStorage.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.17;\n\nabstract contract RouterStorage {\n    struct CoreStorage {\n        address owner;\n        address pendingOwner;\n        mapping(bytes4 => address) selectorToFacet;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"pendle.routerv4.Core\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant CORE_STORAGE_LOCATION = 0xf168c5b0cb4aca9a68f931815c18a144c61ad01d6dd7ca15bd6741672a0ab800;\n\n    function _getCoreStorage() internal pure returns (CoreStorage storage $) {\n        assembly {\n            $.slot := CORE_STORAGE_LOCATION\n        }\n    }\n}\n"},"contracts/pendle/contracts/interfaces/IPActionStorageV4.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\ninterface IPActionStorageV4 {\n    struct SelectorsToFacet {\n        address facet;\n        bytes4[] selectors;\n    }\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    event SelectorToFacetSet(bytes4 indexed selector, address indexed facet);\n\n    function owner() external view returns (address);\n\n    function pendingOwner() external view returns (address);\n\n    function transferOwnership(address newOwner, bool direct, bool renounce) external;\n\n    function claimOwnership() external;\n\n    function setSelectorToFacets(SelectorsToFacet[] calldata arr) external;\n\n    function selectorToFacet(bytes4 selector) external view returns (address);\n}\n"}},"settings":{"optimizer":{"enabled":true,"runs":1000000},"viaIR":true,"evmVersion":"shanghai","outputSelection":{"*":{"*":["evm.bytecode","evm.deployedBytecode","devdoc","userdoc","metadata","abi"]}},"libraries":{}}},"ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"actionStorage\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"PendleRouterV4","CompilerVersion":"v0.8.24+commit.e11b9ed9","OptimizationUsed":1,"Runs":1000000,"ConstructorArguments":"0x0000000000000000000000001fccc097db89a86bfc474a1028f93958295b1fb70000000000000000000000002d36f2a022d1170f33fdfd5670833c447c0c9ff3","EVMVersion":"shanghai","Library":"","LicenseType":"","Proxy":1,"Implementation":"0xb7631b93189900745db51d960ba64b8e6c658843","SwarmSource":""}]}