{"expiry":6014680230,"data":[{"SourceCode":{"language":"Solidity","sources":{"@solidstate/contracts/token/ERC1155/enumerable/ERC1155EnumerableStorage.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { EnumerableSet } from '../../../data/EnumerableSet.sol';\n\nlibrary ERC1155EnumerableStorage {\n    struct Layout {\n        mapping(uint256 => uint256) totalSupply;\n        mapping(uint256 => EnumerableSet.AddressSet) accountsByToken;\n        mapping(address => EnumerableSet.UintSet) tokensByAccount;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.ERC1155Enumerable');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"},"@solidstate/contracts/token/ERC1155/metadata/IERC1155Metadata.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC1155MetadataInternal } from './IERC1155MetadataInternal.sol';\n\n/**\n * @title ERC1155Metadata interface\n */\ninterface IERC1155Metadata is IERC1155MetadataInternal {\n    /**\n     * @notice get generated URI for given token\n     * @return token URI\n     */\n    function uri(uint256 tokenId) external view returns (string memory);\n}\n"},"contracts/staking/VxPremiaStorage.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\r\n// For further clarification please see https://license.premia.legal\r\n\r\npragma solidity ^0.8.0;\r\n\r\nlibrary VxPremiaStorage {\r\n    bytes32 internal constant STORAGE_SLOT =\r\n        keccak256(\"premia.contracts.staking.VxPremia\");\r\n\r\n    enum VoteVersion {\r\n        V2 // poolAddress : 20 bytes / isCallPool : 2 bytes\r\n    }\r\n\r\n    struct Vote {\r\n        uint256 amount;\r\n        VoteVersion version;\r\n        bytes target;\r\n    }\r\n\r\n    struct Layout {\r\n        mapping(address => Vote[]) userVotes;\r\n        // Vote version -> Pool identifier -> Vote amount\r\n        mapping(VoteVersion => mapping(bytes => uint256)) votes;\r\n    }\r\n\r\n    function layout() internal pure returns (Layout storage l) {\r\n        bytes32 slot = STORAGE_SLOT;\r\n        assembly {\r\n            l.slot := slot\r\n        }\r\n    }\r\n}\r\n"},"@solidstate/contracts/token/ERC20/extended/IERC20Extended.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC20ExtendedInternal } from './IERC20ExtendedInternal.sol';\n\n/**\n * @title ERC20 extended interface\n */\ninterface IERC20Extended is IERC20ExtendedInternal {\n    /**\n     * @notice increase spend amount granted to spender\n     * @param spender address whose allowance to increase\n     * @param amount quantity by which to increase allowance\n     * @return success status (always true; otherwise function will revert)\n     */\n    function increaseAllowance(\n        address spender,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @notice decrease spend amount granted to spender\n     * @param spender address whose allowance to decrease\n     * @param amount quantity by which to decrease allowance\n     * @return success status (always true; otherwise function will revert)\n     */\n    function decreaseAllowance(\n        address spender,\n        uint256 amount\n    ) external returns (bool);\n}\n"},"contracts/layerZero/token/oft/IOFT.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport {IOFTCore} from \"./IOFTCore.sol\";\r\nimport {ISolidStateERC20} from \"@solidstate/contracts/token/ERC20/ISolidStateERC20.sol\";\r\n\r\n/**\r\n * @dev Interface of the OFT standard\r\n */\r\ninterface IOFT is IOFTCore, ISolidStateERC20 {\r\n    error OFT_InsufficientAllowance();\r\n}\r\n"},"contracts/pool/IPoolIO.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-or-later\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport {IPoolInternal} from \"./IPoolInternal.sol\";\r\n\r\n/**\r\n * @notice Pool interface for LP position and platform fee management functions\r\n */\r\ninterface IPoolIO {\r\n    /**\r\n     * @notice set timestamp after which reinvestment is disabled\r\n     * @param timestamp timestamp to begin divestment\r\n     * @param isCallPool whether we set divestment timestamp for the call pool or put pool\r\n     */\r\n    function setDivestmentTimestamp(uint64 timestamp, bool isCallPool) external;\r\n\r\n    /**\r\n     * @notice deposit underlying currency, underwriting calls of that currency with respect to base currency\r\n     * @param amount quantity of underlying currency to deposit\r\n     * @param isCallPool whether to deposit underlying in the call pool or base in the put pool\r\n     */\r\n    function deposit(uint256 amount, bool isCallPool) external payable;\r\n\r\n    /**\r\n     * @notice  swap any token to collateral asset through exchange proxy and deposit\r\n     * @dev     any attached msg.value will be wrapped.\r\n     *          if tokenIn is wrappedNativeToken, both msg.value and {amountInMax} amount of wrappedNativeToken will be used\r\n     * @param s swap arguments\r\n     * @param isCallPool whether to deposit underlying in the call pool or base in the put pool\r\n     */\r\n    function swapAndDeposit(\r\n        IPoolInternal.SwapArgs memory s,\r\n        bool isCallPool\r\n    ) external payable;\r\n\r\n    /**\r\n     * @notice redeem pool share tokens for underlying asset\r\n     * @param amount quantity of share tokens to redeem\r\n     * @param isCallPool whether to deposit underlying in the call pool or base in the put pool\r\n     */\r\n    function withdraw(uint256 amount, bool isCallPool) external;\r\n\r\n    /**\r\n     * @notice reassign short position to new underwriter\r\n     * @param tokenId ERC1155 token id (long or short)\r\n     * @param contractSize quantity of option contract tokens to reassign\r\n     * @param divest whether to withdraw freed funds after reassignment\r\n     * @return baseCost quantity of tokens required to reassign short position\r\n     * @return feeCost quantity of tokens required to pay fees\r\n     * @return amountOut quantity of liquidity freed and transferred to owner\r\n     */\r\n    function reassign(\r\n        uint256 tokenId,\r\n        uint256 contractSize,\r\n        bool divest\r\n    ) external returns (uint256 baseCost, uint256 feeCost, uint256 amountOut);\r\n\r\n    /**\r\n     * @notice reassign set of short position to new underwriter\r\n     * @param tokenIds array of ERC1155 token ids (long or short)\r\n     * @param contractSizes array of quantities of option contract tokens to reassign\r\n     * @param divest whether to withdraw freed funds after reassignment\r\n     * @return baseCosts quantities of tokens required to reassign each short position\r\n     * @return feeCosts quantities of tokens required to pay fees\r\n     * @return amountOutCall quantity of call pool liquidity freed and transferred to owner\r\n     * @return amountOutPut quantity of put pool liquidity freed and transferred to owner\r\n     */\r\n    function reassignBatch(\r\n        uint256[] calldata tokenIds,\r\n        uint256[] calldata contractSizes,\r\n        bool divest\r\n    )\r\n        external\r\n        returns (\r\n            uint256[] memory baseCosts,\r\n            uint256[] memory feeCosts,\r\n            uint256 amountOutCall,\r\n            uint256 amountOutPut\r\n        );\r\n\r\n    /**\r\n     * @notice transfer accumulated fees to the fee receiver\r\n     * @return amountOutCall quantity of underlying tokens transferred\r\n     * @return amountOutPut quantity of base tokens transferred\r\n     */\r\n    function withdrawFees()\r\n        external\r\n        returns (uint256 amountOutCall, uint256 amountOutPut);\r\n\r\n    /**\r\n     * @notice burn corresponding long and short option tokens and withdraw collateral\r\n     * @param tokenId ERC1155 token id (long or short)\r\n     * @param contractSize quantity of option contract tokens to annihilate\r\n     * @param divest whether to withdraw freed funds after annihilation\r\n     */\r\n    function annihilate(\r\n        uint256 tokenId,\r\n        uint256 contractSize,\r\n        bool divest\r\n    ) external;\r\n\r\n    /**\r\n     * @notice claim earned PREMIA emissions\r\n     * @param isCallPool true for call, false for put\r\n     */\r\n    function claimRewards(bool isCallPool) external;\r\n\r\n    /**\r\n     * @notice claim earned PREMIA emissions on behalf of given account\r\n     * @param account account on whose behalf to claim rewards\r\n     * @param isCallPool true for call, false for put\r\n     */\r\n    function claimRewards(address account, bool isCallPool) external;\r\n\r\n    /**\r\n     * @notice TODO\r\n     */\r\n    function updateMiningPools() external;\r\n}\r\n"},"@solidstate/contracts/token/ERC20/permit/IERC2612Internal.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\ninterface IERC2612Internal {}\n"},"@solidstate/contracts/access/ownable/IOwnableInternal.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC173Internal } from '../../interfaces/IERC173Internal.sol';\n\ninterface IOwnableInternal is IERC173Internal {\n    error Ownable__NotOwner();\n    error Ownable__NotTransitiveOwner();\n}\n"},"@solidstate/contracts/token/ERC20/permit/IERC20PermitInternal.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC2612Internal } from './IERC2612Internal.sol';\n\ninterface IERC20PermitInternal is IERC2612Internal {\n    error ERC20Permit__ExpiredDeadline();\n    error ERC20Permit__InvalidSignature();\n}\n"},"contracts/staking/IVxPremia.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-or-later\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport {VxPremiaStorage} from \"./VxPremiaStorage.sol\";\r\nimport {IPremiaStaking} from \"./IPremiaStaking.sol\";\r\n\r\ninterface IVxPremia is IPremiaStaking {\r\n    error VxPremia__InvalidPoolAddress();\r\n    error VxPremia__InvalidVoteTarget();\r\n    error VxPremia__NotEnoughVotingPower();\r\n\r\n    event AddVote(\r\n        address indexed voter,\r\n        VxPremiaStorage.VoteVersion indexed version,\r\n        bytes target,\r\n        uint256 amount\r\n    );\r\n    event RemoveVote(\r\n        address indexed voter,\r\n        VxPremiaStorage.VoteVersion indexed version,\r\n        bytes target,\r\n        uint256 amount\r\n    );\r\n\r\n    /**\r\n     * @notice get total votes for specific pools\r\n     * @param version version of target (used to know how to decode data)\r\n     * @param target ABI encoded target of the votes\r\n     * @return total votes for specific pool\r\n     */\r\n    function getPoolVotes(\r\n        VxPremiaStorage.VoteVersion version,\r\n        bytes memory target\r\n    ) external view returns (uint256);\r\n\r\n    /**\r\n     * @notice get votes of user\r\n     * @param user user from which to get votes\r\n     * @return votes of user\r\n     */\r\n    function getUserVotes(\r\n        address user\r\n    ) external view returns (VxPremiaStorage.Vote[] memory);\r\n\r\n    /**\r\n     * @notice add or remove votes, in the limit of the user voting power\r\n     * @param votes votes to cast\r\n     */\r\n    function castVotes(VxPremiaStorage.Vote[] memory votes) external;\r\n}\r\n"},"@solidstate/contracts/token/ERC20/base/IERC20BaseInternal.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC20Internal } from '../../../interfaces/IERC20Internal.sol';\n\n/**\n * @title ERC20 base interface\n */\ninterface IERC20BaseInternal is IERC20Internal {\n    error ERC20Base__ApproveFromZeroAddress();\n    error ERC20Base__ApproveToZeroAddress();\n    error ERC20Base__BurnExceedsBalance();\n    error ERC20Base__BurnFromZeroAddress();\n    error ERC20Base__InsufficientAllowance();\n    error ERC20Base__MintToZeroAddress();\n    error ERC20Base__TransferExceedsBalance();\n    error ERC20Base__TransferFromZeroAddress();\n    error ERC20Base__TransferToZeroAddress();\n}\n"},"@solidstate/contracts/token/ERC20/base/IERC20Base.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC20 } from '../../../interfaces/IERC20.sol';\nimport { IERC20BaseInternal } from './IERC20BaseInternal.sol';\n\n/**\n * @title ERC20 base interface\n */\ninterface IERC20Base is IERC20BaseInternal, IERC20 {\n\n}\n"},"@solidstate/contracts/token/ERC20/metadata/IERC20Metadata.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC20MetadataInternal } from './IERC20MetadataInternal.sol';\n\n/**\n * @title ERC20 metadata interface\n */\ninterface IERC20Metadata is IERC20MetadataInternal {\n    /**\n     * @notice return token name\n     * @return token name\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @notice return token symbol\n     * @return token symbol\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @notice return token decimals, generally used only for display purposes\n     * @return token decimals\n     */\n    function decimals() external view returns (uint8);\n}\n"},"@solidstate/contracts/token/ERC20/metadata/IERC20MetadataInternal.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title ERC20 metadata internal interface\n */\ninterface IERC20MetadataInternal {\n\n}\n"},"contracts/mining/IPremiaMining.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-or-later\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport {PremiaMiningStorage} from \"./PremiaMiningStorage.sol\";\r\n\r\ninterface IPremiaMining {\r\n    struct PoolAllocPoints {\r\n        address pool;\r\n        bool isCallPool;\r\n        uint256 votes;\r\n        uint256 poolUtilizationRateBPS; // 100% = 1e4\r\n    }\r\n\r\n    event Claim(\r\n        address indexed user,\r\n        address indexed pool,\r\n        bool indexed isCallPool,\r\n        uint256 rewardAmount\r\n    );\r\n\r\n    event UpdatePoolAlloc(\r\n        address indexed pool,\r\n        bool indexed isCallPool,\r\n        uint256 votes,\r\n        uint256 poolUtilizationRateBPS\r\n    );\r\n\r\n    function addPremiaRewards(uint256 _amount) external;\r\n\r\n    function premiaRewardsAvailable() external view returns (uint256);\r\n\r\n    function getTotalAllocationPoints() external view returns (uint256);\r\n\r\n    function getPoolInfo(\r\n        address pool,\r\n        bool isCallPool\r\n    ) external view returns (PremiaMiningStorage.PoolInfo memory);\r\n\r\n    function getPremiaPerYear() external view returns (uint256);\r\n\r\n    function pendingPremia(\r\n        address _pool,\r\n        bool _isCallPool,\r\n        address _user\r\n    ) external view returns (uint256);\r\n\r\n    function updatePool(\r\n        address _pool,\r\n        bool _isCallPool,\r\n        uint256 _totalTVL,\r\n        uint256 _utilizationRate\r\n    ) external;\r\n\r\n    function allocatePending(\r\n        address _user,\r\n        address _pool,\r\n        bool _isCallPool,\r\n        uint256 _userTVLOld,\r\n        uint256 _userTVLNew,\r\n        uint256 _totalTVL,\r\n        uint256 _utilizationRate\r\n    ) external;\r\n\r\n    function claim(\r\n        address _user,\r\n        address _pool,\r\n        bool _isCallPool,\r\n        uint256 _userTVLOld,\r\n        uint256 _userTVLNew,\r\n        uint256 _totalTVL,\r\n        uint256 _utilizationRate\r\n    ) external;\r\n}\r\n"},"abdk-libraries-solidity/ABDKMath64x64.sol":{"content":"// SPDX-License-Identifier: BSD-4-Clause\n/*\n * ABDK Math 64.64 Smart Contract Library.  Copyright © 2019 by ABDK Consulting.\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\n */\npragma solidity ^0.8.0;\n\n/**\n * Smart contract library of mathematical functions operating with signed\n * 64.64-bit fixed point numbers.  Signed 64.64-bit fixed point number is\n * basically a simple fraction whose numerator is signed 128-bit integer and\n * denominator is 2^64.  As long as denominator is always the same, there is no\n * need to store it, thus in Solidity signed 64.64-bit fixed point numbers are\n * represented by int128 type holding only the numerator.\n */\nlibrary ABDKMath64x64 {\n  /*\n   * Minimum value signed 64.64-bit fixed point number may have. \n   */\n  int128 private constant MIN_64x64 = -0x80000000000000000000000000000000;\n\n  /*\n   * Maximum value signed 64.64-bit fixed point number may have. \n   */\n  int128 private constant MAX_64x64 = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n  /**\n   * Convert signed 256-bit integer number into signed 64.64-bit fixed point\n   * number.  Revert on overflow.\n   *\n   * @param x signed 256-bit integer number\n   * @return signed 64.64-bit fixed point number\n   */\n  function fromInt (int256 x) internal pure returns (int128) {\n    unchecked {\n      require (x >= -0x8000000000000000 && x <= 0x7FFFFFFFFFFFFFFF);\n      return int128 (x << 64);\n    }\n  }\n\n  /**\n   * Convert signed 64.64 fixed point number into signed 64-bit integer number\n   * rounding down.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64-bit integer number\n   */\n  function toInt (int128 x) internal pure returns (int64) {\n    unchecked {\n      return int64 (x >> 64);\n    }\n  }\n\n  /**\n   * Convert unsigned 256-bit integer number into signed 64.64-bit fixed point\n   * number.  Revert on overflow.\n   *\n   * @param x unsigned 256-bit integer number\n   * @return signed 64.64-bit fixed point number\n   */\n  function fromUInt (uint256 x) internal pure returns (int128) {\n    unchecked {\n      require (x <= 0x7FFFFFFFFFFFFFFF);\n      return int128 (int256 (x << 64));\n    }\n  }\n\n  /**\n   * Convert signed 64.64 fixed point number into unsigned 64-bit integer\n   * number rounding down.  Revert on underflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return unsigned 64-bit integer number\n   */\n  function toUInt (int128 x) internal pure returns (uint64) {\n    unchecked {\n      require (x >= 0);\n      return uint64 (uint128 (x >> 64));\n    }\n  }\n\n  /**\n   * Convert signed 128.128 fixed point number into signed 64.64-bit fixed point\n   * number rounding down.  Revert on overflow.\n   *\n   * @param x signed 128.128-bin fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function from128x128 (int256 x) internal pure returns (int128) {\n    unchecked {\n      int256 result = x >> 64;\n      require (result >= MIN_64x64 && result <= MAX_64x64);\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Convert signed 64.64 fixed point number into signed 128.128 fixed point\n   * number.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 128.128 fixed point number\n   */\n  function to128x128 (int128 x) internal pure returns (int256) {\n    unchecked {\n      return int256 (x) << 64;\n    }\n  }\n\n  /**\n   * Calculate x + y.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function add (int128 x, int128 y) internal pure returns (int128) {\n    unchecked {\n      int256 result = int256(x) + y;\n      require (result >= MIN_64x64 && result <= MAX_64x64);\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate x - y.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function sub (int128 x, int128 y) internal pure returns (int128) {\n    unchecked {\n      int256 result = int256(x) - y;\n      require (result >= MIN_64x64 && result <= MAX_64x64);\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate x * y rounding down.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function mul (int128 x, int128 y) internal pure returns (int128) {\n    unchecked {\n      int256 result = int256(x) * y >> 64;\n      require (result >= MIN_64x64 && result <= MAX_64x64);\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate x * y rounding towards zero, where x is signed 64.64 fixed point\n   * number and y is signed 256-bit integer number.  Revert on overflow.\n   *\n   * @param x signed 64.64 fixed point number\n   * @param y signed 256-bit integer number\n   * @return signed 256-bit integer number\n   */\n  function muli (int128 x, int256 y) internal pure returns (int256) {\n    unchecked {\n      if (x == MIN_64x64) {\n        require (y >= -0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF &&\n          y <= 0x1000000000000000000000000000000000000000000000000);\n        return -y << 63;\n      } else {\n        bool negativeResult = false;\n        if (x < 0) {\n          x = -x;\n          negativeResult = true;\n        }\n        if (y < 0) {\n          y = -y; // We rely on overflow behavior here\n          negativeResult = !negativeResult;\n        }\n        uint256 absoluteResult = mulu (x, uint256 (y));\n        if (negativeResult) {\n          require (absoluteResult <=\n            0x8000000000000000000000000000000000000000000000000000000000000000);\n          return -int256 (absoluteResult); // We rely on overflow behavior here\n        } else {\n          require (absoluteResult <=\n            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n          return int256 (absoluteResult);\n        }\n      }\n    }\n  }\n\n  /**\n   * Calculate x * y rounding down, where x is signed 64.64 fixed point number\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\n   *\n   * @param x signed 64.64 fixed point number\n   * @param y unsigned 256-bit integer number\n   * @return unsigned 256-bit integer number\n   */\n  function mulu (int128 x, uint256 y) internal pure returns (uint256) {\n    unchecked {\n      if (y == 0) return 0;\n\n      require (x >= 0);\n\n      uint256 lo = (uint256 (int256 (x)) * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) >> 64;\n      uint256 hi = uint256 (int256 (x)) * (y >> 128);\n\n      require (hi <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n      hi <<= 64;\n\n      require (hi <=\n        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - lo);\n      return hi + lo;\n    }\n  }\n\n  /**\n   * Calculate x / y rounding towards zero.  Revert on overflow or when y is\n   * zero.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function div (int128 x, int128 y) internal pure returns (int128) {\n    unchecked {\n      require (y != 0);\n      int256 result = (int256 (x) << 64) / y;\n      require (result >= MIN_64x64 && result <= MAX_64x64);\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate x / y rounding towards zero, where x and y are signed 256-bit\n   * integer numbers.  Revert on overflow or when y is zero.\n   *\n   * @param x signed 256-bit integer number\n   * @param y signed 256-bit integer number\n   * @return signed 64.64-bit fixed point number\n   */\n  function divi (int256 x, int256 y) internal pure returns (int128) {\n    unchecked {\n      require (y != 0);\n\n      bool negativeResult = false;\n      if (x < 0) {\n        x = -x; // We rely on overflow behavior here\n        negativeResult = true;\n      }\n      if (y < 0) {\n        y = -y; // We rely on overflow behavior here\n        negativeResult = !negativeResult;\n      }\n      uint128 absoluteResult = divuu (uint256 (x), uint256 (y));\n      if (negativeResult) {\n        require (absoluteResult <= 0x80000000000000000000000000000000);\n        return -int128 (absoluteResult); // We rely on overflow behavior here\n      } else {\n        require (absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n        return int128 (absoluteResult); // We rely on overflow behavior here\n      }\n    }\n  }\n\n  /**\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\n   * integer numbers.  Revert on overflow or when y is zero.\n   *\n   * @param x unsigned 256-bit integer number\n   * @param y unsigned 256-bit integer number\n   * @return signed 64.64-bit fixed point number\n   */\n  function divu (uint256 x, uint256 y) internal pure returns (int128) {\n    unchecked {\n      require (y != 0);\n      uint128 result = divuu (x, y);\n      require (result <= uint128 (MAX_64x64));\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate -x.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function neg (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x != MIN_64x64);\n      return -x;\n    }\n  }\n\n  /**\n   * Calculate |x|.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function abs (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x != MIN_64x64);\n      return x < 0 ? -x : x;\n    }\n  }\n\n  /**\n   * Calculate 1 / x rounding towards zero.  Revert on overflow or when x is\n   * zero.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function inv (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x != 0);\n      int256 result = int256 (0x100000000000000000000000000000000) / x;\n      require (result >= MIN_64x64 && result <= MAX_64x64);\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate arithmetics average of x and y, i.e. (x + y) / 2 rounding down.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function avg (int128 x, int128 y) internal pure returns (int128) {\n    unchecked {\n      return int128 ((int256 (x) + int256 (y)) >> 1);\n    }\n  }\n\n  /**\n   * Calculate geometric average of x and y, i.e. sqrt (x * y) rounding down.\n   * Revert on overflow or in case x * y is negative.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function gavg (int128 x, int128 y) internal pure returns (int128) {\n    unchecked {\n      int256 m = int256 (x) * int256 (y);\n      require (m >= 0);\n      require (m <\n          0x4000000000000000000000000000000000000000000000000000000000000000);\n      return int128 (sqrtu (uint256 (m)));\n    }\n  }\n\n  /**\n   * Calculate x^y assuming 0^0 is 1, where x is signed 64.64 fixed point number\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y uint256 value\n   * @return signed 64.64-bit fixed point number\n   */\n  function pow (int128 x, uint256 y) internal pure returns (int128) {\n    unchecked {\n      bool negative = x < 0 && y & 1 == 1;\n\n      uint256 absX = uint128 (x < 0 ? -x : x);\n      uint256 absResult;\n      absResult = 0x100000000000000000000000000000000;\n\n      if (absX <= 0x10000000000000000) {\n        absX <<= 63;\n        while (y != 0) {\n          if (y & 0x1 != 0) {\n            absResult = absResult * absX >> 127;\n          }\n          absX = absX * absX >> 127;\n\n          if (y & 0x2 != 0) {\n            absResult = absResult * absX >> 127;\n          }\n          absX = absX * absX >> 127;\n\n          if (y & 0x4 != 0) {\n            absResult = absResult * absX >> 127;\n          }\n          absX = absX * absX >> 127;\n\n          if (y & 0x8 != 0) {\n            absResult = absResult * absX >> 127;\n          }\n          absX = absX * absX >> 127;\n\n          y >>= 4;\n        }\n\n        absResult >>= 64;\n      } else {\n        uint256 absXShift = 63;\n        if (absX < 0x1000000000000000000000000) { absX <<= 32; absXShift -= 32; }\n        if (absX < 0x10000000000000000000000000000) { absX <<= 16; absXShift -= 16; }\n        if (absX < 0x1000000000000000000000000000000) { absX <<= 8; absXShift -= 8; }\n        if (absX < 0x10000000000000000000000000000000) { absX <<= 4; absXShift -= 4; }\n        if (absX < 0x40000000000000000000000000000000) { absX <<= 2; absXShift -= 2; }\n        if (absX < 0x80000000000000000000000000000000) { absX <<= 1; absXShift -= 1; }\n\n        uint256 resultShift = 0;\n        while (y != 0) {\n          require (absXShift < 64);\n\n          if (y & 0x1 != 0) {\n            absResult = absResult * absX >> 127;\n            resultShift += absXShift;\n            if (absResult > 0x100000000000000000000000000000000) {\n              absResult >>= 1;\n              resultShift += 1;\n            }\n          }\n          absX = absX * absX >> 127;\n          absXShift <<= 1;\n          if (absX >= 0x100000000000000000000000000000000) {\n              absX >>= 1;\n              absXShift += 1;\n          }\n\n          y >>= 1;\n        }\n\n        require (resultShift < 64);\n        absResult >>= 64 - resultShift;\n      }\n      int256 result = negative ? -int256 (absResult) : int256 (absResult);\n      require (result >= MIN_64x64 && result <= MAX_64x64);\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate sqrt (x) rounding down.  Revert if x < 0.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function sqrt (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x >= 0);\n      return int128 (sqrtu (uint256 (int256 (x)) << 64));\n    }\n  }\n\n  /**\n   * Calculate binary logarithm of x.  Revert if x <= 0.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function log_2 (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x > 0);\n\n      int256 msb = 0;\n      int256 xc = x;\n      if (xc >= 0x10000000000000000) { xc >>= 64; msb += 64; }\n      if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\n      if (xc >= 0x10000) { xc >>= 16; msb += 16; }\n      if (xc >= 0x100) { xc >>= 8; msb += 8; }\n      if (xc >= 0x10) { xc >>= 4; msb += 4; }\n      if (xc >= 0x4) { xc >>= 2; msb += 2; }\n      if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\n\n      int256 result = msb - 64 << 64;\n      uint256 ux = uint256 (int256 (x)) << uint256 (127 - msb);\n      for (int256 bit = 0x8000000000000000; bit > 0; bit >>= 1) {\n        ux *= ux;\n        uint256 b = ux >> 255;\n        ux >>= 127 + b;\n        result += bit * int256 (b);\n      }\n\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate natural logarithm of x.  Revert if x <= 0.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function ln (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x > 0);\n\n      return int128 (int256 (\n          uint256 (int256 (log_2 (x))) * 0xB17217F7D1CF79ABC9E3B39803F2F6AF >> 128));\n    }\n  }\n\n  /**\n   * Calculate binary exponent of x.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function exp_2 (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x < 0x400000000000000000); // Overflow\n\n      if (x < -0x400000000000000000) return 0; // Underflow\n\n      uint256 result = 0x80000000000000000000000000000000;\n\n      if (x & 0x8000000000000000 > 0)\n        result = result * 0x16A09E667F3BCC908B2FB1366EA957D3E >> 128;\n      if (x & 0x4000000000000000 > 0)\n        result = result * 0x1306FE0A31B7152DE8D5A46305C85EDEC >> 128;\n      if (x & 0x2000000000000000 > 0)\n        result = result * 0x1172B83C7D517ADCDF7C8C50EB14A791F >> 128;\n      if (x & 0x1000000000000000 > 0)\n        result = result * 0x10B5586CF9890F6298B92B71842A98363 >> 128;\n      if (x & 0x800000000000000 > 0)\n        result = result * 0x1059B0D31585743AE7C548EB68CA417FD >> 128;\n      if (x & 0x400000000000000 > 0)\n        result = result * 0x102C9A3E778060EE6F7CACA4F7A29BDE8 >> 128;\n      if (x & 0x200000000000000 > 0)\n        result = result * 0x10163DA9FB33356D84A66AE336DCDFA3F >> 128;\n      if (x & 0x100000000000000 > 0)\n        result = result * 0x100B1AFA5ABCBED6129AB13EC11DC9543 >> 128;\n      if (x & 0x80000000000000 > 0)\n        result = result * 0x10058C86DA1C09EA1FF19D294CF2F679B >> 128;\n      if (x & 0x40000000000000 > 0)\n        result = result * 0x1002C605E2E8CEC506D21BFC89A23A00F >> 128;\n      if (x & 0x20000000000000 > 0)\n        result = result * 0x100162F3904051FA128BCA9C55C31E5DF >> 128;\n      if (x & 0x10000000000000 > 0)\n        result = result * 0x1000B175EFFDC76BA38E31671CA939725 >> 128;\n      if (x & 0x8000000000000 > 0)\n        result = result * 0x100058BA01FB9F96D6CACD4B180917C3D >> 128;\n      if (x & 0x4000000000000 > 0)\n        result = result * 0x10002C5CC37DA9491D0985C348C68E7B3 >> 128;\n      if (x & 0x2000000000000 > 0)\n        result = result * 0x1000162E525EE054754457D5995292026 >> 128;\n      if (x & 0x1000000000000 > 0)\n        result = result * 0x10000B17255775C040618BF4A4ADE83FC >> 128;\n      if (x & 0x800000000000 > 0)\n        result = result * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB >> 128;\n      if (x & 0x400000000000 > 0)\n        result = result * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9 >> 128;\n      if (x & 0x200000000000 > 0)\n        result = result * 0x10000162E43F4F831060E02D839A9D16D >> 128;\n      if (x & 0x100000000000 > 0)\n        result = result * 0x100000B1721BCFC99D9F890EA06911763 >> 128;\n      if (x & 0x80000000000 > 0)\n        result = result * 0x10000058B90CF1E6D97F9CA14DBCC1628 >> 128;\n      if (x & 0x40000000000 > 0)\n        result = result * 0x1000002C5C863B73F016468F6BAC5CA2B >> 128;\n      if (x & 0x20000000000 > 0)\n        result = result * 0x100000162E430E5A18F6119E3C02282A5 >> 128;\n      if (x & 0x10000000000 > 0)\n        result = result * 0x1000000B1721835514B86E6D96EFD1BFE >> 128;\n      if (x & 0x8000000000 > 0)\n        result = result * 0x100000058B90C0B48C6BE5DF846C5B2EF >> 128;\n      if (x & 0x4000000000 > 0)\n        result = result * 0x10000002C5C8601CC6B9E94213C72737A >> 128;\n      if (x & 0x2000000000 > 0)\n        result = result * 0x1000000162E42FFF037DF38AA2B219F06 >> 128;\n      if (x & 0x1000000000 > 0)\n        result = result * 0x10000000B17217FBA9C739AA5819F44F9 >> 128;\n      if (x & 0x800000000 > 0)\n        result = result * 0x1000000058B90BFCDEE5ACD3C1CEDC823 >> 128;\n      if (x & 0x400000000 > 0)\n        result = result * 0x100000002C5C85FE31F35A6A30DA1BE50 >> 128;\n      if (x & 0x200000000 > 0)\n        result = result * 0x10000000162E42FF0999CE3541B9FFFCF >> 128;\n      if (x & 0x100000000 > 0)\n        result = result * 0x100000000B17217F80F4EF5AADDA45554 >> 128;\n      if (x & 0x80000000 > 0)\n        result = result * 0x10000000058B90BFBF8479BD5A81B51AD >> 128;\n      if (x & 0x40000000 > 0)\n        result = result * 0x1000000002C5C85FDF84BD62AE30A74CC >> 128;\n      if (x & 0x20000000 > 0)\n        result = result * 0x100000000162E42FEFB2FED257559BDAA >> 128;\n      if (x & 0x10000000 > 0)\n        result = result * 0x1000000000B17217F7D5A7716BBA4A9AE >> 128;\n      if (x & 0x8000000 > 0)\n        result = result * 0x100000000058B90BFBE9DDBAC5E109CCE >> 128;\n      if (x & 0x4000000 > 0)\n        result = result * 0x10000000002C5C85FDF4B15DE6F17EB0D >> 128;\n      if (x & 0x2000000 > 0)\n        result = result * 0x1000000000162E42FEFA494F1478FDE05 >> 128;\n      if (x & 0x1000000 > 0)\n        result = result * 0x10000000000B17217F7D20CF927C8E94C >> 128;\n      if (x & 0x800000 > 0)\n        result = result * 0x1000000000058B90BFBE8F71CB4E4B33D >> 128;\n      if (x & 0x400000 > 0)\n        result = result * 0x100000000002C5C85FDF477B662B26945 >> 128;\n      if (x & 0x200000 > 0)\n        result = result * 0x10000000000162E42FEFA3AE53369388C >> 128;\n      if (x & 0x100000 > 0)\n        result = result * 0x100000000000B17217F7D1D351A389D40 >> 128;\n      if (x & 0x80000 > 0)\n        result = result * 0x10000000000058B90BFBE8E8B2D3D4EDE >> 128;\n      if (x & 0x40000 > 0)\n        result = result * 0x1000000000002C5C85FDF4741BEA6E77E >> 128;\n      if (x & 0x20000 > 0)\n        result = result * 0x100000000000162E42FEFA39FE95583C2 >> 128;\n      if (x & 0x10000 > 0)\n        result = result * 0x1000000000000B17217F7D1CFB72B45E1 >> 128;\n      if (x & 0x8000 > 0)\n        result = result * 0x100000000000058B90BFBE8E7CC35C3F0 >> 128;\n      if (x & 0x4000 > 0)\n        result = result * 0x10000000000002C5C85FDF473E242EA38 >> 128;\n      if (x & 0x2000 > 0)\n        result = result * 0x1000000000000162E42FEFA39F02B772C >> 128;\n      if (x & 0x1000 > 0)\n        result = result * 0x10000000000000B17217F7D1CF7D83C1A >> 128;\n      if (x & 0x800 > 0)\n        result = result * 0x1000000000000058B90BFBE8E7BDCBE2E >> 128;\n      if (x & 0x400 > 0)\n        result = result * 0x100000000000002C5C85FDF473DEA871F >> 128;\n      if (x & 0x200 > 0)\n        result = result * 0x10000000000000162E42FEFA39EF44D91 >> 128;\n      if (x & 0x100 > 0)\n        result = result * 0x100000000000000B17217F7D1CF79E949 >> 128;\n      if (x & 0x80 > 0)\n        result = result * 0x10000000000000058B90BFBE8E7BCE544 >> 128;\n      if (x & 0x40 > 0)\n        result = result * 0x1000000000000002C5C85FDF473DE6ECA >> 128;\n      if (x & 0x20 > 0)\n        result = result * 0x100000000000000162E42FEFA39EF366F >> 128;\n      if (x & 0x10 > 0)\n        result = result * 0x1000000000000000B17217F7D1CF79AFA >> 128;\n      if (x & 0x8 > 0)\n        result = result * 0x100000000000000058B90BFBE8E7BCD6D >> 128;\n      if (x & 0x4 > 0)\n        result = result * 0x10000000000000002C5C85FDF473DE6B2 >> 128;\n      if (x & 0x2 > 0)\n        result = result * 0x1000000000000000162E42FEFA39EF358 >> 128;\n      if (x & 0x1 > 0)\n        result = result * 0x10000000000000000B17217F7D1CF79AB >> 128;\n\n      result >>= uint256 (int256 (63 - (x >> 64)));\n      require (result <= uint256 (int256 (MAX_64x64)));\n\n      return int128 (int256 (result));\n    }\n  }\n\n  /**\n   * Calculate natural exponent of x.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function exp (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x < 0x400000000000000000); // Overflow\n\n      if (x < -0x400000000000000000) return 0; // Underflow\n\n      return exp_2 (\n          int128 (int256 (x) * 0x171547652B82FE1777D0FFDA0D23A7D12 >> 128));\n    }\n  }\n\n  /**\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\n   * integer numbers.  Revert on overflow or when y is zero.\n   *\n   * @param x unsigned 256-bit integer number\n   * @param y unsigned 256-bit integer number\n   * @return unsigned 64.64-bit fixed point number\n   */\n  function divuu (uint256 x, uint256 y) private pure returns (uint128) {\n    unchecked {\n      require (y != 0);\n\n      uint256 result;\n\n      if (x <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n        result = (x << 64) / y;\n      else {\n        uint256 msb = 192;\n        uint256 xc = x >> 192;\n        if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\n        if (xc >= 0x10000) { xc >>= 16; msb += 16; }\n        if (xc >= 0x100) { xc >>= 8; msb += 8; }\n        if (xc >= 0x10) { xc >>= 4; msb += 4; }\n        if (xc >= 0x4) { xc >>= 2; msb += 2; }\n        if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\n\n        result = (x << 255 - msb) / ((y - 1 >> msb - 191) + 1);\n        require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n\n        uint256 hi = result * (y >> 128);\n        uint256 lo = result * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n\n        uint256 xh = x >> 192;\n        uint256 xl = x << 64;\n\n        if (xl < lo) xh -= 1;\n        xl -= lo; // We rely on overflow behavior here\n        lo = hi << 128;\n        if (xl < lo) xh -= 1;\n        xl -= lo; // We rely on overflow behavior here\n\n        assert (xh == hi >> 128);\n\n        result += xl / y;\n      }\n\n      require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n      return uint128 (result);\n    }\n  }\n\n  /**\n   * Calculate sqrt (x) rounding down, where x is unsigned 256-bit integer\n   * number.\n   *\n   * @param x unsigned 256-bit integer number\n   * @return unsigned 128-bit integer number\n   */\n  function sqrtu (uint256 x) private pure returns (uint128) {\n    unchecked {\n      if (x == 0) return 0;\n      else {\n        uint256 xx = x;\n        uint256 r = 1;\n        if (xx >= 0x100000000000000000000000000000000) { xx >>= 128; r <<= 64; }\n        if (xx >= 0x10000000000000000) { xx >>= 64; r <<= 32; }\n        if (xx >= 0x100000000) { xx >>= 32; r <<= 16; }\n        if (xx >= 0x10000) { xx >>= 16; r <<= 8; }\n        if (xx >= 0x100) { xx >>= 8; r <<= 4; }\n        if (xx >= 0x10) { xx >>= 4; r <<= 2; }\n        if (xx >= 0x4) { r <<= 1; }\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1; // Seven iterations should be enough\n        uint256 r1 = x / r;\n        return uint128 (r < r1 ? r : r1);\n      }\n    }\n  }\n}\n"},"@solidstate/contracts/interfaces/IERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC165Internal } from './IERC165Internal.sol';\n\n/**\n * @title ERC165 interface registration interface\n * @dev see https://eips.ethereum.org/EIPS/eip-165\n */\ninterface IERC165 is IERC165Internal {\n    /**\n     * @notice query whether contract has registered support for given interface\n     * @param interfaceId interface id\n     * @return bool whether interface is supported\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"},"@solidstate/abdk-math-extensions/contracts/ABDKMath64x64Token.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { ABDKMath64x64 } from 'abdk-libraries-solidity/ABDKMath64x64.sol';\n\n/**\n * @title SolidState token extensions for ABDKMath64x64 library\n */\nlibrary ABDKMath64x64Token {\n    using ABDKMath64x64 for int128;\n\n    /**\n     * @notice convert 64x64 fixed point representation of token amount to decimal\n     * @param value64x64 64x64 fixed point representation of token amount\n     * @param decimals token display decimals\n     * @return value decimal representation of token amount\n     */\n    function toDecimals(int128 value64x64, uint8 decimals)\n        internal\n        pure\n        returns (uint256 value)\n    {\n        value = value64x64.mulu(10**decimals);\n    }\n\n    /**\n     * @notice convert decimal representation of token amount to 64x64 fixed point\n     * @param value decimal representation of token amount\n     * @param decimals token display decimals\n     * @return value64x64 64x64 fixed point representation of token amount\n     */\n    function fromDecimals(uint256 value, uint8 decimals)\n        internal\n        pure\n        returns (int128 value64x64)\n    {\n        value64x64 = ABDKMath64x64.divu(value, 10**decimals);\n    }\n\n    /**\n     * @notice convert 64x64 fixed point representation of token amount to wei (18 decimals)\n     * @param value64x64 64x64 fixed point representation of token amount\n     * @return value wei representation of token amount\n     */\n    function toWei(int128 value64x64) internal pure returns (uint256 value) {\n        value = toDecimals(value64x64, 18);\n    }\n\n    /**\n     * @notice convert wei representation (18 decimals) of token amount to 64x64 fixed point\n     * @param value wei representation of token amount\n     * @return value64x64 64x64 fixed point representation of token amount\n     */\n    function fromWei(uint256 value) internal pure returns (int128 value64x64) {\n        value64x64 = fromDecimals(value, 18);\n    }\n}\n"},"@solidstate/contracts/interfaces/IERC165Internal.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC165Internal } from './IERC165Internal.sol';\n\n/**\n * @title ERC165 interface registration interface\n */\ninterface IERC165Internal {\n\n}\n"},"contracts/mining/PremiaMining.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\r\n// For further clarification please see https://license.premia.legal\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport {OwnableInternal, OwnableStorage} from \"@solidstate/contracts/access/ownable/OwnableInternal.sol\";\r\nimport {IERC20} from \"@solidstate/contracts/interfaces/IERC20.sol\";\r\nimport {SafeERC20} from \"@solidstate/contracts/utils/SafeERC20.sol\";\r\n\r\nimport {PremiaMiningStorage} from \"./PremiaMiningStorage.sol\";\r\nimport {IPremiaMining} from \"./IPremiaMining.sol\";\r\nimport {IPoolIO} from \"../pool/IPoolIO.sol\";\r\nimport {IPoolView} from \"../pool/IPoolView.sol\";\r\nimport {IVxPremia} from \"../staking/IVxPremia.sol\";\r\nimport {VxPremiaStorage} from \"../staking/VxPremiaStorage.sol\";\r\nimport {IProxyManager} from \"../core/IProxyManager.sol\";\r\n\r\n/**\r\n * @title Premia liquidity mining contract, derived from Sushiswap's MasterChef.sol ( https://github.com/sushiswap/sushiswap )\r\n */\r\ncontract PremiaMining is IPremiaMining, OwnableInternal {\r\n    using PremiaMiningStorage for PremiaMiningStorage.Layout;\r\n    using SafeERC20 for IERC20;\r\n\r\n    address internal immutable PROXY_MANAGER;\r\n    address internal immutable PREMIA;\r\n    address internal immutable VX_PREMIA;\r\n\r\n    uint256 private constant ONE_YEAR = 365 days;\r\n    uint256 private constant INVERSE_BASIS_POINT = 1e4;\r\n    uint256 private constant MIN_POINT_MULTIPLIER = 2500; // 25% -> If utilization rate is less than this value, we use this value instead\r\n\r\n    constructor(address _proxyManager, address _premia, address _vxPremia) {\r\n        PROXY_MANAGER = _proxyManager;\r\n        PREMIA = _premia;\r\n        VX_PREMIA = _vxPremia;\r\n    }\r\n\r\n    modifier onlyPool(address _pool) {\r\n        _validatePool(_pool);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice validate that pool is registered on the proxy manager and is the message sender\r\n     * @param _pool pool to validate\r\n     */\r\n    function _validatePool(address _pool) private {\r\n        require(msg.sender == _pool, \"Not pool\");\r\n\r\n        PremiaMiningStorage.Layout storage l = PremiaMiningStorage.layout();\r\n\r\n        if (l.pools[_pool]) return;\r\n\r\n        address[] memory poolList = IProxyManager(PROXY_MANAGER).getPoolList();\r\n\r\n        for (uint256 i = 0; i < poolList.length; i++) {\r\n            l.pools[poolList[i]] = true;\r\n        }\r\n\r\n        require(l.pools[_pool], \"Not pool\");\r\n    }\r\n\r\n    /**\r\n     * @notice Add premia rewards to distribute. Can only be called by the owner\r\n     * @param _amount Amount of premia to add\r\n     */\r\n    function addPremiaRewards(uint256 _amount) external onlyOwner {\r\n        PremiaMiningStorage.Layout storage l = PremiaMiningStorage.layout();\r\n        IERC20(PREMIA).safeTransferFrom(msg.sender, address(this), _amount);\r\n        l.premiaAvailable += _amount;\r\n    }\r\n\r\n    /**\r\n     * @notice Get amount of premia reward available to distribute\r\n     * @return Amount of premia reward available to distribute\r\n     */\r\n    function premiaRewardsAvailable() external view returns (uint256) {\r\n        return PremiaMiningStorage.layout().premiaAvailable;\r\n    }\r\n\r\n    /**\r\n     * @notice Get the total allocation points\r\n     * @return Total allocation points\r\n     */\r\n    function getTotalAllocationPoints() external view returns (uint256) {\r\n        return PremiaMiningStorage.layout().totalAllocPoint;\r\n    }\r\n\r\n    /**\r\n     * @notice Get pool info\r\n     * @param pool address of the pool\r\n     * @param isCallPool whether we want infos of the CALL pool or the PUT pool\r\n     * @return Pool info\r\n     */\r\n    function getPoolInfo(\r\n        address pool,\r\n        bool isCallPool\r\n    ) external view returns (PremiaMiningStorage.PoolInfo memory) {\r\n        return PremiaMiningStorage.layout().poolInfo[pool][isCallPool];\r\n    }\r\n\r\n    /**\r\n     * @notice Get the amount of premia emitted per year\r\n     * @return Premia emitted per year\r\n     */\r\n    function getPremiaPerYear() external view returns (uint256) {\r\n        return PremiaMiningStorage.layout().premiaPerYear;\r\n    }\r\n\r\n    /**\r\n     * @notice Set new alloc points for an option pool. Can only be called by the owner.\r\n     * @param _premiaPerYear Amount of PREMIA per year to allocate as reward across all pools\r\n     */\r\n    function setPremiaPerYear(uint256 _premiaPerYear) external onlyOwner {\r\n        PremiaMiningStorage.layout().premiaPerYear = _premiaPerYear;\r\n    }\r\n\r\n    function _setPoolAllocPoints(\r\n        PremiaMiningStorage.Layout storage l,\r\n        IPremiaMining.PoolAllocPoints memory _data\r\n    ) internal {\r\n        if (_data.poolUtilizationRateBPS < MIN_POINT_MULTIPLIER) {\r\n            _data.poolUtilizationRateBPS = MIN_POINT_MULTIPLIER;\r\n        }\r\n\r\n        uint256 allocPoints = (_data.votes * _data.poolUtilizationRateBPS) /\r\n            INVERSE_BASIS_POINT;\r\n\r\n        l.totalAllocPoint =\r\n            l.totalAllocPoint -\r\n            l.poolInfo[_data.pool][_data.isCallPool].allocPoint +\r\n            allocPoints;\r\n        l.poolInfo[_data.pool][_data.isCallPool].allocPoint = allocPoints;\r\n\r\n        // If alloc points set for a new pool, we initialize the last reward timestamp\r\n        if (l.poolInfo[_data.pool][_data.isCallPool].lastRewardTimestamp == 0) {\r\n            l.poolInfo[_data.pool][_data.isCallPool].lastRewardTimestamp = block\r\n                .timestamp;\r\n        }\r\n\r\n        emit UpdatePoolAlloc(\r\n            _data.pool,\r\n            _data.isCallPool,\r\n            _data.votes,\r\n            _data.poolUtilizationRateBPS\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Get pending premia reward for a user on a pool\r\n     * @param _pool Address of option pool contract\r\n     * @param _isCallPool True if for call option pool, False if for put option pool\r\n     */\r\n    function pendingPremia(\r\n        address _pool,\r\n        bool _isCallPool,\r\n        address _user\r\n    ) external view returns (uint256) {\r\n        uint256 TVL;\r\n        uint256 userTVL;\r\n\r\n        {\r\n            (uint256 underlyingTVL, uint256 baseTVL) = IPoolView(_pool)\r\n                .getTotalTVL();\r\n            TVL = _isCallPool ? underlyingTVL : baseTVL;\r\n        }\r\n\r\n        {\r\n            (uint256 userUnderlyingTVL, uint256 userBaseTVL) = IPoolView(_pool)\r\n                .getUserTVL(_user);\r\n            userTVL = _isCallPool ? userUnderlyingTVL : userBaseTVL;\r\n        }\r\n\r\n        PremiaMiningStorage.Layout storage l = PremiaMiningStorage.layout();\r\n        PremiaMiningStorage.PoolInfo storage pool = l.poolInfo[_pool][\r\n            _isCallPool\r\n        ];\r\n\r\n        PremiaMiningStorage.UserInfo storage user = l.userInfo[_pool][\r\n            _isCallPool\r\n        ][_user];\r\n        uint256 accPremiaPerShare = pool.accPremiaPerShare;\r\n\r\n        if (\r\n            block.timestamp > pool.lastRewardTimestamp &&\r\n            TVL > 0 &&\r\n            pool.allocPoint > 0\r\n        ) {\r\n            uint256 premiaReward = (((block.timestamp -\r\n                pool.lastRewardTimestamp) * l.premiaPerYear) *\r\n                pool.allocPoint) /\r\n                l.totalAllocPoint /\r\n                ONE_YEAR;\r\n\r\n            // If we are running out of rewards to distribute, distribute whats left\r\n            if (premiaReward > l.premiaAvailable) {\r\n                premiaReward = l.premiaAvailable;\r\n            }\r\n\r\n            accPremiaPerShare += (premiaReward * 1e12) / TVL;\r\n        }\r\n        return\r\n            ((userTVL * accPremiaPerShare) / 1e12) -\r\n            user.rewardDebt +\r\n            user.reward;\r\n    }\r\n\r\n    /**\r\n     * @notice Update reward variables of the given pool to be up-to-date. Only callable by the option pool\r\n     * @param _pool Address of option pool contract\r\n     * @param _isCallPool True if for call option pool, False if for put option pool\r\n     * @param _totalTVL Total amount of tokens deposited in the option pool\r\n     * @param _utilizationRate Utilization rate of the pool (1e4 = 100%)\r\n     */\r\n    function updatePool(\r\n        address _pool,\r\n        bool _isCallPool,\r\n        uint256 _totalTVL,\r\n        uint256 _utilizationRate\r\n    ) external onlyPool(_pool) {\r\n        _updatePool(_pool, _isCallPool, _totalTVL, _utilizationRate);\r\n    }\r\n\r\n    /**\r\n     * @notice Update reward variables of the given pool to be up-to-date. Only callable by the option pool\r\n     * @param _pool Address of option pool contract\r\n     * @param _isCallPool True if for call option pool, False if for put option pool\r\n     * @param _totalTVL Total amount of tokens deposited in the option pool\r\n     * @param _utilizationRate Utilization rate of the pool (1e4 = 100%)\r\n     */\r\n    function _updatePool(\r\n        address _pool,\r\n        bool _isCallPool,\r\n        uint256 _totalTVL,\r\n        uint256 _utilizationRate\r\n    ) internal {\r\n        PremiaMiningStorage.Layout storage l = PremiaMiningStorage.layout();\r\n\r\n        PremiaMiningStorage.PoolInfo storage pool = l.poolInfo[_pool][\r\n            _isCallPool\r\n        ];\r\n\r\n        if (block.timestamp <= pool.lastRewardTimestamp) {\r\n            return;\r\n        }\r\n\r\n        if (_totalTVL > 0 && pool.allocPoint > 0) {\r\n            uint256 premiaReward = (((block.timestamp -\r\n                pool.lastRewardTimestamp) * l.premiaPerYear) *\r\n                pool.allocPoint) /\r\n                l.totalAllocPoint /\r\n                ONE_YEAR;\r\n\r\n            // If we are running out of rewards to distribute, distribute whats left\r\n            if (premiaReward > l.premiaAvailable) {\r\n                premiaReward = l.premiaAvailable;\r\n            }\r\n\r\n            l.premiaAvailable -= premiaReward;\r\n            pool.accPremiaPerShare += (premiaReward * 1e12) / _totalTVL;\r\n        }\r\n\r\n        pool.lastRewardTimestamp = block.timestamp;\r\n\r\n        _updatePoolAllocPoints(l, _pool, _isCallPool, _utilizationRate);\r\n    }\r\n\r\n    function _updatePoolAllocPoints(\r\n        PremiaMiningStorage.Layout storage l,\r\n        address pool,\r\n        bool isCallPool,\r\n        uint256 utilizationRate\r\n    ) internal virtual {\r\n        uint256 votes = IVxPremia(VX_PREMIA).getPoolVotes(\r\n            VxPremiaStorage.VoteVersion.V2,\r\n            abi.encodePacked(pool, isCallPool)\r\n        );\r\n        _setPoolAllocPoints(\r\n            l,\r\n            IPremiaMining.PoolAllocPoints(\r\n                pool,\r\n                isCallPool,\r\n                votes,\r\n                utilizationRate\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Allocate pending rewards to a user. Only callable by the option pool\r\n     * @param _user User for whom allocate the rewards\r\n     * @param _pool Address of option pool contract\r\n     * @param _isCallPool True if for call option pool, False if for put option pool\r\n     * @param _userTVLOld Total amount of tokens deposited in the option pool by user before the allocation update\r\n     * @param _userTVLNew Total amount of tokens deposited in the option pool by user after the allocation update\r\n     * @param _totalTVL Total amount of tokens deposited in the option pool\r\n     * @param _utilizationRate Utilization rate of the pool (1e4 = 100%)\r\n     */\r\n    function allocatePending(\r\n        address _user,\r\n        address _pool,\r\n        bool _isCallPool,\r\n        uint256 _userTVLOld,\r\n        uint256 _userTVLNew,\r\n        uint256 _totalTVL,\r\n        uint256 _utilizationRate\r\n    ) external onlyPool(_pool) {\r\n        _allocatePending(\r\n            _user,\r\n            _pool,\r\n            _isCallPool,\r\n            _userTVLOld,\r\n            _userTVLNew,\r\n            _totalTVL,\r\n            _utilizationRate\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Allocate pending rewards to a user. Only callable by the option pool\r\n     * @param _user User for whom allocate the rewards\r\n     * @param _pool Address of option pool contract\r\n     * @param _isCallPool True if for call option pool, False if for put option pool\r\n     * @param _userTVLOld Total amount of tokens deposited in the option pool by user before the allocation update\r\n     * @param _userTVLNew Total amount of tokens deposited in the option pool by user after the allocation update\r\n     * @param _totalTVL Total amount of tokens deposited in the option pool\r\n     * @param _utilizationRate Utilization rate of the pool (1e4 = 100%)\r\n     */\r\n    function _allocatePending(\r\n        address _user,\r\n        address _pool,\r\n        bool _isCallPool,\r\n        uint256 _userTVLOld,\r\n        uint256 _userTVLNew,\r\n        uint256 _totalTVL,\r\n        uint256 _utilizationRate\r\n    ) internal {\r\n        PremiaMiningStorage.Layout storage l = PremiaMiningStorage.layout();\r\n        PremiaMiningStorage.PoolInfo storage pool = l.poolInfo[_pool][\r\n            _isCallPool\r\n        ];\r\n        PremiaMiningStorage.UserInfo storage user = l.userInfo[_pool][\r\n            _isCallPool\r\n        ][_user];\r\n\r\n        _updatePool(_pool, _isCallPool, _totalTVL, _utilizationRate);\r\n\r\n        user.reward +=\r\n            ((_userTVLOld * pool.accPremiaPerShare) / 1e12) -\r\n            user.rewardDebt;\r\n\r\n        user.rewardDebt = (_userTVLNew * pool.accPremiaPerShare) / 1e12;\r\n    }\r\n\r\n    /**\r\n     * @notice Update user reward allocation + claim allocated PREMIA reward. Only callable by the option pool\r\n     * @param _user User claiming the rewards\r\n     * @param _pool Address of option pool contract\r\n     * @param _isCallPool True if for call option pool, False if for put option pool\r\n     * @param _userTVLOld Total amount of tokens deposited in the option pool by user before the allocation update\r\n     * @param _userTVLNew Total amount of tokens deposited in the option pool by user after the allocation update\r\n     * @param _totalTVL Total amount of tokens deposited in the option pool\r\n     * @param _utilizationRate Utilization rate of the pool (1e4 = 100%)\r\n     */\r\n    function claim(\r\n        address _user,\r\n        address _pool,\r\n        bool _isCallPool,\r\n        uint256 _userTVLOld,\r\n        uint256 _userTVLNew,\r\n        uint256 _totalTVL,\r\n        uint256 _utilizationRate\r\n    ) external onlyPool(_pool) {\r\n        PremiaMiningStorage.Layout storage l = PremiaMiningStorage.layout();\r\n\r\n        _allocatePending(\r\n            _user,\r\n            _pool,\r\n            _isCallPool,\r\n            _userTVLOld,\r\n            _userTVLNew,\r\n            _totalTVL,\r\n            _utilizationRate\r\n        );\r\n\r\n        uint256 reward = l.userInfo[_pool][_isCallPool][_user].reward;\r\n        l.userInfo[_pool][_isCallPool][_user].reward = 0;\r\n        _safePremiaTransfer(_user, reward);\r\n\r\n        emit Claim(_user, _pool, _isCallPool, reward);\r\n    }\r\n\r\n    /**\r\n     * @notice Trigger reward distribution by multiple pools\r\n     * @param account address whose rewards to claim\r\n     * @param pools list of pools to call\r\n     * @param isCall list of bools indicating whether each pool is call pool\r\n     */\r\n    function multiClaim(\r\n        address account,\r\n        address[] calldata pools,\r\n        bool[] calldata isCall\r\n    ) external {\r\n        require(pools.length == isCall.length);\r\n\r\n        for (uint256 i; i < pools.length; i++) {\r\n            IPoolIO(pools[i]).claimRewards(account, isCall[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Safe premia transfer function, just in case if rounding error causes pool to not have enough PREMIA.\r\n     * @param _to Address where to transfer the Premia\r\n     * @param _amount Amount of tokens to transfer\r\n     */\r\n    function _safePremiaTransfer(address _to, uint256 _amount) internal {\r\n        IERC20 premia = IERC20(PREMIA);\r\n\r\n        uint256 premiaBal = premia.balanceOf(address(this));\r\n        if (_amount > premiaBal) {\r\n            premia.safeTransfer(_to, premiaBal);\r\n        } else {\r\n            premia.safeTransfer(_to, _amount);\r\n        }\r\n    }\r\n}\r\n"},"contracts/staking/IPremiaStaking.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-or-later\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport {PremiaStakingStorage} from \"./PremiaStakingStorage.sol\";\r\nimport {IOFT} from \"../layerZero/token/oft/IOFT.sol\";\r\n\r\nimport {IERC2612} from \"@solidstate/contracts/token/ERC20/permit/IERC2612.sol\";\r\n\r\n// IERC20Metadata inheritance not possible due to linearization issue\r\ninterface IPremiaStaking is IERC2612, IOFT {\r\n    error PremiaStaking__CantTransfer();\r\n    error PremiaStaking__ExcessiveStakePeriod();\r\n    error PremiaStaking__InsufficientSwapOutput();\r\n    error PremiaStaking__NoPendingWithdrawal();\r\n    error PremiaStaking__NotEnoughLiquidity();\r\n    error PremiaStaking__PeriodTooShort();\r\n    error PremiaStaking__StakeLocked();\r\n    error PremiaStaking__StakeNotLocked();\r\n    error PremiaStaking__WithdrawalStillPending();\r\n\r\n    event Stake(\r\n        address indexed user,\r\n        uint256 amount,\r\n        uint64 stakePeriod,\r\n        uint64 lockedUntil\r\n    );\r\n\r\n    event Unstake(\r\n        address indexed user,\r\n        uint256 amount,\r\n        uint256 fee,\r\n        uint256 startDate\r\n    );\r\n\r\n    event Harvest(address indexed user, uint256 amount);\r\n\r\n    event EarlyUnstakeRewardCollected(address indexed user, uint256 amount);\r\n\r\n    event Withdraw(address indexed user, uint256 amount);\r\n\r\n    event RewardsAdded(uint256 amount);\r\n\r\n    struct StakeLevel {\r\n        uint256 amount; // Amount to stake\r\n        uint256 discountBPS; // Discount when amount is reached\r\n    }\r\n\r\n    struct SwapArgs {\r\n        //min amount out to be used to purchase\r\n        uint256 amountOutMin;\r\n        // exchange address to call to execute the trade\r\n        address callee;\r\n        // address for which to set allowance for the trade\r\n        address allowanceTarget;\r\n        // data to execute the trade\r\n        bytes data;\r\n        // address to which refund excess tokens\r\n        address refundAddress;\r\n    }\r\n\r\n    event BridgeLock(\r\n        address indexed user,\r\n        uint64 stakePeriod,\r\n        uint64 lockedUntil\r\n    );\r\n\r\n    event UpdateLock(\r\n        address indexed user,\r\n        uint64 oldStakePeriod,\r\n        uint64 newStakePeriod\r\n    );\r\n\r\n    /**\r\n     * @notice Returns the reward token address\r\n     * @return The reward token address\r\n     */\r\n    function getRewardToken() external view returns (address);\r\n\r\n    /**\r\n     * @notice add premia tokens as available tokens to be distributed as rewards\r\n     * @param amount amount of premia tokens to add as rewards\r\n     */\r\n    function addRewards(uint256 amount) external;\r\n\r\n    /**\r\n     * @notice get amount of tokens that have not yet been distributed as rewards\r\n     * @return rewards amount of tokens not yet distributed as rewards\r\n     * @return unstakeRewards amount of PREMIA not yet claimed from early unstake fees\r\n     */\r\n    function getAvailableRewards()\r\n        external\r\n        view\r\n        returns (uint256 rewards, uint256 unstakeRewards);\r\n\r\n    /**\r\n     * @notice get pending amount of tokens to be distributed as rewards to stakers\r\n     * @return amount of tokens pending to be distributed as rewards\r\n     */\r\n    function getPendingRewards() external view returns (uint256);\r\n\r\n    /**\r\n     * @notice get pending withdrawal data of a user\r\n     * @return amount pending withdrawal amount\r\n     * @return startDate start timestamp of withdrawal\r\n     * @return unlockDate timestamp at which withdrawal becomes available\r\n     */\r\n    function getPendingWithdrawal(\r\n        address user\r\n    )\r\n        external\r\n        view\r\n        returns (uint256 amount, uint256 startDate, uint256 unlockDate);\r\n\r\n    /**\r\n     * @notice get the amount of PREMIA available for withdrawal\r\n     * @return amount of PREMIA available for withdrawal\r\n     */\r\n    function getAvailablePremiaAmount() external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Stake using IERC2612 permit\r\n     * @param amount The amount of xPremia to stake\r\n     * @param period The lockup period (in seconds)\r\n     * @param deadline Deadline after which permit will fail\r\n     * @param v V\r\n     * @param r R\r\n     * @param s S\r\n     */\r\n    function stakeWithPermit(\r\n        uint256 amount,\r\n        uint64 period,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Lockup xPremia for protocol fee discounts\r\n     *          Longer period of locking will apply a multiplier on the amount staked, in the fee discount calculation\r\n     * @param amount The amount of xPremia to stake\r\n     * @param period The lockup period (in seconds)\r\n     */\r\n    function stake(uint256 amount, uint64 period) external;\r\n\r\n    /**\r\n     * @notice update vxPremia lock\r\n     * @param period The new lockup period (in seconds)\r\n     */\r\n    function updateLock(uint64 period) external;\r\n\r\n    /**\r\n     * @notice harvest rewards, convert to PREMIA using exchange helper, and stake\r\n     * @param s swap arguments\r\n     * @param stakePeriod The lockup period (in seconds)\r\n     */\r\n    function harvestAndStake(\r\n        IPremiaStaking.SwapArgs memory s,\r\n        uint64 stakePeriod\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Harvest rewards directly to user wallet\r\n     */\r\n    function harvest() external;\r\n\r\n    /**\r\n     * @notice Get pending rewards amount, including pending pool update\r\n     * @param user User for which to calculate pending rewards\r\n     * @return reward amount of pending rewards from protocol fees (in REWARD_TOKEN)\r\n     * @return unstakeReward amount of pending rewards from early unstake fees (in PREMIA)\r\n     */\r\n    function getPendingUserRewards(\r\n        address user\r\n    ) external view returns (uint256 reward, uint256 unstakeReward);\r\n\r\n    /**\r\n     * @notice unstake tokens before end of the lock period, for a fee\r\n     * @param amount the amount of vxPremia to unstake\r\n     */\r\n    function earlyUnstake(uint256 amount) external;\r\n\r\n    /**\r\n     * @notice get early unstake fee for given user\r\n     * @param user address of the user\r\n     * @return feePercentage % fee to pay for early unstake (1e4 = 100%)\r\n     */\r\n    function getEarlyUnstakeFeeBPS(\r\n        address user\r\n    ) external view returns (uint256 feePercentage);\r\n\r\n    /**\r\n     * @notice Initiate the withdrawal process by burning xPremia, starting the delay period\r\n     * @param amount quantity of xPremia to unstake\r\n     */\r\n    function startWithdraw(uint256 amount) external;\r\n\r\n    /**\r\n     * @notice Withdraw underlying premia\r\n     */\r\n    function withdraw() external;\r\n\r\n    //////////\r\n    // View //\r\n    //////////\r\n\r\n    /**\r\n     * Calculate the stake amount of a user, after applying the bonus from the lockup period chosen\r\n     * @param user The user from which to query the stake amount\r\n     * @return The user stake amount after applying the bonus\r\n     */\r\n    function getUserPower(address user) external view returns (uint256);\r\n\r\n    /**\r\n     * Return the total power across all users (applying the bonus from lockup period chosen)\r\n     * @return The total power across all users\r\n     */\r\n    function getTotalPower() external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Calculate the % of fee discount for user, based on his stake\r\n     * @param user The _user for which the discount is for\r\n     * @return Percentage of protocol fee discount (in basis point)\r\n     *         Ex : 1000 = 10% fee discount\r\n     */\r\n    function getDiscountBPS(address user) external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Get stake levels\r\n     * @return Stake levels\r\n     *         Ex : 2500 = -25%\r\n     */\r\n    function getStakeLevels() external returns (StakeLevel[] memory);\r\n\r\n    /**\r\n     * @notice Get stake period multiplier\r\n     * @param period The duration (in seconds) for which tokens are locked\r\n     * @return The multiplier for this staking period\r\n     *         Ex : 20000 = x2\r\n     */\r\n    function getStakePeriodMultiplierBPS(\r\n        uint256 period\r\n    ) external returns (uint256);\r\n\r\n    /**\r\n     * @notice Get staking infos of a user\r\n     * @param user The user address for which to get staking infos\r\n     * @return The staking infos of the user\r\n     */\r\n    function getUserInfo(\r\n        address user\r\n    ) external view returns (PremiaStakingStorage.UserInfo memory);\r\n}\r\n"},"contracts/pool/IPoolInternal.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-or-later\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IPoolInternal {\r\n    struct SwapArgs {\r\n        // token to pass in to swap\r\n        address tokenIn;\r\n        // amount of tokenIn to trade\r\n        uint256 amountInMax;\r\n        //min amount out to be used to purchase\r\n        uint256 amountOutMin;\r\n        // exchange address to call to execute the trade\r\n        address callee;\r\n        // address for which to set allowance for the trade\r\n        address allowanceTarget;\r\n        // data to execute the trade\r\n        bytes data;\r\n        // address to which refund excess tokens\r\n        address refundAddress;\r\n    }\r\n}\r\n"},"@solidstate/contracts/token/ERC20/ISolidStateERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC20Base } from './base/IERC20Base.sol';\nimport { IERC20Extended } from './extended/IERC20Extended.sol';\nimport { IERC20Metadata } from './metadata/IERC20Metadata.sol';\nimport { IERC20Permit } from './permit/IERC20Permit.sol';\n\ninterface ISolidStateERC20 is\n    IERC20Base,\n    IERC20Extended,\n    IERC20Metadata,\n    IERC20Permit\n{}\n"},"@solidstate/contracts/token/ERC20/permit/IERC20Permit.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC20Metadata } from '../metadata/IERC20Metadata.sol';\nimport { IERC2612 } from './IERC2612.sol';\nimport { IERC20PermitInternal } from './IERC20PermitInternal.sol';\n\n// TODO: note that IERC20Metadata is needed for eth-permit library\n\ninterface IERC20Permit is IERC20PermitInternal, IERC2612 {\n\n}\n"},"contracts/layerZero/token/oft/IOFTCore.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport {IERC20} from \"@solidstate/contracts/interfaces/IERC20.sol\";\r\nimport {IERC165} from \"@solidstate/contracts/interfaces/IERC165.sol\";\r\n\r\n/**\r\n * @dev Interface of the IOFT core standard\r\n */\r\ninterface IOFTCore is IERC165 {\r\n    /**\r\n     * @dev estimate send token `tokenId` to (`dstChainId`, `toAddress`)\r\n     * dstChainId - L0 defined chain id to send tokens too\r\n     * toAddress - dynamic bytes array which contains the address to whom you are sending tokens to on the dstChain\r\n     * amount - amount of the tokens to transfer\r\n     * useZro - indicates to use zro to pay L0 fees\r\n     * adapterParam - flexible bytes array to indicate messaging adapter services in L0\r\n     */\r\n    function estimateSendFee(\r\n        uint16 dstChainId,\r\n        bytes calldata toAddress,\r\n        uint256 amount,\r\n        bool useZro,\r\n        bytes calldata adapterParams\r\n    ) external view returns (uint256 nativeFee, uint256 zroFee);\r\n\r\n    /**\r\n     * @dev send `amount` amount of token to (`dstChainId`, `toAddress`) from `from`\r\n     * `from` the owner of token\r\n     * `dstChainId` the destination chain identifier\r\n     * `toAddress` can be any size depending on the `dstChainId`.\r\n     * `amount` the quantity of tokens in wei\r\n     * `refundAddress` the address LayerZero refunds if too much message fee is sent\r\n     * `zroPaymentAddress` set to address(0x0) if not paying in ZRO (LayerZero Token)\r\n     * `adapterParams` is a flexible bytes array to indicate messaging adapter services\r\n     */\r\n    function sendFrom(\r\n        address from,\r\n        uint16 dstChainId,\r\n        bytes calldata toAddress,\r\n        uint256 amount,\r\n        address payable refundAddress,\r\n        address zroPaymentAddress,\r\n        bytes calldata adapterParams\r\n    ) external payable;\r\n\r\n    /**\r\n     * @dev returns the circulating amount of tokens on current chain\r\n     */\r\n    function circulatingSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Emitted when `amount` tokens are moved from the `sender` to (`dstChainId`, `toAddress`)\r\n     * `nonce` is the outbound nonce\r\n     */\r\n    event SendToChain(\r\n        address indexed sender,\r\n        uint16 indexed dstChainId,\r\n        bytes indexed toAddress,\r\n        uint256 amount\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when `amount` tokens are received from `srcChainId` into the `toAddress` on the local chain.\r\n     * `nonce` is the inbound nonce.\r\n     */\r\n    event ReceiveFromChain(\r\n        uint16 indexed srcChainId,\r\n        bytes indexed srcAddress,\r\n        address indexed toAddress,\r\n        uint256 amount\r\n    );\r\n\r\n    event SetUseCustomAdapterParams(bool _useCustomAdapterParams);\r\n}\r\n"},"@solidstate/contracts/interfaces/IERC173.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC173Internal } from './IERC173Internal.sol';\n\n/**\n * @title Contract ownership standard interface\n * @dev see https://eips.ethereum.org/EIPS/eip-173\n */\ninterface IERC173 is IERC173Internal {\n    /**\n     * @notice get the ERC173 contract owner\n     * @return conrtact owner\n     */\n    function owner() external view returns (address);\n\n    /**\n     * @notice transfer contract ownership to new account\n     * @param account address of new owner\n     */\n    function transferOwnership(address account) external;\n}\n"},"@solidstate/contracts/access/ownable/OwnableStorage.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nlibrary OwnableStorage {\n    struct Layout {\n        address owner;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.Ownable');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"},"@solidstate/contracts/token/ERC20/extended/IERC20ExtendedInternal.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC20BaseInternal } from '../base/IERC20BaseInternal.sol';\n\n/**\n * @title ERC20 extended internal interface\n */\ninterface IERC20ExtendedInternal is IERC20BaseInternal {\n    error ERC20Extended__ExcessiveAllowance();\n    error ERC20Extended__InsufficientAllowance();\n}\n"},"@solidstate/contracts/utils/AddressUtils.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { UintUtils } from './UintUtils.sol';\n\nlibrary AddressUtils {\n    using UintUtils for uint256;\n\n    error AddressUtils__InsufficientBalance();\n    error AddressUtils__NotContract();\n    error AddressUtils__SendValueFailed();\n\n    function toString(address account) internal pure returns (string memory) {\n        return uint256(uint160(account)).toHexString(20);\n    }\n\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    function sendValue(address payable account, uint256 amount) internal {\n        (bool success, ) = account.call{ value: amount }('');\n        if (!success) revert AddressUtils__SendValueFailed();\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data\n    ) internal returns (bytes memory) {\n        return\n            functionCall(target, data, 'AddressUtils: failed low-level call');\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory error\n    ) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, error);\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return\n            functionCallWithValue(\n                target,\n                data,\n                value,\n                'AddressUtils: failed low-level call with value'\n            );\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory error\n    ) internal returns (bytes memory) {\n        if (value > address(this).balance)\n            revert AddressUtils__InsufficientBalance();\n        return _functionCallWithValue(target, data, value, error);\n    }\n\n    /**\n     * @notice execute arbitrary external call with limited gas usage and amount of copied return data\n     * @dev derived from https://github.com/nomad-xyz/ExcessivelySafeCall (MIT License)\n     * @param target recipient of call\n     * @param gasAmount gas allowance for call\n     * @param value native token value to include in call\n     * @param maxCopy maximum number of bytes to copy from return data\n     * @param data encoded call data\n     * @return success whether call is successful\n     * @return returnData copied return data\n     */\n    function excessivelySafeCall(\n        address target,\n        uint256 gasAmount,\n        uint256 value,\n        uint16 maxCopy,\n        bytes memory data\n    ) internal returns (bool success, bytes memory returnData) {\n        returnData = new bytes(maxCopy);\n\n        assembly {\n            // execute external call via assembly to avoid automatic copying of return data\n            success := call(\n                gasAmount,\n                target,\n                value,\n                add(data, 0x20),\n                mload(data),\n                0,\n                0\n            )\n\n            // determine whether to limit amount of data to copy\n            let toCopy := returndatasize()\n\n            if gt(toCopy, maxCopy) {\n                toCopy := maxCopy\n            }\n\n            // store the length of the copied bytes\n            mstore(returnData, toCopy)\n\n            // copy the bytes from returndata[0:toCopy]\n            returndatacopy(add(returnData, 0x20), 0, toCopy)\n        }\n    }\n\n    function _functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory error\n    ) private returns (bytes memory) {\n        if (!isContract(target)) revert AddressUtils__NotContract();\n\n        (bool success, bytes memory returnData) = target.call{ value: value }(\n            data\n        );\n\n        if (success) {\n            return returnData;\n        } else if (returnData.length > 0) {\n            assembly {\n                let returnData_size := mload(returnData)\n                revert(add(32, returnData), returnData_size)\n            }\n        } else {\n            revert(error);\n        }\n    }\n}\n"},"contracts/libraries/OptionMath.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\r\n// For further clarification please see https://license.premia.legal\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport {ABDKMath64x64} from \"abdk-libraries-solidity/ABDKMath64x64.sol\";\r\n\r\nlibrary OptionMath {\r\n    using ABDKMath64x64 for int128;\r\n\r\n    struct QuoteArgs {\r\n        int128 varianceAnnualized64x64; // 64x64 fixed point representation of annualized variance\r\n        int128 strike64x64; // 64x64 fixed point representation of strike price\r\n        int128 spot64x64; // 64x64 fixed point representation of spot price\r\n        int128 timeToMaturity64x64; // 64x64 fixed point representation of duration of option contract (in years)\r\n        int128 oldCLevel64x64; // 64x64 fixed point representation of C-Level of Pool before purchase\r\n        int128 oldPoolState; // 64x64 fixed point representation of current state of the pool\r\n        int128 newPoolState; // 64x64 fixed point representation of state of the pool after trade\r\n        int128 steepness64x64; // 64x64 fixed point representation of Pool state delta multiplier\r\n        int128 minAPY64x64; // 64x64 fixed point representation of minimum APY for capital locked up to underwrite options\r\n        bool isCall; // whether to price \"call\" or \"put\" option\r\n    }\r\n\r\n    struct CalculateCLevelDecayArgs {\r\n        int128 timeIntervalsElapsed64x64; // 64x64 fixed point representation of quantity of discrete arbitrary intervals elapsed since last update\r\n        int128 oldCLevel64x64; // 64x64 fixed point representation of C-Level prior to accounting for decay\r\n        int128 utilization64x64; // 64x64 fixed point representation of pool capital utilization rate\r\n        int128 utilizationLowerBound64x64;\r\n        int128 utilizationUpperBound64x64;\r\n        int128 cLevelLowerBound64x64;\r\n        int128 cLevelUpperBound64x64;\r\n        int128 cConvergenceULowerBound64x64;\r\n        int128 cConvergenceUUpperBound64x64;\r\n    }\r\n\r\n    // 64x64 fixed point integer constants\r\n    int128 internal constant ONE_64x64 = 0x10000000000000000;\r\n    int128 internal constant THREE_64x64 = 0x30000000000000000;\r\n\r\n    // 64x64 fixed point constants used in Choudhury’s approximation of the Black-Scholes CDF\r\n    int128 private constant CDF_CONST_0 = 0x09109f285df452394; // 2260 / 3989\r\n    int128 private constant CDF_CONST_1 = 0x19abac0ea1da65036; // 6400 / 3989\r\n    int128 private constant CDF_CONST_2 = 0x0d3c84b78b749bd6b; // 3300 / 3989\r\n\r\n    /**\r\n     * @notice recalculate C-Level based on change in liquidity\r\n     * @param initialCLevel64x64 64x64 fixed point representation of C-Level of Pool before update\r\n     * @param oldPoolState64x64 64x64 fixed point representation of liquidity in pool before update\r\n     * @param newPoolState64x64 64x64 fixed point representation of liquidity in pool after update\r\n     * @param steepness64x64 64x64 fixed point representation of steepness coefficient\r\n     * @return 64x64 fixed point representation of new C-Level\r\n     */\r\n    function calculateCLevel(\r\n        int128 initialCLevel64x64,\r\n        int128 oldPoolState64x64,\r\n        int128 newPoolState64x64,\r\n        int128 steepness64x64\r\n    ) external pure returns (int128) {\r\n        return\r\n            newPoolState64x64\r\n                .sub(oldPoolState64x64)\r\n                .div(\r\n                    oldPoolState64x64 > newPoolState64x64\r\n                        ? oldPoolState64x64\r\n                        : newPoolState64x64\r\n                )\r\n                .mul(steepness64x64)\r\n                .neg()\r\n                .exp()\r\n                .mul(initialCLevel64x64);\r\n    }\r\n\r\n    /**\r\n     * @notice calculate the price of an option using the Premia Finance model\r\n     * @param args arguments of quotePrice\r\n     * @return premiaPrice64x64 64x64 fixed point representation of Premia option price\r\n     * @return cLevel64x64 64x64 fixed point representation of C-Level of Pool after purchase\r\n     */\r\n    function quotePrice(\r\n        QuoteArgs memory args\r\n    )\r\n        external\r\n        pure\r\n        returns (\r\n            int128 premiaPrice64x64,\r\n            int128 cLevel64x64,\r\n            int128 slippageCoefficient64x64\r\n        )\r\n    {\r\n        int128 deltaPoolState64x64 = args\r\n            .newPoolState\r\n            .sub(args.oldPoolState)\r\n            .div(args.oldPoolState)\r\n            .mul(args.steepness64x64);\r\n        int128 tradingDelta64x64 = deltaPoolState64x64.neg().exp();\r\n\r\n        int128 blackScholesPrice64x64 = _blackScholesPrice(\r\n            args.varianceAnnualized64x64,\r\n            args.strike64x64,\r\n            args.spot64x64,\r\n            args.timeToMaturity64x64,\r\n            args.isCall\r\n        );\r\n\r\n        cLevel64x64 = tradingDelta64x64.mul(args.oldCLevel64x64);\r\n        slippageCoefficient64x64 = ONE_64x64.sub(tradingDelta64x64).div(\r\n            deltaPoolState64x64\r\n        );\r\n\r\n        premiaPrice64x64 = blackScholesPrice64x64.mul(cLevel64x64).mul(\r\n            slippageCoefficient64x64\r\n        );\r\n\r\n        int128 intrinsicValue64x64;\r\n\r\n        if (args.isCall && args.strike64x64 < args.spot64x64) {\r\n            intrinsicValue64x64 = args.spot64x64.sub(args.strike64x64);\r\n        } else if (!args.isCall && args.strike64x64 > args.spot64x64) {\r\n            intrinsicValue64x64 = args.strike64x64.sub(args.spot64x64);\r\n        }\r\n\r\n        int128 collateralValue64x64 = args.isCall\r\n            ? args.spot64x64\r\n            : args.strike64x64;\r\n\r\n        int128 minPrice64x64 = intrinsicValue64x64.add(\r\n            collateralValue64x64.mul(args.minAPY64x64).mul(\r\n                args.timeToMaturity64x64\r\n            )\r\n        );\r\n\r\n        if (minPrice64x64 > premiaPrice64x64) {\r\n            premiaPrice64x64 = minPrice64x64;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice calculate the decay of C-Level based on heat diffusion function\r\n     * @param args structured CalculateCLevelDecayArgs\r\n     * @return cLevelDecayed64x64 C-Level after accounting for decay\r\n     */\r\n    function calculateCLevelDecay(\r\n        CalculateCLevelDecayArgs memory args\r\n    ) external pure returns (int128 cLevelDecayed64x64) {\r\n        int128 convFHighU64x64 = (args.utilization64x64 >=\r\n            args.utilizationUpperBound64x64 &&\r\n            args.oldCLevel64x64 <= args.cLevelLowerBound64x64)\r\n            ? ONE_64x64\r\n            : int128(0);\r\n\r\n        int128 convFLowU64x64 = (args.utilization64x64 <=\r\n            args.utilizationLowerBound64x64 &&\r\n            args.oldCLevel64x64 >= args.cLevelUpperBound64x64)\r\n            ? ONE_64x64\r\n            : int128(0);\r\n\r\n        cLevelDecayed64x64 = args\r\n            .oldCLevel64x64\r\n            .sub(args.cConvergenceULowerBound64x64.mul(convFLowU64x64))\r\n            .sub(args.cConvergenceUUpperBound64x64.mul(convFHighU64x64))\r\n            .mul(\r\n                convFLowU64x64\r\n                    .mul(ONE_64x64.sub(args.utilization64x64))\r\n                    .add(convFHighU64x64.mul(args.utilization64x64))\r\n                    .mul(args.timeIntervalsElapsed64x64)\r\n                    .neg()\r\n                    .exp()\r\n            )\r\n            .add(\r\n                args.cConvergenceULowerBound64x64.mul(convFLowU64x64).add(\r\n                    args.cConvergenceUUpperBound64x64.mul(convFHighU64x64)\r\n                )\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @notice calculate the exponential decay coefficient for a given interval\r\n     * @param oldTimestamp timestamp of previous update\r\n     * @param newTimestamp current timestamp\r\n     * @return 64x64 fixed point representation of exponential decay coefficient\r\n     */\r\n    function _decay(\r\n        uint256 oldTimestamp,\r\n        uint256 newTimestamp\r\n    ) internal pure returns (int128) {\r\n        return\r\n            ONE_64x64.sub(\r\n                (-ABDKMath64x64.divu(newTimestamp - oldTimestamp, 7 days)).exp()\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @notice calculate Choudhury’s approximation of the Black-Scholes CDF\r\n     * @param input64x64 64x64 fixed point representation of random variable\r\n     * @return 64x64 fixed point representation of the approximated CDF of x\r\n     */\r\n    function _N(int128 input64x64) internal pure returns (int128) {\r\n        // squaring via mul is cheaper than via pow\r\n        int128 inputSquared64x64 = input64x64.mul(input64x64);\r\n\r\n        int128 value64x64 = (-inputSquared64x64 >> 1).exp().div(\r\n            CDF_CONST_0.add(CDF_CONST_1.mul(input64x64.abs())).add(\r\n                CDF_CONST_2.mul(inputSquared64x64.add(THREE_64x64).sqrt())\r\n            )\r\n        );\r\n\r\n        return input64x64 > 0 ? ONE_64x64.sub(value64x64) : value64x64;\r\n    }\r\n\r\n    /**\r\n     * @notice calculate the price of an option using the Black-Scholes model\r\n     * @param varianceAnnualized64x64 64x64 fixed point representation of annualized variance\r\n     * @param strike64x64 64x64 fixed point representation of strike price\r\n     * @param spot64x64 64x64 fixed point representation of spot price\r\n     * @param timeToMaturity64x64 64x64 fixed point representation of duration of option contract (in years)\r\n     * @param isCall whether to price \"call\" or \"put\" option\r\n     * @return 64x64 fixed point representation of Black-Scholes option price\r\n     */\r\n    function _blackScholesPrice(\r\n        int128 varianceAnnualized64x64,\r\n        int128 strike64x64,\r\n        int128 spot64x64,\r\n        int128 timeToMaturity64x64,\r\n        bool isCall\r\n    ) internal pure returns (int128) {\r\n        int128 cumulativeVariance64x64 = timeToMaturity64x64.mul(\r\n            varianceAnnualized64x64\r\n        );\r\n        int128 cumulativeVarianceSqrt64x64 = cumulativeVariance64x64.sqrt();\r\n\r\n        int128 d1_64x64 = spot64x64\r\n            .div(strike64x64)\r\n            .ln()\r\n            .add(cumulativeVariance64x64 >> 1)\r\n            .div(cumulativeVarianceSqrt64x64);\r\n        int128 d2_64x64 = d1_64x64.sub(cumulativeVarianceSqrt64x64);\r\n\r\n        if (isCall) {\r\n            return\r\n                spot64x64.mul(_N(d1_64x64)).sub(strike64x64.mul(_N(d2_64x64)));\r\n        } else {\r\n            return\r\n                -spot64x64.mul(_N(-d1_64x64)).sub(\r\n                    strike64x64.mul(_N(-d2_64x64))\r\n                );\r\n        }\r\n    }\r\n}\r\n"},"@solidstate/contracts/interfaces/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC20Internal } from './IERC20Internal.sol';\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ninterface IERC20 is IERC20Internal {\n    /**\n     * @notice query the total minted token supply\n     * @return token supply\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @notice query the token balance of given account\n     * @param account address to query\n     * @return token balance\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @notice query the allowance granted from given holder to given spender\n     * @param holder approver of allowance\n     * @param spender recipient of allowance\n     * @return token allowance\n     */\n    function allowance(\n        address holder,\n        address spender\n    ) external view returns (uint256);\n\n    /**\n     * @notice grant approval to spender to spend tokens\n     * @dev prefer ERC20Extended functions to avoid transaction-ordering vulnerability (see https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729)\n     * @param spender recipient of allowance\n     * @param amount quantity of tokens approved for spending\n     * @return success status (always true; otherwise function should revert)\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @notice transfer tokens to given recipient\n     * @param recipient beneficiary of token transfer\n     * @param amount quantity of tokens to transfer\n     * @return success status (always true; otherwise function should revert)\n     */\n    function transfer(\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @notice transfer tokens to given recipient on behalf of given holder\n     * @param holder holder of tokens prior to transfer\n     * @param recipient beneficiary of token transfer\n     * @param amount quantity of tokens to transfer\n     * @return success status (always true; otherwise function should revert)\n     */\n    function transferFrom(\n        address holder,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n}\n"},"contracts/staking/PremiaStakingStorage.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\r\n// For further clarification please see https://license.premia.legal\r\n\r\npragma solidity ^0.8.0;\r\n\r\nlibrary PremiaStakingStorage {\r\n    bytes32 internal constant STORAGE_SLOT =\r\n        keccak256(\"premia.contracts.staking.PremiaStaking\");\r\n\r\n    struct Withdrawal {\r\n        uint256 amount; // Premia amount\r\n        uint256 startDate; // Will unlock at startDate + withdrawalDelay\r\n    }\r\n\r\n    struct UserInfo {\r\n        uint256 reward; // Amount of rewards accrued which havent been claimed yet\r\n        uint256 rewardDebt; // Debt to subtract from reward calculation\r\n        uint256 unstakeRewardDebt; // Debt to subtract from reward calculation from early unstake fee\r\n        uint64 stakePeriod; // Stake period selected by user\r\n        uint64 lockedUntil; // Timestamp at which the lock ends\r\n    }\r\n\r\n    struct Layout {\r\n        uint256 pendingWithdrawal;\r\n        uint256 _deprecated_withdrawalDelay;\r\n        mapping(address => Withdrawal) withdrawals;\r\n        uint256 availableRewards;\r\n        uint256 lastRewardUpdate; // Timestamp of last reward distribution update\r\n        uint256 totalPower; // Total power of all staked tokens (underlying amount with multiplier applied)\r\n        mapping(address => UserInfo) userInfo;\r\n        uint256 accRewardPerShare;\r\n        uint256 accUnstakeRewardPerShare;\r\n        uint256 availableUnstakeRewards;\r\n    }\r\n\r\n    function layout() internal pure returns (Layout storage l) {\r\n        bytes32 slot = STORAGE_SLOT;\r\n        assembly {\r\n            l.slot := slot\r\n        }\r\n    }\r\n}\r\n"},"@solidstate/contracts/access/ownable/OwnableInternal.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC173 } from '../../interfaces/IERC173.sol';\nimport { AddressUtils } from '../../utils/AddressUtils.sol';\nimport { IOwnableInternal } from './IOwnableInternal.sol';\nimport { OwnableStorage } from './OwnableStorage.sol';\n\nabstract contract OwnableInternal is IOwnableInternal {\n    using AddressUtils for address;\n\n    modifier onlyOwner() {\n        if (msg.sender != _owner()) revert Ownable__NotOwner();\n        _;\n    }\n\n    modifier onlyTransitiveOwner() {\n        if (msg.sender != _transitiveOwner())\n            revert Ownable__NotTransitiveOwner();\n        _;\n    }\n\n    function _owner() internal view virtual returns (address) {\n        return OwnableStorage.layout().owner;\n    }\n\n    function _transitiveOwner() internal view virtual returns (address owner) {\n        owner = _owner();\n\n        while (owner.isContract()) {\n            try IERC173(owner).owner() returns (address transitiveOwner) {\n                owner = transitiveOwner;\n            } catch {\n                break;\n            }\n        }\n    }\n\n    function _transferOwnership(address account) internal virtual {\n        _setOwner(account);\n    }\n\n    function _setOwner(address account) internal virtual {\n        OwnableStorage.Layout storage l = OwnableStorage.layout();\n        emit OwnershipTransferred(l.owner, account);\n        l.owner = account;\n    }\n}\n"},"@solidstate/contracts/data/EnumerableSet.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title Set implementation with enumeration functions\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\n */\nlibrary EnumerableSet {\n    error EnumerableSet__IndexOutOfBounds();\n\n    struct Set {\n        bytes32[] _values;\n        // 1-indexed to allow 0 to signify nonexistence\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    function at(\n        Bytes32Set storage set,\n        uint256 index\n    ) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    function at(\n        AddressSet storage set,\n        uint256 index\n    ) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    function at(\n        UintSet storage set,\n        uint256 index\n    ) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    function contains(\n        Bytes32Set storage set,\n        bytes32 value\n    ) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    function contains(\n        AddressSet storage set,\n        address value\n    ) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function contains(\n        UintSet storage set,\n        uint256 value\n    ) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    function indexOf(\n        Bytes32Set storage set,\n        bytes32 value\n    ) internal view returns (uint256) {\n        return _indexOf(set._inner, value);\n    }\n\n    function indexOf(\n        AddressSet storage set,\n        address value\n    ) internal view returns (uint256) {\n        return _indexOf(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function indexOf(\n        UintSet storage set,\n        uint256 value\n    ) internal view returns (uint256) {\n        return _indexOf(set._inner, bytes32(value));\n    }\n\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    function add(\n        Bytes32Set storage set,\n        bytes32 value\n    ) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    function add(\n        AddressSet storage set,\n        address value\n    ) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    function remove(\n        Bytes32Set storage set,\n        bytes32 value\n    ) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    function remove(\n        AddressSet storage set,\n        address value\n    ) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function remove(\n        UintSet storage set,\n        uint256 value\n    ) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    function toArray(\n        Bytes32Set storage set\n    ) internal view returns (bytes32[] memory) {\n        return set._inner._values;\n    }\n\n    function toArray(\n        AddressSet storage set\n    ) internal view returns (address[] memory) {\n        bytes32[] storage values = set._inner._values;\n        address[] storage array;\n\n        assembly {\n            array.slot := values.slot\n        }\n\n        return array;\n    }\n\n    function toArray(\n        UintSet storage set\n    ) internal view returns (uint256[] memory) {\n        bytes32[] storage values = set._inner._values;\n        uint256[] storage array;\n\n        assembly {\n            array.slot := values.slot\n        }\n\n        return array;\n    }\n\n    function _at(\n        Set storage set,\n        uint256 index\n    ) private view returns (bytes32) {\n        if (index >= set._values.length)\n            revert EnumerableSet__IndexOutOfBounds();\n        return set._values[index];\n    }\n\n    function _contains(\n        Set storage set,\n        bytes32 value\n    ) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    function _indexOf(\n        Set storage set,\n        bytes32 value\n    ) private view returns (uint256) {\n        unchecked {\n            return set._indexes[value] - 1;\n        }\n    }\n\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    function _add(\n        Set storage set,\n        bytes32 value\n    ) private returns (bool status) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            set._indexes[value] = set._values.length;\n            status = true;\n        }\n    }\n\n    function _remove(\n        Set storage set,\n        bytes32 value\n    ) private returns (bool status) {\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            unchecked {\n                bytes32 last = set._values[set._values.length - 1];\n\n                // move last value to now-vacant index\n\n                set._values[valueIndex - 1] = last;\n                set._indexes[last] = valueIndex;\n            }\n            // clear last index\n\n            set._values.pop();\n            delete set._indexes[value];\n\n            status = true;\n        }\n    }\n}\n"},"contracts/core/IProxyManager.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-or-later\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IProxyManager {\r\n    function getPoolList() external view returns (address[] memory);\r\n}\r\n"},"@chainlink/contracts/src/v0.8/interfaces/AggregatorInterface.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorInterface {\n  function latestAnswer() external view returns (int256);\n\n  function latestTimestamp() external view returns (uint256);\n\n  function latestRound() external view returns (uint256);\n\n  function getAnswer(uint256 roundId) external view returns (int256);\n\n  function getTimestamp(uint256 roundId) external view returns (uint256);\n\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\n\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\n}\n"},"contracts/pool/IPoolView.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-or-later\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport {IERC1155Metadata} from \"@solidstate/contracts/token/ERC1155/metadata/IERC1155Metadata.sol\";\r\n\r\nimport {PoolStorage} from \"./PoolStorage.sol\";\r\n\r\n/**\r\n * @notice Pool view function interface\r\n */\r\ninterface IPoolView is IERC1155Metadata {\r\n    /**\r\n     * @notice get fee receiver address\r\n     * @dev called by PremiaMakerKeeper\r\n     * @return fee receiver address\r\n     */\r\n    function getFeeReceiverAddress() external view returns (address);\r\n\r\n    /**\r\n     * @notice get fundamental pool attributes\r\n     * @return structured PoolSettings\r\n     */\r\n    function getPoolSettings()\r\n        external\r\n        view\r\n        returns (PoolStorage.PoolSettings memory);\r\n\r\n    /**\r\n     * @notice get the list of all token ids in circulation\r\n     * @return list of token ids\r\n     */\r\n    function getTokenIds() external view returns (uint256[] memory);\r\n\r\n    /**\r\n     * @notice get current C-Level, accounting for unrealized decay and pending deposits\r\n     * @param isCall whether query is for call or put pool\r\n     * @return cLevel64x64 64x64 fixed point representation of C-Level\r\n     */\r\n    function getCLevel64x64(bool isCall) external view returns (int128);\r\n\r\n    /**\r\n     * @notice get pool APY fee\r\n     * @return 64x64 fixed point representation of APY fee\r\n     */\r\n    function getApyFee64x64() external view returns (int128);\r\n\r\n    /**\r\n     * @notice get steepness coefficient\r\n     * @param isCall whether query is for call or put pool\r\n     * @return 64x64 fixed point representation of C steepness of Pool\r\n     */\r\n    function getSteepness64x64(bool isCall) external view returns (int128);\r\n\r\n    /**\r\n     * @notice get oracle price at timestamp\r\n     * @param timestamp timestamp to query\r\n     * @return 64x64 fixed point representation of price\r\n     */\r\n    function getPrice64x64(uint256 timestamp) external view returns (int128);\r\n\r\n    /**\r\n     * @notice get first oracle price update after timestamp. If no update has been registered yet, return current price feed spot price\r\n     * @param timestamp timestamp to query\r\n     * @return spot64x64 64x64 fixed point representation of price\r\n     */\r\n    function getPriceAfter64x64(\r\n        uint256 timestamp\r\n    ) external view returns (int128 spot64x64);\r\n\r\n    /**\r\n     * @notice get parameters for token id\r\n     * @param tokenId token id to query\r\n     * @return token type enum\r\n     * @return maturity\r\n     * @return 64x64 fixed point representation of strike price\r\n     */\r\n    function getParametersForTokenId(\r\n        uint256 tokenId\r\n    ) external pure returns (PoolStorage.TokenType, uint64, int128);\r\n\r\n    /**\r\n     * @notice get minimum purchase and interval amounts\r\n     * @return minCallTokenAmount minimum call pool amount\r\n     * @return minPutTokenAmount minimum put pool amount\r\n     */\r\n    function getMinimumAmounts()\r\n        external\r\n        view\r\n        returns (uint256 minCallTokenAmount, uint256 minPutTokenAmount);\r\n\r\n    /**\r\n     * @notice get TVL (total value locked) for given address\r\n     * @param account address whose TVL to query\r\n     * @return underlyingTVL user total value locked in call pool (in underlying token amount)\r\n     * @return baseTVL user total value locked in put pool (in base token amount)\r\n     */\r\n    function getUserTVL(\r\n        address account\r\n    ) external view returns (uint256 underlyingTVL, uint256 baseTVL);\r\n\r\n    /**\r\n     * @notice get TVL (total value locked) of entire Pool\r\n     * @return underlyingTVL total value locked in call pool (in underlying token amount)\r\n     * @return baseTVL total value locked in put pool (in base token amount)\r\n     */\r\n    function getTotalTVL()\r\n        external\r\n        view\r\n        returns (uint256 underlyingTVL, uint256 baseTVL);\r\n\r\n    /**\r\n     * @notice get position in the liquidity queue of the Pool\r\n     * @param account account address whose liquidity position to query\r\n     * @param isCallPool whether query is for call or put pool\r\n     * @return liquidityBeforePosition total available liquidity before account's liquidity queue\r\n     * @return positionSize size of the account's liquidity queue position\r\n     */\r\n    function getLiquidityQueuePosition(\r\n        address account,\r\n        bool isCallPool\r\n    )\r\n        external\r\n        view\r\n        returns (uint256 liquidityBeforePosition, uint256 positionSize);\r\n\r\n    /**\r\n     * @notice get the amount of APY fees reserved for given user and token id\r\n     * @param account account whose reserved fees to query\r\n     * @param shortTokenId short token id whose reserved fees to query\r\n     * @return amount quantity of fees reserved\r\n     */\r\n    function getFeesReserved(\r\n        address account,\r\n        uint256 shortTokenId\r\n    ) external view returns (uint256 amount);\r\n\r\n    /**\r\n     * @notice get the address of PremiaMining contract\r\n     * @return address of PremiaMining contract\r\n     */\r\n    function getPremiaMining() external view returns (address);\r\n\r\n    /**\r\n     * @notice get the gradual divestment timestamps of a user\r\n     * @param account address whose divestment timestamps to query\r\n     * @return callDivestmentTimestamp gradual divestment timestamp of the user for the call pool\r\n     * @return putDivestmentTimestamp gradual divestment timestamp of the user for the put pool\r\n     */\r\n    function getDivestmentTimestamps(\r\n        address account\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            uint256 callDivestmentTimestamp,\r\n            uint256 putDivestmentTimestamp\r\n        );\r\n\r\n    /**\r\n     * @notice get the spot price offset used to account for price feed lag\r\n     * @return spotOffset64x64 64x64 fixed point representation of spot price offset\r\n     */\r\n    function getSpotOffset64x64()\r\n        external\r\n        view\r\n        returns (int128 spotOffset64x64);\r\n\r\n    /**\r\n     * @notice get the exchange helper address\r\n     * @return exchangeHelper exchange helper address\r\n     */\r\n    function getExchangeHelper() external view returns (address exchangeHelper);\r\n}\r\n"},"@solidstate/contracts/interfaces/IERC20Internal.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title Partial ERC20 interface needed by internal functions\n */\ninterface IERC20Internal {\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n"},"@solidstate/contracts/token/ERC1155/metadata/IERC1155MetadataInternal.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title Partial ERC1155Metadata interface needed by internal functions\n */\ninterface IERC1155MetadataInternal {\n    event URI(string value, uint256 indexed tokenId);\n}\n"},"contracts/mining/PremiaMiningStorage.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\r\n// For further clarification please see https://license.premia.legal\r\n\r\npragma solidity ^0.8.0;\r\n\r\nlibrary PremiaMiningStorage {\r\n    bytes32 internal constant STORAGE_SLOT =\r\n        keccak256(\"premia.contracts.storage.PremiaMining\");\r\n\r\n    // Info of each pool.\r\n    struct PoolInfo {\r\n        uint256 allocPoint; // How many allocation points assigned to this pool. PREMIA to distribute per block.\r\n        uint256 lastRewardTimestamp; // Last timestamp that PREMIA distribution occurs\r\n        uint256 accPremiaPerShare; // Accumulated PREMIA per share, times 1e12. See below.\r\n    }\r\n\r\n    // Info of each user.\r\n    struct UserInfo {\r\n        uint256 reward; // Total allocated unclaimed reward\r\n        uint256 rewardDebt; // Reward debt. See explanation below.\r\n        //\r\n        // We do some fancy math here. Basically, any point in time, the amount of PREMIA\r\n        // entitled to a user but is pending to be distributed is:\r\n        //\r\n        //   pending reward = (user.amount * pool.accPremiaPerShare) - user.rewardDebt\r\n        //\r\n        // Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens:\r\n        //   1. The pool's `accPremiaPerShare` (and `lastRewardBlock`) gets updated.\r\n        //   2. User receives the pending reward sent to his/her address.\r\n        //   3. User's `amount` gets updated.\r\n        //   4. User's `rewardDebt` gets updated.\r\n    }\r\n\r\n    struct Layout {\r\n        // Total PREMIA left to distribute\r\n        uint256 premiaAvailable;\r\n        // Amount of premia distributed per year\r\n        uint256 premiaPerYear;\r\n        // pool -> isCallPool -> PoolInfo\r\n        mapping(address => mapping(bool => PoolInfo)) poolInfo;\r\n        // pool -> isCallPool -> user -> UserInfo\r\n        mapping(address => mapping(bool => mapping(address => UserInfo))) userInfo;\r\n        // Total allocation points. Must be the sum of all allocation points in all pools.\r\n        uint256 totalAllocPoint;\r\n        // pool -> whether pool is valid\r\n        mapping(address => bool) pools;\r\n    }\r\n\r\n    function layout() internal pure returns (Layout storage l) {\r\n        bytes32 slot = STORAGE_SLOT;\r\n        assembly {\r\n            l.slot := slot\r\n        }\r\n    }\r\n}\r\n"},"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"},"@solidstate/contracts/interfaces/IERC173Internal.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title Partial ERC173 interface needed by internal functions\n */\ninterface IERC173Internal {\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n}\n"},"@solidstate/contracts/token/ERC20/permit/IERC2612.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC2612Internal } from './IERC2612Internal.sol';\n\n/**\n * @title ERC2612 interface\n * @dev see https://eips.ethereum.org/EIPS/eip-2612.\n */\ninterface IERC2612 is IERC2612Internal {\n    /**\n     * @notice return the EIP-712 domain separator unique to contract and chain\n     * @return domainSeparator domain separator\n     */\n    function DOMAIN_SEPARATOR() external view returns (bytes32 domainSeparator);\n\n    /**\n     * @notice get the current ERC2612 nonce for the given address\n     * @return current nonce\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @notice approve spender to transfer tokens held by owner via signature\n     * @dev this function may be vulnerable to approval replay attacks\n     * @param owner holder of tokens and signer of permit\n     * @param spender beneficiary of approval\n     * @param amount quantity of tokens to approve\n     * @param v secp256k1 'v' value\n     * @param r secp256k1 'r' value\n     * @param s secp256k1 's' value\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"},"@solidstate/contracts/utils/UintUtils.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title utility functions for uint256 operations\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts/ (MIT license)\n */\nlibrary UintUtils {\n    error UintUtils__InsufficientHexLength();\n\n    bytes16 private constant HEX_SYMBOLS = '0123456789abcdef';\n\n    function add(uint256 a, int256 b) internal pure returns (uint256) {\n        return b < 0 ? sub(a, -b) : a + uint256(b);\n    }\n\n    function sub(uint256 a, int256 b) internal pure returns (uint256) {\n        return b < 0 ? add(a, -b) : a - uint256(b);\n    }\n\n    function toString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return '0';\n        }\n\n        uint256 temp = value;\n        uint256 digits;\n\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n\n        bytes memory buffer = new bytes(digits);\n\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n\n        return string(buffer);\n    }\n\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return '0x00';\n        }\n\n        uint256 length = 0;\n\n        for (uint256 temp = value; temp != 0; temp >>= 8) {\n            unchecked {\n                length++;\n            }\n        }\n\n        return toHexString(value, length);\n    }\n\n    function toHexString(\n        uint256 value,\n        uint256 length\n    ) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = '0';\n        buffer[1] = 'x';\n\n        unchecked {\n            for (uint256 i = 2 * length + 1; i > 1; --i) {\n                buffer[i] = HEX_SYMBOLS[value & 0xf];\n                value >>= 4;\n            }\n        }\n\n        if (value != 0) revert UintUtils__InsufficientHexLength();\n\n        return string(buffer);\n    }\n}\n"},"contracts/pool/PoolStorage.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\r\n// For further clarification please see https://license.premia.legal\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport {AggregatorInterface} from \"@chainlink/contracts/src/v0.8/interfaces/AggregatorInterface.sol\";\r\nimport {AggregatorV3Interface} from \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\r\nimport {ABDKMath64x64Token} from \"@solidstate/abdk-math-extensions/contracts/ABDKMath64x64Token.sol\";\r\nimport {EnumerableSet, ERC1155EnumerableStorage} from \"@solidstate/contracts/token/ERC1155/enumerable/ERC1155EnumerableStorage.sol\";\r\nimport {ABDKMath64x64} from \"abdk-libraries-solidity/ABDKMath64x64.sol\";\r\n\r\nimport {OptionMath} from \"../libraries/OptionMath.sol\";\r\n\r\nlibrary PoolStorage {\r\n    using ABDKMath64x64 for int128;\r\n    using PoolStorage for PoolStorage.Layout;\r\n\r\n    enum TokenType {\r\n        UNDERLYING_FREE_LIQ,\r\n        BASE_FREE_LIQ,\r\n        UNDERLYING_RESERVED_LIQ,\r\n        BASE_RESERVED_LIQ,\r\n        LONG_CALL,\r\n        SHORT_CALL,\r\n        LONG_PUT,\r\n        SHORT_PUT\r\n    }\r\n\r\n    struct PoolSettings {\r\n        address underlying;\r\n        address base;\r\n        address underlyingOracle;\r\n        address baseOracle;\r\n    }\r\n\r\n    struct QuoteArgsInternal {\r\n        address feePayer; // address of the fee payer\r\n        uint64 maturity; // timestamp of option maturity\r\n        int128 strike64x64; // 64x64 fixed point representation of strike price\r\n        int128 spot64x64; // 64x64 fixed point representation of spot price\r\n        uint256 contractSize; // size of option contract\r\n        bool isCall; // true for call, false for put\r\n    }\r\n\r\n    struct QuoteResultInternal {\r\n        int128 baseCost64x64; // 64x64 fixed point representation of option cost denominated in underlying currency (without fee)\r\n        int128 feeCost64x64; // 64x64 fixed point representation of option fee cost denominated in underlying currency for call, or base currency for put\r\n        int128 cLevel64x64; // 64x64 fixed point representation of C-Level of Pool after purchase\r\n        int128 slippageCoefficient64x64; // 64x64 fixed point representation of slippage coefficient for given order size\r\n    }\r\n\r\n    struct BatchData {\r\n        uint256 eta;\r\n        uint256 totalPendingDeposits;\r\n    }\r\n\r\n    bytes32 internal constant STORAGE_SLOT =\r\n        keccak256(\"premia.contracts.storage.Pool\");\r\n\r\n    uint256 private constant C_DECAY_BUFFER = 12 hours;\r\n    uint256 private constant C_DECAY_INTERVAL = 4 hours;\r\n\r\n    int128 internal constant ONE_64x64 = 0x10000000000000000;\r\n\r\n    struct Layout {\r\n        // ERC20 token addresses\r\n        address base;\r\n        address underlying;\r\n        // AggregatorV3Interface oracle addresses\r\n        address baseOracle;\r\n        address underlyingOracle;\r\n        // token metadata\r\n        uint8 underlyingDecimals;\r\n        uint8 baseDecimals;\r\n        // minimum amounts\r\n        uint256 baseMinimum;\r\n        uint256 underlyingMinimum;\r\n        // deposit caps\r\n        uint256 _deprecated_basePoolCap;\r\n        uint256 _deprecated_underlyingPoolCap;\r\n        // market state\r\n        int128 _deprecated_steepness64x64;\r\n        int128 cLevelBase64x64;\r\n        int128 cLevelUnderlying64x64;\r\n        uint256 cLevelBaseUpdatedAt;\r\n        uint256 cLevelUnderlyingUpdatedAt;\r\n        uint256 updatedAt;\r\n        // User -> isCall -> depositedAt\r\n        mapping(address => mapping(bool => uint256)) depositedAt;\r\n        mapping(address => mapping(bool => uint256)) divestmentTimestamps;\r\n        // doubly linked list of free liquidity intervals\r\n        // isCall -> User -> User\r\n        mapping(bool => mapping(address => address)) liquidityQueueAscending;\r\n        mapping(bool => mapping(address => address)) liquidityQueueDescending;\r\n        // minimum resolution price bucket => price\r\n        mapping(uint256 => int128) bucketPrices64x64;\r\n        // sequence id (minimum resolution price bucket / 256) => price update sequence\r\n        mapping(uint256 => uint256) priceUpdateSequences;\r\n        // isCall -> batch data\r\n        mapping(bool => BatchData) nextDeposits;\r\n        // user -> batch timestamp -> isCall -> pending amount\r\n        mapping(address => mapping(uint256 => mapping(bool => uint256))) pendingDeposits;\r\n        EnumerableSet.UintSet tokenIds;\r\n        // user -> isCallPool -> total value locked of user (Used for liquidity mining)\r\n        mapping(address => mapping(bool => uint256)) userTVL;\r\n        // isCallPool -> total value locked\r\n        mapping(bool => uint256) totalTVL;\r\n        // steepness values\r\n        int128 steepnessBase64x64;\r\n        int128 steepnessUnderlying64x64;\r\n        // User -> isCallPool -> isBuybackEnabled\r\n        mapping(address => mapping(bool => bool)) isBuybackEnabled;\r\n        // LongTokenId -> minC\r\n        mapping(uint256 => int128) minCLevel64x64;\r\n        // APY fee tracking\r\n        // underwriter -> shortTokenId -> amount\r\n        mapping(address => mapping(uint256 => uint256)) feesReserved;\r\n        // shortTokenId -> 64x64 fixed point representation of apy fee\r\n        mapping(uint256 => int128) feeReserveRates;\r\n        // APY fee paid by underwriters\r\n        // Also used along with multiplier to calculate minimum option price as APY\r\n        int128 feeApy64x64;\r\n        // adjustment applied to spot price for puchase calculations\r\n        int128 spotOffset64x64;\r\n    }\r\n\r\n    function layout() internal pure returns (Layout storage l) {\r\n        bytes32 slot = STORAGE_SLOT;\r\n        assembly {\r\n            l.slot := slot\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice calculate ERC1155 token id for given option parameters\r\n     * @param tokenType TokenType enum\r\n     * @param maturity timestamp of option maturity\r\n     * @param strike64x64 64x64 fixed point representation of strike price\r\n     * @return tokenId token id\r\n     */\r\n    function formatTokenId(\r\n        TokenType tokenType,\r\n        uint64 maturity,\r\n        int128 strike64x64\r\n    ) internal pure returns (uint256 tokenId) {\r\n        tokenId =\r\n            (uint256(tokenType) << 248) +\r\n            (uint256(maturity) << 128) +\r\n            uint256(int256(strike64x64));\r\n    }\r\n\r\n    /**\r\n     * @notice derive option maturity and strike price from ERC1155 token id\r\n     * @param tokenId token id\r\n     * @return tokenType TokenType enum\r\n     * @return maturity timestamp of option maturity\r\n     * @return strike64x64 option strike price\r\n     */\r\n    function parseTokenId(\r\n        uint256 tokenId\r\n    )\r\n        internal\r\n        pure\r\n        returns (TokenType tokenType, uint64 maturity, int128 strike64x64)\r\n    {\r\n        assembly {\r\n            tokenType := shr(248, tokenId)\r\n            maturity := shr(128, tokenId)\r\n            strike64x64 := tokenId\r\n        }\r\n    }\r\n\r\n    function getTokenType(\r\n        bool isCall,\r\n        bool isLong\r\n    ) internal pure returns (TokenType tokenType) {\r\n        if (isCall) {\r\n            tokenType = isLong ? TokenType.LONG_CALL : TokenType.SHORT_CALL;\r\n        } else {\r\n            tokenType = isLong ? TokenType.LONG_PUT : TokenType.SHORT_PUT;\r\n        }\r\n    }\r\n\r\n    function getPoolToken(\r\n        Layout storage l,\r\n        bool isCall\r\n    ) internal view returns (address token) {\r\n        token = isCall ? l.underlying : l.base;\r\n    }\r\n\r\n    function getTokenDecimals(\r\n        Layout storage l,\r\n        bool isCall\r\n    ) internal view returns (uint8 decimals) {\r\n        decimals = isCall ? l.underlyingDecimals : l.baseDecimals;\r\n    }\r\n\r\n    function getMinimumAmount(\r\n        Layout storage l,\r\n        bool isCall\r\n    ) internal view returns (uint256 minimumAmount) {\r\n        minimumAmount = isCall ? l.underlyingMinimum : l.baseMinimum;\r\n    }\r\n\r\n    /**\r\n     * @notice get the total supply of free liquidity tokens, minus pending deposits\r\n     * @param l storage layout struct\r\n     * @param isCall whether query is for call or put pool\r\n     * @return 64x64 fixed point representation of total free liquidity\r\n     */\r\n    function totalFreeLiquiditySupply64x64(\r\n        Layout storage l,\r\n        bool isCall\r\n    ) internal view returns (int128) {\r\n        uint256 tokenId = formatTokenId(\r\n            isCall ? TokenType.UNDERLYING_FREE_LIQ : TokenType.BASE_FREE_LIQ,\r\n            0,\r\n            0\r\n        );\r\n\r\n        return\r\n            ABDKMath64x64Token.fromDecimals(\r\n                ERC1155EnumerableStorage.layout().totalSupply[tokenId] -\r\n                    l.totalPendingDeposits(isCall),\r\n                l.getTokenDecimals(isCall)\r\n            );\r\n    }\r\n\r\n    function getReinvestmentStatus(\r\n        Layout storage l,\r\n        address account,\r\n        bool isCallPool\r\n    ) internal view returns (bool) {\r\n        uint256 timestamp = l.divestmentTimestamps[account][isCallPool];\r\n        return timestamp == 0 || timestamp > block.timestamp;\r\n    }\r\n\r\n    function getFeeApy64x64(\r\n        Layout storage l\r\n    ) internal view returns (int128 feeApy64x64) {\r\n        feeApy64x64 = l.feeApy64x64;\r\n\r\n        if (feeApy64x64 == 0) {\r\n            // if APY fee is not set, set to 0.025\r\n            feeApy64x64 = 0x666666666666666;\r\n        }\r\n    }\r\n\r\n    function getMinApy64x64(\r\n        Layout storage l\r\n    ) internal view returns (int128 feeApy64x64) {\r\n        feeApy64x64 = l.getFeeApy64x64() << 3;\r\n    }\r\n\r\n    function addUnderwriter(\r\n        Layout storage l,\r\n        address account,\r\n        bool isCallPool\r\n    ) internal {\r\n        require(account != address(0));\r\n\r\n        mapping(address => address) storage asc = l.liquidityQueueAscending[\r\n            isCallPool\r\n        ];\r\n        mapping(address => address) storage desc = l.liquidityQueueDescending[\r\n            isCallPool\r\n        ];\r\n\r\n        if (_isInQueue(account, asc, desc)) return;\r\n\r\n        address last = desc[address(0)];\r\n\r\n        asc[last] = account;\r\n        desc[account] = last;\r\n        desc[address(0)] = account;\r\n    }\r\n\r\n    function removeUnderwriter(\r\n        Layout storage l,\r\n        address account,\r\n        bool isCallPool\r\n    ) internal {\r\n        require(account != address(0));\r\n\r\n        mapping(address => address) storage asc = l.liquidityQueueAscending[\r\n            isCallPool\r\n        ];\r\n        mapping(address => address) storage desc = l.liquidityQueueDescending[\r\n            isCallPool\r\n        ];\r\n\r\n        if (!_isInQueue(account, asc, desc)) return;\r\n\r\n        address prev = desc[account];\r\n        address next = asc[account];\r\n        asc[prev] = next;\r\n        desc[next] = prev;\r\n        delete asc[account];\r\n        delete desc[account];\r\n    }\r\n\r\n    function isInQueue(\r\n        Layout storage l,\r\n        address account,\r\n        bool isCallPool\r\n    ) internal view returns (bool) {\r\n        mapping(address => address) storage asc = l.liquidityQueueAscending[\r\n            isCallPool\r\n        ];\r\n        mapping(address => address) storage desc = l.liquidityQueueDescending[\r\n            isCallPool\r\n        ];\r\n\r\n        return _isInQueue(account, asc, desc);\r\n    }\r\n\r\n    function _isInQueue(\r\n        address account,\r\n        mapping(address => address) storage asc,\r\n        mapping(address => address) storage desc\r\n    ) private view returns (bool) {\r\n        return asc[account] != address(0) || desc[address(0)] == account;\r\n    }\r\n\r\n    /**\r\n     * @notice get current C-Level, without accounting for pending adjustments\r\n     * @param l storage layout struct\r\n     * @param isCall whether query is for call or put pool\r\n     * @return cLevel64x64 64x64 fixed point representation of C-Level\r\n     */\r\n    function getRawCLevel64x64(\r\n        Layout storage l,\r\n        bool isCall\r\n    ) internal view returns (int128 cLevel64x64) {\r\n        cLevel64x64 = isCall ? l.cLevelUnderlying64x64 : l.cLevelBase64x64;\r\n    }\r\n\r\n    /**\r\n     * @notice get current C-Level, accounting for unrealized decay\r\n     * @param l storage layout struct\r\n     * @param isCall whether query is for call or put pool\r\n     * @param utilization64x64 utilization of the pool\r\n     * @return cLevel64x64 64x64 fixed point representation of C-Level\r\n     */\r\n    function getDecayAdjustedCLevel64x64(\r\n        Layout storage l,\r\n        bool isCall,\r\n        int128 utilization64x64\r\n    ) internal view returns (int128 cLevel64x64) {\r\n        // get raw C-Level from storage\r\n        cLevel64x64 = l.getRawCLevel64x64(isCall);\r\n\r\n        // account for C-Level decay\r\n        cLevel64x64 = l.applyCLevelDecayAdjustment(\r\n            cLevel64x64,\r\n            isCall,\r\n            utilization64x64\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice get updated C-Level and pool liquidity level, accounting for decay and pending deposits\r\n     * @param l storage layout struct\r\n     * @param isCall whether to update C-Level for call or put pool\r\n     * @return cLevel64x64 64x64 fixed point representation of C-Level\r\n     * @return liquidity64x64 64x64 fixed point representation of new liquidity amount\r\n     */\r\n    function getRealPoolState(\r\n        Layout storage l,\r\n        bool isCall\r\n    ) internal view returns (int128 cLevel64x64, int128 liquidity64x64) {\r\n        PoolStorage.BatchData storage batchData = l.nextDeposits[isCall];\r\n\r\n        int128 oldCLevel64x64 = l.getDecayAdjustedCLevel64x64(\r\n            isCall,\r\n            l.getUtilization64x64(isCall)\r\n        );\r\n        int128 oldLiquidity64x64 = l.totalFreeLiquiditySupply64x64(isCall);\r\n\r\n        if (\r\n            batchData.totalPendingDeposits > 0 &&\r\n            batchData.eta != 0 &&\r\n            block.timestamp >= batchData.eta\r\n        ) {\r\n            liquidity64x64 = ABDKMath64x64Token\r\n                .fromDecimals(\r\n                    batchData.totalPendingDeposits,\r\n                    l.getTokenDecimals(isCall)\r\n                )\r\n                .add(oldLiquidity64x64);\r\n\r\n            cLevel64x64 = l.applyCLevelLiquidityChangeAdjustment(\r\n                oldCLevel64x64,\r\n                oldLiquidity64x64,\r\n                liquidity64x64,\r\n                isCall\r\n            );\r\n        } else {\r\n            cLevel64x64 = oldCLevel64x64;\r\n            liquidity64x64 = oldLiquidity64x64;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice calculate updated C-Level, accounting for unrealized decay\r\n     * @param l storage layout struct\r\n     * @param oldCLevel64x64 64x64 fixed point representation pool C-Level before accounting for decay\r\n     * @param isCall whether query is for call or put pool\r\n     * @return cLevel64x64 64x64 fixed point representation of C-Level of Pool after accounting for decay\r\n     */\r\n    function applyCLevelDecayAdjustment(\r\n        Layout storage l,\r\n        int128 oldCLevel64x64,\r\n        bool isCall,\r\n        int128 utilization64x64\r\n    ) internal view returns (int128 cLevel64x64) {\r\n        uint256 timeElapsed = block.timestamp -\r\n            (isCall ? l.cLevelUnderlyingUpdatedAt : l.cLevelBaseUpdatedAt);\r\n\r\n        // do not apply C decay if less than 24 hours have elapsed\r\n\r\n        if (timeElapsed > C_DECAY_BUFFER) {\r\n            timeElapsed -= C_DECAY_BUFFER;\r\n        } else {\r\n            return oldCLevel64x64;\r\n        }\r\n\r\n        int128 timeIntervalsElapsed64x64 = ABDKMath64x64.divu(\r\n            timeElapsed,\r\n            C_DECAY_INTERVAL\r\n        );\r\n\r\n        return\r\n            OptionMath.calculateCLevelDecay(\r\n                OptionMath.CalculateCLevelDecayArgs(\r\n                    timeIntervalsElapsed64x64,\r\n                    oldCLevel64x64,\r\n                    utilization64x64,\r\n                    0xb333333333333333, // 0.7\r\n                    0xe666666666666666, // 0.9\r\n                    0x10000000000000000, // 1.0\r\n                    0x10000000000000000, // 1.0\r\n                    0xe666666666666666, // 0.9\r\n                    0x56fc2a2c515da32ea // 2e\r\n                )\r\n            );\r\n    }\r\n\r\n    function getUtilization64x64(\r\n        Layout storage l,\r\n        bool isCall\r\n    ) internal view returns (int128 utilization64x64) {\r\n        uint256 tokenId = formatTokenId(\r\n            isCall ? TokenType.UNDERLYING_FREE_LIQ : TokenType.BASE_FREE_LIQ,\r\n            0,\r\n            0\r\n        );\r\n\r\n        uint256 tvl = l.totalTVL[isCall];\r\n        uint256 pendingDeposits = l.totalPendingDeposits(isCall);\r\n\r\n        if (tvl <= pendingDeposits) return 0;\r\n\r\n        uint256 freeLiq = ERC1155EnumerableStorage.layout().totalSupply[\r\n            tokenId\r\n        ];\r\n\r\n        if (tvl < freeLiq) {\r\n            // workaround for TVL underflow issue\r\n            freeLiq = tvl;\r\n        }\r\n\r\n        utilization64x64 = ABDKMath64x64.divu(\r\n            tvl - freeLiq,\r\n            tvl - pendingDeposits\r\n        );\r\n\r\n        // Safeguard check\r\n        require(utilization64x64 <= ONE_64x64, \"utilization > 1\");\r\n    }\r\n\r\n    /**\r\n     * @notice calculate updated C-Level, accounting for change in liquidity\r\n     * @param l storage layout struct\r\n     * @param oldCLevel64x64 64x64 fixed point representation pool C-Level before accounting for liquidity change\r\n     * @param oldLiquidity64x64 64x64 fixed point representation of previous liquidity\r\n     * @param newLiquidity64x64 64x64 fixed point representation of current liquidity\r\n     * @param isCallPool whether to update C-Level for call or put pool\r\n     * @return cLevel64x64 64x64 fixed point representation of C-Level\r\n     */\r\n    function applyCLevelLiquidityChangeAdjustment(\r\n        Layout storage l,\r\n        int128 oldCLevel64x64,\r\n        int128 oldLiquidity64x64,\r\n        int128 newLiquidity64x64,\r\n        bool isCallPool\r\n    ) internal view returns (int128 cLevel64x64) {\r\n        int128 steepness64x64 = isCallPool\r\n            ? l.steepnessUnderlying64x64\r\n            : l.steepnessBase64x64;\r\n\r\n        // fallback to deprecated storage value if side-specific value is not set\r\n        if (steepness64x64 == 0) steepness64x64 = l._deprecated_steepness64x64;\r\n\r\n        cLevel64x64 = OptionMath.calculateCLevel(\r\n            oldCLevel64x64,\r\n            oldLiquidity64x64,\r\n            newLiquidity64x64,\r\n            steepness64x64\r\n        );\r\n\r\n        if (cLevel64x64 < 0xb333333333333333) {\r\n            cLevel64x64 = int128(0xb333333333333333); // 64x64 fixed point representation of 0.7\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice set C-Level to arbitrary pre-calculated value\r\n     * @param cLevel64x64 new C-Level of pool\r\n     * @param isCallPool whether to update C-Level for call or put pool\r\n     */\r\n    function setCLevel(\r\n        Layout storage l,\r\n        int128 cLevel64x64,\r\n        bool isCallPool\r\n    ) internal {\r\n        if (isCallPool) {\r\n            l.cLevelUnderlying64x64 = cLevel64x64;\r\n            l.cLevelUnderlyingUpdatedAt = block.timestamp;\r\n        } else {\r\n            l.cLevelBase64x64 = cLevel64x64;\r\n            l.cLevelBaseUpdatedAt = block.timestamp;\r\n        }\r\n    }\r\n\r\n    function setOracles(\r\n        Layout storage l,\r\n        address baseOracle,\r\n        address underlyingOracle\r\n    ) internal {\r\n        require(\r\n            AggregatorV3Interface(baseOracle).decimals() ==\r\n                AggregatorV3Interface(underlyingOracle).decimals(),\r\n            \"Pool: oracle decimals must match\"\r\n        );\r\n\r\n        l.baseOracle = baseOracle;\r\n        l.underlyingOracle = underlyingOracle;\r\n    }\r\n\r\n    function fetchPriceUpdate(\r\n        Layout storage l\r\n    ) internal view returns (int128 price64x64) {\r\n        int256 priceUnderlying = AggregatorInterface(l.underlyingOracle)\r\n            .latestAnswer();\r\n        int256 priceBase = AggregatorInterface(l.baseOracle).latestAnswer();\r\n\r\n        return ABDKMath64x64.divi(priceUnderlying, priceBase);\r\n    }\r\n\r\n    /**\r\n     * @notice set price update for hourly bucket corresponding to given timestamp\r\n     * @param l storage layout struct\r\n     * @param timestamp timestamp to update\r\n     * @param price64x64 64x64 fixed point representation of price\r\n     */\r\n    function setPriceUpdate(\r\n        Layout storage l,\r\n        uint256 timestamp,\r\n        int128 price64x64\r\n    ) internal {\r\n        uint256 bucket = timestamp / (1 hours);\r\n        l.bucketPrices64x64[bucket] = price64x64;\r\n        l.priceUpdateSequences[bucket >> 8] += 1 << (255 - (bucket & 255));\r\n    }\r\n\r\n    /**\r\n     * @notice get price update for hourly bucket corresponding to given timestamp\r\n     * @param l storage layout struct\r\n     * @param timestamp timestamp to query\r\n     * @return 64x64 fixed point representation of price\r\n     */\r\n    function getPriceUpdate(\r\n        Layout storage l,\r\n        uint256 timestamp\r\n    ) internal view returns (int128) {\r\n        return l.bucketPrices64x64[timestamp / (1 hours)];\r\n    }\r\n\r\n    /**\r\n     * @notice get first price update available following given timestamp\r\n     * @param l storage layout struct\r\n     * @param timestamp timestamp to query\r\n     * @return 64x64 fixed point representation of price\r\n     */\r\n    function getPriceUpdateAfter(\r\n        Layout storage l,\r\n        uint256 timestamp\r\n    ) internal view returns (int128) {\r\n        // price updates are grouped into hourly buckets\r\n        uint256 bucket = timestamp / (1 hours);\r\n        // divide by 256 to get the index of the relevant price update sequence\r\n        uint256 sequenceId = bucket >> 8;\r\n\r\n        // get position within sequence relevant to current price update\r\n\r\n        uint256 offset = bucket & 255;\r\n        // shift to skip buckets from earlier in sequence\r\n        uint256 sequence = (l.priceUpdateSequences[sequenceId] << offset) >>\r\n            offset;\r\n\r\n        // iterate through future sequences until a price update is found\r\n        // sequence corresponding to current timestamp used as upper bound\r\n\r\n        uint256 currentPriceUpdateSequenceId = block.timestamp / (256 hours);\r\n\r\n        while (sequence == 0 && sequenceId <= currentPriceUpdateSequenceId) {\r\n            sequence = l.priceUpdateSequences[++sequenceId];\r\n        }\r\n\r\n        // if no price update is found (sequence == 0) function will return 0\r\n        // this should never occur, as each relevant external function triggers a price update\r\n\r\n        // the most significant bit of the sequence corresponds to the offset of the relevant bucket\r\n\r\n        uint256 msb;\r\n\r\n        for (uint256 i = 128; i > 0; i >>= 1) {\r\n            if (sequence >> i > 0) {\r\n                msb += i;\r\n                sequence >>= i;\r\n            }\r\n        }\r\n\r\n        return l.bucketPrices64x64[((sequenceId + 1) << 8) - msb - 1];\r\n    }\r\n\r\n    function totalPendingDeposits(\r\n        Layout storage l,\r\n        bool isCallPool\r\n    ) internal view returns (uint256) {\r\n        return l.nextDeposits[isCallPool].totalPendingDeposits;\r\n    }\r\n\r\n    function pendingDepositsOf(\r\n        Layout storage l,\r\n        address account,\r\n        bool isCallPool\r\n    ) internal view returns (uint256) {\r\n        return\r\n            l.pendingDeposits[account][l.nextDeposits[isCallPool].eta][\r\n                isCallPool\r\n            ];\r\n    }\r\n\r\n    function contractSizeToBaseTokenAmount(\r\n        Layout storage l,\r\n        uint256 contractSize,\r\n        int128 price64x64,\r\n        bool isCallPool\r\n    ) internal view returns (uint256 tokenAmount) {\r\n        if (isCallPool) {\r\n            tokenAmount = contractSize;\r\n        } else {\r\n            uint256 value = price64x64.mulu(contractSize);\r\n\r\n            int128 value64x64 = ABDKMath64x64Token.fromDecimals(\r\n                value,\r\n                l.underlyingDecimals\r\n            );\r\n\r\n            tokenAmount = ABDKMath64x64Token.toDecimals(\r\n                value64x64,\r\n                l.baseDecimals\r\n            );\r\n        }\r\n    }\r\n\r\n    function setBuybackEnabled(\r\n        Layout storage l,\r\n        bool state,\r\n        bool isCallPool\r\n    ) internal {\r\n        l.isBuybackEnabled[msg.sender][isCallPool] = state;\r\n    }\r\n}\r\n"},"@solidstate/contracts/utils/SafeERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC20 } from '../interfaces/IERC20.sol';\nimport { AddressUtils } from './AddressUtils.sol';\n\n/**\n * @title Safe ERC20 interaction library\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts/ (MIT license)\n */\nlibrary SafeERC20 {\n    using AddressUtils for address;\n\n    error SafeERC20__ApproveFromNonZeroToNonZero();\n    error SafeERC20__DecreaseAllowanceBelowZero();\n    error SafeERC20__OperationFailed();\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transfer.selector, to, value)\n        );\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\n        );\n    }\n\n    /**\n     * @dev safeApprove (like approve) should only be called when setting an initial allowance or when resetting it to zero; otherwise prefer safeIncreaseAllowance and safeDecreaseAllowance\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        if ((value != 0) && (token.allowance(address(this), spender) != 0))\n            revert SafeERC20__ApproveFromNonZeroToNonZero();\n\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.approve.selector, spender, value)\n        );\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(\n                token.approve.selector,\n                spender,\n                newAllowance\n            )\n        );\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            if (oldAllowance < value)\n                revert SafeERC20__DecreaseAllowanceBelowZero();\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(\n                token,\n                abi.encodeWithSelector(\n                    token.approve.selector,\n                    spender,\n                    newAllowance\n                )\n            );\n        }\n    }\n\n    /**\n     * @notice send transaction data and check validity of return value, if present\n     * @param token ERC20 token interface\n     * @param data transaction data\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        bytes memory returndata = address(token).functionCall(\n            data,\n            'SafeERC20: low-level call failed'\n        );\n\n        if (returndata.length > 0) {\n            if (!abi.decode(returndata, (bool)))\n                revert SafeERC20__OperationFailed();\n        }\n    }\n}\n"}},"settings":{"optimizer":{"enabled":true,"runs":200},"outputSelection":{"*":{"*":["evm.bytecode","evm.deployedBytecode","devdoc","userdoc","metadata","abi"]}},"libraries":{}}},"ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_proxyManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_premia\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_vxPremia\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AddressUtils__NotContract\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Ownable__NotOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Ownable__NotTransitiveOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SafeERC20__OperationFailed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"isCallPool\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"isCallPool\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"votes\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"poolUtilizationRateBPS\",\"type\":\"uint256\"}],\"name\":\"UpdatePoolAlloc\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"addPremiaRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isCallPool\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_userTVLOld\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_userTVLNew\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalTVL\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_utilizationRate\",\"type\":\"uint256\"}],\"name\":\"allocatePending\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isCallPool\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_userTVLOld\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_userTVLNew\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalTVL\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_utilizationRate\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isCallPool\",\"type\":\"bool\"}],\"name\":\"getPoolInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"allocPoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastRewardTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accPremiaPerShare\",\"type\":\"uint256\"}],\"internalType\":\"struct PremiaMiningStorage.PoolInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPremiaPerYear\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalAllocationPoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"pools\",\"type\":\"address[]\"},{\"internalType\":\"bool[]\",\"name\":\"isCall\",\"type\":\"bool[]\"}],\"name\":\"multiClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isCallPool\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"pendingPremia\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"premiaRewardsAvailable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_premiaPerYear\",\"type\":\"uint256\"}],\"name\":\"setPremiaPerYear\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isCallPool\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_totalTVL\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_utilizationRate\",\"type\":\"uint256\"}],\"name\":\"updatePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"PremiaMining","CompilerVersion":"v0.8.17+commit.8df45f5f","OptimizationUsed":1,"Runs":200,"ConstructorArguments":"0x0000000000000000000000004f273f4efa9ecf5dd245a338fad9fe0bab63b3500000000000000000000000006399c842dd2be3de30bf99bc7d1bbf6fa3650e70000000000000000000000000f1bb87563a122211d40d393ebf1c633c330377f9","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":0,"SwarmSource":""}]}