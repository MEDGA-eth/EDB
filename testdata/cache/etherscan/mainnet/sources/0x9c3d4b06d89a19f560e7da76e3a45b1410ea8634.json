{"expiry":1725830233,"data":[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2024-08-08\r\n*/\r\n\r\n// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity >= 0.8.26;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nstruct LoanDeploymentParams {\r\n    uint256 fundingPeriodInSeconds;\r\n    uint256 newPaymentIntervalInSeconds;\r\n    uint256 newLoanAmountInPrincipalTokens; \r\n    uint256 originationFeePercent2Decimals;\r\n    uint256 newAprWithTwoDecimals;\r\n    uint256 initialCollateralRatioWith2Decimals;\r\n    uint256 maintenanceCollateralRatioWith2Decimals;\r\n    uint256 lateInterestFee;\r\n    uint256 latePrincipalFee;\r\n    uint256 expiryInfo;\r\n    string loanTypeInfo;\r\n    address lenderAddr;\r\n    address borrowerAddr;\r\n    address newCollateralToken;\r\n    address newPrincipalToken;\r\n    address feesManagerAddr;\r\n    address priceOracleAddress;\r\n    address feesCollectorAddress;\r\n    address categoryFeesAdress;\r\n    bool allowSeizeCollateral;\r\n}\r\n\r\nstruct LoanRecord {\r\n    address lenderAddr;\r\n    address borrowerAddr;\r\n    address principalTokenAddr;\r\n    address collateralTokenAddr;\r\n    uint256 loanAmount;\r\n    uint256 initialApr;\r\n    uint256 paymentInterval;\r\n}\r\n\r\nstruct FeeData {\r\n    address feeTokenAddr;       // The token address. This is used when the offset is not available (offset = 0).\r\n    uint256 feeTokenOffset;     // The offset of the token, if any.\r\n    uint256 amountOffset;       // The offset of the amount.\r\n    uint256 feeWithTwoDecimals; // The applicable fee, expressed with 2 decimal places.\r\n}\r\n\r\nstruct CallCheck {\r\n    uint8 checkType;\r\n    address contractAddr;\r\n    uint256 numericVal;\r\n    address contractAddr2;\r\n    uint256 numericVal2;\r\n}\r\n\r\nstruct ModuleFee {\r\n    address tokenAddress;\r\n    uint256 dstAmount;\r\n    uint256 dstPercent;\r\n}\r\n\r\nstruct ModuleResponse {\r\n    uint256[] targetCallValues;\r\n    address[] targetAddresses;\r\n    bytes[] targetPayloads;\r\n    CallCheck[] checks;\r\n    ModuleFee[] feesBefore;\r\n    ModuleFee[] feesAfter;\r\n}\r\n\r\n\r\ninterface IPermissionlessLoansDeployer {\r\n    /**\r\n     * @notice Triggers when a new loan is deployed.\r\n     * @param loanAddr The address of the newly deployed loan.\r\n     * @param lenderAddr The lender.\r\n     * @param borrowerAddr The borrower.\r\n     */\r\n    event PermissionlessLoanDeployed(address indexed loanAddr, address indexed lenderAddr, address indexed borrowerAddr);\r\n\r\n    function deployLoan(LoanDeploymentParams calldata loanParams) external returns (address);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ninterface IHookableLender {\r\n    function notifyLoanClosed() external;\r\n    function notifyLoanMatured() external;\r\n    function notifyPrincipalRepayment(uint256 effectiveLoanAmount, uint256 principalRepaid) external;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// ---------------------------------------------------------------\r\n// States of a loan\r\n// ---------------------------------------------------------------\r\nuint8 constant LOAN_PREAPPROVED = 1;        // The loan was pre-approved by the lender\r\nuint8 constant LOAN_FUNDING_REQUIRED = 2;   // The loan was accepted by the borrower. Waiting for the lender to fund the loan.\r\nuint8 constant LOAN_FUNDED = 3;             // The loan was funded.\r\nuint8 constant LOAN_ACTIVE = 4;             // The loan is active.\r\nuint8 constant LOAN_CANCELLED = 5;          // The lender failed to fund the loan and the borrower claimed their collateral.\r\nuint8 constant LOAN_MATURED = 6;            // The loan matured. It was liquidated by the lender.\r\nuint8 constant LOAN_CLOSED = 7;             // The loan was closed normally.\r\n\r\ninterface IPeerToPeerOpenTermLoan {\r\n    // Functions available to the lender only\r\n    function fundLoan() external;\r\n    function callLoan(uint256 callbackPeriodInSeconds, uint256 gracePeriodInSeconds) external;\r\n    function liquidate() external;\r\n    function proposeNewApr(uint256 newAprWithTwoDecimals) external;\r\n    function changeOracle(address newOracle) external;\r\n    function changeLateFees(uint256 lateInterestFeeWithTwoDecimals, uint256 latePrincipalFeeWithTwoDecimals) external;\r\n    function changeMaintenanceCollateralRatio(uint256 maintenanceCollateralRatioWith2Decimals) external;\r\n    function seizeCollateral(uint256 amount) external;\r\n    function returnCollateral(uint256 depositAmount) external;\r\n\r\n    // Functions available to the borrower only\r\n    function acceptApr() external;\r\n    function borrowerCommitment() external;\r\n    function claimCollateral() external;\r\n    function repay(uint256 paymentAmount) external;\r\n    function repayInterests() external;\r\n    function repayPrincipal(uint256 paymentAmount) external;\r\n\r\n    // The minimum views of a loan\r\n    function lender() external view returns (address);\r\n    function borrower() external view returns (address);\r\n    function principalToken() external view returns (address);\r\n    function collateralToken() external view returns (address);\r\n    function loanState() external view returns (uint8);\r\n    function currentApr() external view returns (uint256);\r\n    function effectiveLoanAmount() external view returns (uint256);\r\n    function getCollateralRequirements() external view returns (uint256 initialCollateralAmount, uint256 maintenanceCollateralAmount);\r\n\r\n    function getDebt() external view returns (\r\n        uint256 currentBillingCycle,\r\n        uint256 cyclesSinceLastAprUpdate,\r\n        uint256 interestOwed,\r\n        uint256 applicableLateFee,\r\n        uint256 minPaymentAmount,\r\n        uint256 maxPaymentAmount\r\n    );\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nabstract contract BaseOwnable {\r\n    address internal _owner;\r\n\r\n    /**\r\n     * @notice Triggers when contract ownership changes.\r\n     * @param previousOwner The previous owner of the contract.\r\n     * @param newOwner The new owner of the contract.\r\n     */\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == _owner, \"Caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nlibrary DateUtils {\r\n    // The number of seconds per day\r\n    uint256 internal constant SECONDS_PER_DAY = 24 * 60 * 60;\r\n\r\n    // The number of seconds per hour\r\n    uint256 internal constant SECONDS_PER_HOUR = 60 * 60;\r\n\r\n    // The number of seconds per minute\r\n    uint256 internal constant SECONDS_PER_MINUTE = 60;\r\n\r\n    // The offset from 01/01/1970\r\n    int256 internal constant OFFSET19700101 = 2440588;\r\n\r\n    function timestampToDate(uint256 ts) internal pure returns (uint256 year, uint256 month, uint256 day) {\r\n        (year, month, day) = _daysToDate(ts / SECONDS_PER_DAY);\r\n    }\r\n\r\n    function timestampToDateTime(uint256 timestamp) internal pure returns (uint256 year, uint256 month, uint256 day, uint256 hour, uint256 minute, uint256 second) {\r\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n        uint256 secs = timestamp % SECONDS_PER_DAY;\r\n        hour = secs / SECONDS_PER_HOUR;\r\n        secs = secs % SECONDS_PER_HOUR;\r\n        minute = secs / SECONDS_PER_MINUTE;\r\n        second = secs % SECONDS_PER_MINUTE;\r\n    }\r\n\r\n    function timestampFromDateTime(uint256 year, uint256 month, uint256 day, uint256 hour, uint256 minute, uint256 second) internal pure returns (uint256 timestamp) {\r\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate year/month/day from the number of days since 1970/01/01 using the date conversion algorithm from http://aa.usno.navy.mil/faq/docs/JD_Formula.php and adding the offset 2440588 so that 1970/01/01 is day 0\r\n     * @dev Taken from https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary/blob/master/contracts/BokkyPooBahsDateTimeLibrary.sol\r\n     * @param _days The year\r\n     * @return year The year\r\n     * @return month The month\r\n     * @return day The day\r\n     */\r\n    function _daysToDate (uint256 _days) internal pure returns (uint256 year, uint256 month, uint256 day) {\r\n        int256 __days = int256(_days);\r\n\r\n        int256 x = __days + 68569 + OFFSET19700101;\r\n        int256 n = 4 * x / 146097;\r\n        x = x - (146097 * n + 3) / 4;\r\n        int256 _year = 4000 * (x + 1) / 1461001;\r\n        x = x - 1461 * _year / 4 + 31;\r\n        int256 _month = 80 * x / 2447;\r\n        int256 _day = x - 2447 * _month / 80;\r\n        x = _month / 11;\r\n        _month = _month + 2 - 12 * x;\r\n        _year = 100 * (n - 49) + _year + x;\r\n\r\n        year = uint256(_year);\r\n        month = uint256(_month);\r\n        day = uint256(_day);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates the number of days from 1970/01/01 to year/month/day using the date conversion algorithm from http://aa.usno.navy.mil/faq/docs/JD_Formula.php and subtracting the offset 2440588 so that 1970/01/01 is day 0\r\n     * @dev Taken from https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary/blob/master/contracts/BokkyPooBahsDateTimeLibrary.sol\r\n     * @param year The year\r\n     * @param month The month\r\n     * @param day The day\r\n     * @return _days Returns the number of days\r\n     */\r\n    function _daysFromDate (uint256 year, uint256 month, uint256 day) internal pure returns (uint256 _days) {\r\n        require(year >= 1970, \"Error\");\r\n        int256 _year = int256(year);\r\n        int256 _month = int256(month);\r\n        int256 _day = int256(day);\r\n\r\n        int256 __days = _day\r\n          - 32075\r\n          + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\r\n          + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\r\n          - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\r\n          - OFFSET19700101;\r\n\r\n        _days = uint256(__days);\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/Math.sol)\r\n\r\n\r\n/**\r\n * @dev Standard math utilities missing in the Solidity language.\r\n */\r\nlibrary MathUpgradeable {\r\n    enum Rounding {\r\n        Down, // Toward negative infinity\r\n        Up, // Toward infinity\r\n        Zero // Toward zero\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a > b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow.\r\n        return (a & b) + (a ^ b) / 2;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the ceiling of the division of two numbers.\r\n     *\r\n     * This differs from standard division with `/` in that it rounds up instead\r\n     * of rounding down.\r\n     */\r\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b - 1) / b can overflow on addition, so we distribute.\r\n        return a == 0 ? 0 : (a - 1) / b + 1;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\r\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\r\n     * with further edits by Uniswap Labs also under MIT license.\r\n     */\r\n    function mulDiv(\r\n        uint256 x,\r\n        uint256 y,\r\n        uint256 denominator\r\n    ) internal pure returns (uint256 result) {\r\n        unchecked {\r\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\r\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\r\n            // variables such that product = prod1 * 2^256 + prod0.\r\n            uint256 prod0; // Least significant 256 bits of the product\r\n            uint256 prod1; // Most significant 256 bits of the product\r\n            assembly {\r\n                let mm := mulmod(x, y, not(0))\r\n                prod0 := mul(x, y)\r\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\r\n            }\r\n\r\n            // Handle non-overflow cases, 256 by 256 division.\r\n            if (prod1 == 0) {\r\n                return prod0 / denominator;\r\n            }\r\n\r\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\r\n            require(denominator > prod1);\r\n\r\n            ///////////////////////////////////////////////\r\n            // 512 by 256 division.\r\n            ///////////////////////////////////////////////\r\n\r\n            // Make division exact by subtracting the remainder from [prod1 prod0].\r\n            uint256 remainder;\r\n            assembly {\r\n                // Compute remainder using mulmod.\r\n                remainder := mulmod(x, y, denominator)\r\n\r\n                // Subtract 256 bit number from 512 bit number.\r\n                prod1 := sub(prod1, gt(remainder, prod0))\r\n                prod0 := sub(prod0, remainder)\r\n            }\r\n\r\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\r\n            // See https://cs.stackexchange.com/q/138556/92363.\r\n\r\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\r\n            uint256 twos = denominator & (~denominator + 1);\r\n            assembly {\r\n                // Divide denominator by twos.\r\n                denominator := div(denominator, twos)\r\n\r\n                // Divide [prod1 prod0] by twos.\r\n                prod0 := div(prod0, twos)\r\n\r\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\r\n                twos := add(div(sub(0, twos), twos), 1)\r\n            }\r\n\r\n            // Shift in bits from prod1 into prod0.\r\n            prod0 |= prod1 * twos;\r\n\r\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\r\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\r\n            // four bits. That is, denominator * inv = 1 mod 2^4.\r\n            uint256 inverse = (3 * denominator) ^ 2;\r\n\r\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\r\n            // in modular arithmetic, doubling the correct bits in each step.\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\r\n\r\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\r\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\r\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\r\n            // is no longer required.\r\n            result = prod0 * inverse;\r\n            return result;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\r\n     */\r\n    function mulDiv(\r\n        uint256 x,\r\n        uint256 y,\r\n        uint256 denominator,\r\n        Rounding rounding\r\n    ) internal pure returns (uint256) {\r\n        uint256 result = mulDiv(x, y, denominator);\r\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\r\n            result += 1;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\r\n     *\r\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\r\n     */\r\n    function sqrt(uint256 a) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\r\n        //\r\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\r\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\r\n        //\r\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\r\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\r\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\r\n        //\r\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\r\n        uint256 result = 1 << (log2(a) >> 1);\r\n\r\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\r\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\r\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\r\n        // into the expected uint128 result.\r\n        unchecked {\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            return min(result, a / result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates sqrt(a), following the selected rounding direction.\r\n     */\r\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = sqrt(a);\r\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 2, rounded down, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log2(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >> 128 > 0) {\r\n                value >>= 128;\r\n                result += 128;\r\n            }\r\n            if (value >> 64 > 0) {\r\n                value >>= 64;\r\n                result += 64;\r\n            }\r\n            if (value >> 32 > 0) {\r\n                value >>= 32;\r\n                result += 32;\r\n            }\r\n            if (value >> 16 > 0) {\r\n                value >>= 16;\r\n                result += 16;\r\n            }\r\n            if (value >> 8 > 0) {\r\n                value >>= 8;\r\n                result += 8;\r\n            }\r\n            if (value >> 4 > 0) {\r\n                value >>= 4;\r\n                result += 4;\r\n            }\r\n            if (value >> 2 > 0) {\r\n                value >>= 2;\r\n                result += 2;\r\n            }\r\n            if (value >> 1 > 0) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log2(value);\r\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 10, rounded down, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log10(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >= 10**64) {\r\n                value /= 10**64;\r\n                result += 64;\r\n            }\r\n            if (value >= 10**32) {\r\n                value /= 10**32;\r\n                result += 32;\r\n            }\r\n            if (value >= 10**16) {\r\n                value /= 10**16;\r\n                result += 16;\r\n            }\r\n            if (value >= 10**8) {\r\n                value /= 10**8;\r\n                result += 8;\r\n            }\r\n            if (value >= 10**4) {\r\n                value /= 10**4;\r\n                result += 4;\r\n            }\r\n            if (value >= 10**2) {\r\n                value /= 10**2;\r\n                result += 2;\r\n            }\r\n            if (value >= 10**1) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log10(value);\r\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 256, rounded down, of a positive value.\r\n     * Returns 0 if given 0.\r\n     *\r\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\r\n     */\r\n    function log256(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >> 128 > 0) {\r\n                value >>= 128;\r\n                result += 16;\r\n            }\r\n            if (value >> 64 > 0) {\r\n                value >>= 64;\r\n                result += 8;\r\n            }\r\n            if (value >> 32 > 0) {\r\n                value >>= 32;\r\n                result += 4;\r\n            }\r\n            if (value >> 16 > 0) {\r\n                value >>= 16;\r\n                result += 2;\r\n            }\r\n            if (value >> 8 > 0) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log256(value);\r\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\r\n\r\n\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\r\n\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n}\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Permit.sol)\r\n\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\r\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\r\n *\r\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\r\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\r\n * need to send a transaction, and thus is not required to hold Ether at all.\r\n */\r\ninterface IERC20Permit {\r\n    /**\r\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\r\n     * given ``owner``'s signed approval.\r\n     *\r\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\r\n     * ordering also apply here.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `deadline` must be a timestamp in the future.\r\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\r\n     * over the EIP712-formatted function arguments.\r\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\r\n     *\r\n     * For more information on the signature format, see the\r\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\r\n     * section].\r\n     */\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Returns the current nonce for `owner`. This value must be\r\n     * included whenever a signature is generated for {permit}.\r\n     *\r\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\r\n     * prevents a signature from being used multiple times.\r\n     */\r\n    function nonces(address owner) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\r\n     */\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n}\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\r\n\r\n\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     *\r\n     * Furthermore, `isContract` will also return true if the target contract within\r\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\r\n     * which only has an effect at the end of a transaction.\r\n     * ====\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\r\n     *\r\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\r\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\r\n     * constructor.\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize/address.code.length, which returns 0\r\n        // for contracts in construction, since the code is only stored at the end\r\n        // of the constructor execution.\r\n\r\n        return account.code.length > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\r\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\r\n     *\r\n     * _Available since v4.8._\r\n     */\r\n    function verifyCallResultFromTarget(\r\n        address target,\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        if (success) {\r\n            if (returndata.length == 0) {\r\n                // only check isContract if the call was successful and the return data is empty\r\n                // otherwise we already know that it was a contract\r\n                require(isContract(target), \"Address: call to non-contract\");\r\n            }\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n     * revert reason or using the provided one.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\r\n        // Look for revert reason and bubble it up if present\r\n        if (returndata.length > 0) {\r\n            // The easiest way to bubble the revert reason is using memory via assembly\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                let returndata_size := mload(returndata)\r\n                revert(add(32, returndata), returndata_size)\r\n            }\r\n        } else {\r\n            revert(errorMessage);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        unchecked {\r\n            uint256 oldAllowance = token.allowance(address(this), spender);\r\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\r\n            uint256 newAllowance = oldAllowance - value;\r\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n        }\r\n    }\r\n\r\n    function safePermit(\r\n        IERC20Permit token,\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) internal {\r\n        uint256 nonceBefore = token.nonces(owner);\r\n        token.permit(owner, spender, value, deadline, v, r, s);\r\n        uint256 nonceAfter = token.nonces(owner);\r\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC4626 \"Tokenized Vault Standard\", as defined in\r\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\r\n *\r\n * _Available since v4.7._\r\n */\r\ninterface IERC4626 {\r\n    /// @notice Triggers when an account deposits funds in the contract\r\n    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\r\n\r\n    event Withdraw(\r\n        address indexed sender,\r\n        address indexed receiver,\r\n        address indexed owner,\r\n        uint256 assets,\r\n        uint256 shares\r\n    );\r\n\r\n    /**\r\n     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\r\n     *\r\n     * - MUST be an ERC-20 token contract.\r\n     * - MUST NOT revert.\r\n     */\r\n    function asset() external view returns (address assetTokenAddress);\r\n\r\n    /**\r\n     * @dev Returns the total amount of the underlying asset that is “managed” by Vault.\r\n     *\r\n     * - SHOULD include any compounding that occurs from yield.\r\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\r\n     * - MUST NOT revert.\r\n     */\r\n    function totalAssets() external view returns (uint256 totalManagedAssets);\r\n\r\n    /**\r\n     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\r\n     * scenario where all the conditions are met.\r\n     *\r\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\r\n     * - MUST NOT show any variations depending on the caller.\r\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\r\n     * - MUST NOT revert.\r\n     *\r\n     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\r\n     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\r\n     * from.\r\n     */\r\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\r\n\r\n    /**\r\n     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\r\n     * scenario where all the conditions are met.\r\n     *\r\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\r\n     * - MUST NOT show any variations depending on the caller.\r\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\r\n     * - MUST NOT revert.\r\n     *\r\n     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\r\n     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\r\n     * from.\r\n     */\r\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\r\n\r\n    /**\r\n     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\r\n     * through a deposit call.\r\n     *\r\n     * - MUST return a limited value if receiver is subject to some deposit limit.\r\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\r\n     * - MUST NOT revert.\r\n     */\r\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\r\n\r\n    /**\r\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\r\n     * current on-chain conditions.\r\n     *\r\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\r\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\r\n     *   in the same transaction.\r\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\r\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\r\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\r\n     * - MUST NOT revert.\r\n     *\r\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\r\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\r\n     */\r\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\r\n\r\n    /**\r\n     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\r\n     *\r\n     * - MUST emit the Deposit event.\r\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\r\n     *   deposit execution, and are accounted for during deposit.\r\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\r\n     *   approving enough underlying tokens to the Vault contract, etc).\r\n     *\r\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\r\n     */\r\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\r\n\r\n    /**\r\n     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\r\n     * - MUST return a limited value if receiver is subject to some mint limit.\r\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\r\n     * - MUST NOT revert.\r\n     */\r\n    function maxMint(address receiver) external view returns (uint256 maxShares);\r\n\r\n    /**\r\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\r\n     * current on-chain conditions.\r\n     *\r\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\r\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\r\n     *   same transaction.\r\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\r\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\r\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\r\n     * - MUST NOT revert.\r\n     *\r\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\r\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\r\n     */\r\n    function previewMint(uint256 shares) external view returns (uint256 assets);\r\n\r\n    /**\r\n     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\r\n     *\r\n     * - MUST emit the Deposit event.\r\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\r\n     *   execution, and are accounted for during mint.\r\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\r\n     *   approving enough underlying tokens to the Vault contract, etc).\r\n     *\r\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\r\n     */\r\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\r\n\r\n    /**\r\n     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\r\n     * Vault, through a withdraw call.\r\n     *\r\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\r\n     * - MUST NOT revert.\r\n     */\r\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\r\n\r\n    /**\r\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\r\n     * given current on-chain conditions.\r\n     *\r\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\r\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\r\n     *   called\r\n     *   in the same transaction.\r\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\r\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\r\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\r\n     * - MUST NOT revert.\r\n     *\r\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\r\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\r\n     */\r\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\r\n\r\n    /**\r\n     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\r\n     *\r\n     * - MUST emit the Withdraw event.\r\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\r\n     *   withdraw execution, and are accounted for during withdraw.\r\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\r\n     *   not having enough shares, etc).\r\n     *\r\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\r\n     * Those methods should be performed separately.\r\n     */\r\n    function withdraw(\r\n        uint256 assets,\r\n        address receiver,\r\n        address owner\r\n    ) external returns (uint256 shares);\r\n\r\n    /**\r\n     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\r\n     * through a redeem call.\r\n     *\r\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\r\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\r\n     * - MUST NOT revert.\r\n     */\r\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\r\n\r\n    /**\r\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\r\n     * given current on-chain conditions.\r\n     *\r\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\r\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\r\n     *   same transaction.\r\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\r\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\r\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\r\n     * - MUST NOT revert.\r\n     *\r\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\r\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\r\n     */\r\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\r\n\r\n    /**\r\n     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\r\n     *\r\n     * - MUST emit the Withdraw event.\r\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\r\n     *   redeem execution, and are accounted for during redeem.\r\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\r\n     *   not having enough shares, etc).\r\n     *\r\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\r\n     * Those methods should be performed separately.\r\n     */\r\n    function redeem(\r\n        uint256 shares,\r\n        address receiver,\r\n        address owner\r\n    ) external returns (uint256 assets);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/utils/Initializable.sol)\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\r\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\r\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\r\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\r\n *\r\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\r\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\r\n * case an upgrade adds a module that needs to be initialized.\r\n *\r\n * For example:\r\n *\r\n * [.hljs-theme-light.nopadding]\r\n * ```solidity\r\n * contract MyToken is ERC20Upgradeable {\r\n *     function initialize() initializer public {\r\n *         __ERC20_init(\"MyToken\", \"MTK\");\r\n *     }\r\n * }\r\n *\r\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\r\n *     function initializeV2() reinitializer(2) public {\r\n *         __ERC20Permit_init(\"MyToken\");\r\n *     }\r\n * }\r\n * ```\r\n *\r\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\r\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\r\n *\r\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\r\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\r\n *\r\n * [CAUTION]\r\n * ====\r\n * Avoid leaving a contract uninitialized.\r\n *\r\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\r\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\r\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\r\n *\r\n * [.hljs-theme-light.nopadding]\r\n * ```\r\n * /// @custom:oz-upgrades-unsafe-allow constructor\r\n * constructor() {\r\n *     _disableInitializers();\r\n * }\r\n * ```\r\n * ====\r\n */\r\nabstract contract Initializable {\r\n    /**\r\n     * @dev Indicates that the contract has been initialized.\r\n     * @custom:oz-retyped-from bool\r\n     */\r\n    uint8 private _initialized;\r\n\r\n    /**\r\n     * @dev Indicates that the contract is in the process of being initialized.\r\n     */\r\n    bool private _initializing;\r\n\r\n    /**\r\n     * @dev Triggered when the contract has been initialized or reinitialized.\r\n     */\r\n    event Initialized(uint8 version);\r\n\r\n    /**\r\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\r\n     * `onlyInitializing` functions can be used to initialize parent contracts.\r\n     *\r\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\r\n     * constructor.\r\n     *\r\n     * Emits an {Initialized} event.\r\n     */\r\n    modifier initializer() {\r\n        bool isTopLevelCall = !_initializing;\r\n        require(\r\n            (isTopLevelCall && _initialized < 1) || (!Address.isContract(address(this)) && _initialized == 1),\r\n            \"Initializable: contract is already initialized\"\r\n        );\r\n        _initialized = 1;\r\n        if (isTopLevelCall) {\r\n            _initializing = true;\r\n        }\r\n        _;\r\n        if (isTopLevelCall) {\r\n            _initializing = false;\r\n            emit Initialized(1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\r\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\r\n     * used to initialize parent contracts.\r\n     *\r\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\r\n     * are added through upgrades and that require initialization.\r\n     *\r\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\r\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\r\n     *\r\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\r\n     * a contract, executing them in the right order is up to the developer or operator.\r\n     *\r\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\r\n     *\r\n     * Emits an {Initialized} event.\r\n     */\r\n    modifier reinitializer(uint8 version) {\r\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\r\n        _initialized = version;\r\n        _initializing = true;\r\n        _;\r\n        _initializing = false;\r\n        emit Initialized(version);\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\r\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\r\n     */\r\n    modifier onlyInitializing() {\r\n        require(_initializing, \"Initializable: contract is not initializing\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\r\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\r\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\r\n     * through proxies.\r\n     *\r\n     * Emits an {Initialized} event the first time it is successfully executed.\r\n     */\r\n    function _disableInitializers() internal virtual {\r\n        require(!_initializing, \"Initializable: contract is initializing\");\r\n        if (_initialized != type(uint8).max) {\r\n            _initialized = type(uint8).max;\r\n            emit Initialized(type(uint8).max);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\r\n     */\r\n    function _getInitializedVersion() internal view returns (uint8) {\r\n        return _initialized;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\r\n     */\r\n    function _isInitializing() internal view returns (bool) {\r\n        return _initializing;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Base reentrancy guard. This is constructor-less implementation for both proxies and standalone contracts.\r\n */\r\nabstract contract BaseReentrancyGuard {\r\n    uint256 internal constant _REENTRANCY_NOT_ENTERED = 1;\r\n    uint256 internal constant _REENTRANCY_ENTERED = 2;\r\n\r\n    uint256 internal _reentrancyStatus;\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _nonReentrantBefore();\r\n        _;\r\n        _nonReentrantAfter();\r\n    }\r\n\r\n    function _nonReentrantBefore() private {\r\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\r\n        require(_reentrancyStatus != _REENTRANCY_ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _reentrancyStatus = _REENTRANCY_ENTERED;\r\n    }\r\n\r\n    function _nonReentrantAfter() private {\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _reentrancyStatus = _REENTRANCY_NOT_ENTERED;\r\n    }\r\n\r\n    /*\r\n    /// @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a `nonReentrant` function in the call stack.\r\n    function _reentrancyGuardEntered() internal view returns (bool) {\r\n        return _reentrancyStatus == _REENTRANCY_ENTERED;\r\n    }\r\n    */\r\n}\r\n\r\n\r\n/**\r\n * @title Tokenizes a liability per EIP-20.\r\n * @dev The liability is upgradeable per EIP-1967. Reentrancy checks in place.\r\n */\r\nabstract contract BaseUpgradeableERC20 is IERC20, Initializable, BaseReentrancyGuard {\r\n    /// @notice The decimal places of the token.\r\n    uint8 public decimals;\r\n\r\n    /// @notice The token symbol.\r\n    string public symbol;\r\n\r\n    /// @notice The descriptive name of the token.\r\n    string public name;\r\n\r\n    /// @dev The total circulating supply of the token\r\n    uint256 internal _totalSupply;\r\n\r\n    /// @dev The maximum circulating supply of the token, if any. Set to zero if there is no max limit.\r\n    uint256 internal _maxSupply;\r\n\r\n    /// @dev The balance of each holder\r\n    mapping(address => uint256) internal _balances;\r\n\r\n    /// @dev The allowance of each spender, which is set by each owner\r\n    mapping(address => mapping(address => uint256)) internal _allowances;\r\n\r\n    /**\r\n     * @notice This event is triggered when the maximum limit for minting tokens is updated.\r\n     * @param prevValue The previous limit\r\n     * @param newValue The new limit\r\n     */\r\n    event OnMaxSupplyChanged(uint256 prevValue, uint256 newValue);\r\n\r\n    // --------------------------------------------------------------------------\r\n    // Modifiers\r\n    // --------------------------------------------------------------------------\r\n    /**\r\n     * @notice Indicates if this contract implementation was initialized at the proxy\r\n     * @dev Throws if the contract was not initialized\r\n     */\r\n    modifier onlyIfInitialized() {\r\n        require(_getInitializedVersion() != type(uint8).max, \"Contract not initialized yet\");\r\n        _;\r\n    }\r\n\r\n    // --------------------------------------------------------------------------\r\n    // ERC-20 interface implementation\r\n    // --------------------------------------------------------------------------\r\n    /**\r\n     * @notice Transfers a given amount tokens to the address specified.\r\n     * @param to The address to transfer to.\r\n     * @param value The amount to be transferred.\r\n     * @return Returns true in case of success.\r\n     */\r\n    function transfer(address to, uint256 value) external override onlyIfInitialized nonReentrant returns (bool) {\r\n        return _executeErc20Transfer(msg.sender, to, value);\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer tokens from one address to another.\r\n     * @dev Note that while this function emits an Approval event, this is not required as per the specification,\r\n     * and other compliant implementations may not emit the event.\r\n     * @param from address The address which you want to send tokens from\r\n     * @param to address The address which you want to transfer to\r\n     * @param value uint256 the amount of tokens to be transferred\r\n     * @return Returns true in case of success.\r\n     */\r\n    function transferFrom(address from, address to, uint256 value) external override onlyIfInitialized nonReentrant returns (bool) {\r\n        uint256 currentAllowance = _allowances[from][msg.sender];\r\n        require(currentAllowance >= value, \"Amount exceeds allowance\");\r\n\r\n        require (_executeErc20Transfer(from, to, value), \"Failed to execute transferFrom\");\r\n\r\n        _approveSpender(from, msg.sender, currentAllowance - value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n     * @dev Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n     * and the new allowance by unfortunate transaction ordering.\r\n     * One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0\r\n     * and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     * @param spender The address which will spend the funds.\r\n     * @param value The amount of tokens to be spent.\r\n     * @return Returns true in case of success.\r\n     */\r\n    function approve(address spender, uint256 value) external override onlyIfInitialized nonReentrant returns (bool) {\r\n        _approveSpender(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the current version of the token.\r\n     * @return uint8 The current version of the contract.\r\n     */\r\n    function getInitializedVersion() external view onlyIfInitialized returns (uint8) {\r\n        return _getInitializedVersion();\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the total circulating supply of tokens\r\n     * @return uint256 The total circulating supply of tokens\r\n     */\r\n    function totalSupply() external view override onlyIfInitialized returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the balance of the address specified.\r\n     * @param addr The address to query the balance of.\r\n     * @return uint256 An uint256 representing the amount owned by the passed address.\r\n     */\r\n    function balanceOf(address addr) external view override onlyIfInitialized returns (uint256) {\r\n        return _balances[addr];\r\n    }\r\n\r\n    /**\r\n     * @notice Function to check the amount of tokens that an owner allowed to a spender.\r\n     * @param ownerAddr address The address which owns the funds.\r\n     * @param spenderAddr address The address which will spend the funds.\r\n     * @return uint256 A uint256 specifying the amount of tokens still available for the spender.\r\n     */\r\n    function allowance(address ownerAddr, address spenderAddr) external view override onlyIfInitialized returns (uint256) {\r\n        return _allowances[ownerAddr][spenderAddr];\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the maximum token supply.\r\n     * @return uint256 The maximum token supply.\r\n     */\r\n    function maxSupply() external view onlyIfInitialized returns (uint256) {\r\n        return _maxSupply;\r\n    }\r\n\r\n    // --------------------------------------------------------------------------\r\n    // Implementation functions\r\n    // --------------------------------------------------------------------------\r\n    function _executeErc20Transfer(address from, address to, uint256 value) internal virtual returns (bool) {\r\n        // Checks\r\n        require(to != address(0), \"non-zero address required\");\r\n        require(from != address(0), \"non-zero sender required\");\r\n        require(value > 0, \"Amount cannot be zero\");\r\n        require(_balances[from] >= value, \"Amount exceeds sender balance\");\r\n\r\n        // State changes\r\n        _balances[from] = _balances[from] - value;\r\n        _balances[to] = _balances[to] + value;\r\n\r\n        // Emit the event per ERC-20\r\n        emit Transfer(from, to, value);\r\n\r\n        return true;\r\n    }\r\n\r\n    function _approveSpender(address ownerAddr, address spender, uint256 value) internal virtual {\r\n        require(spender != address(0), \"non-zero spender required\");\r\n        require(ownerAddr != address(0), \"non-zero owner required\");\r\n\r\n        // State changes\r\n        _allowances[ownerAddr][spender] = value;\r\n\r\n        // Emit the event\r\n        emit Approval(ownerAddr, spender, value);\r\n    }\r\n\r\n    function _spendAllowance (address ownerAddr, address spenderAddr, uint256 amount) internal virtual {\r\n        uint256 currentAllowance = _allowances[ownerAddr][spenderAddr];\r\n        if (currentAllowance != type(uint256).max) {\r\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\r\n            _approveSpender(ownerAddr, spenderAddr, currentAllowance - amount);\r\n        }\r\n    }\r\n\r\n    function _mintErc20(address addr, uint256 amount) internal virtual {\r\n        require(amount > 0, \"Invalid amount\");\r\n        require(_canMint(amount), \"Max supply limit reached\");\r\n\r\n        _totalSupply += amount;\r\n        _balances[addr] += amount;\r\n\r\n        emit Transfer(address(0), addr, amount);\r\n    }\r\n\r\n    function _burnErc20(address addr, uint256 amount) internal virtual {\r\n        require(amount > 0, \"Invalid amount\");\r\n        require(_balances[addr] >= amount, \"Burn amount exceeds balance\");\r\n\r\n        _balances[addr] -= amount;\r\n        _totalSupply -= amount;\r\n\r\n        emit Transfer(addr, address(0), amount);\r\n    }\r\n\r\n    function _setMaxSupply(uint256 newValue) internal virtual {\r\n        require(newValue > 0 && newValue > _totalSupply, \"Invalid max supply\");\r\n\r\n        uint256 prevValue = _maxSupply;\r\n        _maxSupply = newValue;\r\n\r\n        emit OnMaxSupplyChanged(prevValue, newValue);\r\n    }\r\n\r\n    // Indicates if we can issue/mint the number of tokens specified.\r\n    function _canMint(uint256 amount) internal view virtual returns (bool) {        \r\n        return _maxSupply - _totalSupply >= amount;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Represents a liquidity pool. The pool works per ERC-4626 standard. The pool can be paused.\r\n */\r\nabstract contract BaseUpgradeableERC4626 is IERC4626, BaseUpgradeableERC20 {\r\n    using MathUpgradeable for uint256;\r\n\r\n    /// @notice Indicates whether deposits are paused or not.\r\n    bool public depositsPaused;\r\n\r\n    /// @notice Indicates whether withdrawals are paused or not.\r\n    bool public withdrawalsPaused;\r\n\r\n    /// @dev The underlying asset of the pool\r\n    IERC20 internal _underlyingAsset;\r\n\r\n    /// @dev The address of the fees collector, if any.\r\n    address public feesCollector;\r\n\r\n    /// @notice The maximum deposit amount.\r\n    uint256 public maxDepositAmount;\r\n\r\n    /// @notice The maximum withdrawal amount.\r\n    uint256 public maxWithdrawalAmount;\r\n\r\n    /// @notice The fee to apply when an account withdraws funds from the pool.\r\n    uint256 public withdrawalFee;\r\n\r\n    /**\r\n     * @notice Triggers when deposits/withdrawals are paused or resumed.\r\n     * @param bDepositsPaused The new state for deposits\r\n     * @param bWithdrawalsPaused The new state for withdrawals\r\n     */\r\n    event DepositWithdrawalStatusChanged(bool bDepositsPaused, bool bWithdrawalsPaused);\r\n\r\n    // ---------------------------------------------------------------\r\n    // Modifiers\r\n    // ---------------------------------------------------------------\r\n    modifier ifConfigured() {\r\n        require(address(_underlyingAsset) != address(0), \"Not configured\");\r\n        _;\r\n    }\r\n\r\n    modifier ifNotConfigured() {\r\n        require(address(_underlyingAsset) == address(0), \"Already configured\");\r\n        _;\r\n    }\r\n\r\n    modifier ifDepositsNotPaused() {\r\n        require(!depositsPaused, \"Deposits paused\");\r\n        _;\r\n    }\r\n\r\n    modifier ifWithdrawalsNotPaused() {\r\n        require(!withdrawalsPaused, \"Withdrawals paused\");\r\n        _;\r\n    }\r\n\r\n    // --------------------------------------------------------------------------\r\n    // ERC-4626 interface implementation\r\n    // --------------------------------------------------------------------------\r\n    /**\r\n     * @notice Deposits funds in the pool. Issues LP tokens in exchange for the deposit.\r\n     * @dev Throws if the deposit limit is reached.\r\n     * @param assets The deposit amount, expressed in underlying tokens. For example: USDC, DAI, etc.\r\n     * @param receiver The address that will receive the LP tokens. It is usually the same as a the sender.\r\n     * @return shares The number of LP tokens issued to the receiving address specified.\r\n     */\r\n    function deposit(\r\n        uint256 assets, \r\n        address receiver\r\n    ) external override nonReentrant ifConfigured ifDepositsNotPaused returns (uint256 shares) {\r\n        require(receiver != address(0) && receiver != address(this), \"Invalid receiver\");\r\n        require(assets > 0, \"Assets amount required\");\r\n        require(assets <= maxDeposit(receiver), \"Deposit limit reached\");\r\n\r\n        shares = previewDeposit(assets);\r\n        require(shares > 0, \"Shares amount required\");\r\n\r\n        _deposit(msg.sender, receiver, assets, shares);\r\n    }\r\n\r\n    /**\r\n     * @notice Issues a specific amount of LP tokens to the receiver specified.\r\n     * @dev Throws if the deposit limit is reached regardless of how many LP tokens you want to mint.\r\n     * @param shares The amount of LP tokens to mint.\r\n     * @param receiver The address of the receiver. It is usually the same as a the sender.\r\n     * @return assets The amount of underlying assets per current ratio\r\n     */\r\n    function mint(\r\n        uint256 shares, \r\n        address receiver\r\n    ) external override nonReentrant ifConfigured ifDepositsNotPaused returns (uint256 assets) {\r\n        require(receiver != address(0) && receiver != address(this), \"Invalid receiver\");\r\n        require(shares > 0, \"Shares amount required\");\r\n        require(shares <= maxMint(receiver), \"ERC4626: mint more than max\");\r\n\r\n        assets = previewMint(shares);\r\n        require(assets <= maxDeposit(receiver), \"Deposit limit reached\");\r\n\r\n        _deposit(msg.sender, receiver, assets, shares);\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the underlying asset of the pool.\r\n     * @return address The address of the asset.\r\n     */\r\n    function asset() external view override onlyIfInitialized returns (address) {\r\n        return address(_underlyingAsset);\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the total assets amount managed by the pool.\r\n     * @return uint256 The assets amount.\r\n     */\r\n    function totalAssets() external view virtual override ifConfigured returns (uint256) {\r\n        return _getTotalAssets();\r\n    }\r\n\r\n    function previewDeposit(uint256 assets) public view virtual override ifConfigured returns (uint256) {\r\n        return _convertToShares(assets, MathUpgradeable.Rounding.Down);\r\n    }\r\n\r\n    function previewMint(uint256 shares) public view virtual override ifConfigured returns (uint256) {\r\n        return _convertToAssets(shares, MathUpgradeable.Rounding.Up);\r\n    }\r\n\r\n    function previewWithdraw(uint256 assets) public view virtual override ifConfigured returns (uint256) {\r\n        return _convertToShares(assets, MathUpgradeable.Rounding.Up);\r\n    }\r\n\r\n    function previewRedeem(uint256 shares) public view virtual override ifConfigured returns (uint256 assets) {\r\n        (, assets) = _previewRedeemWithFees(shares);\r\n    }\r\n\r\n    function convertToShares(uint256 assets) public view virtual override ifConfigured returns (uint256) {\r\n        return _convertToShares(assets, MathUpgradeable.Rounding.Down);\r\n    }\r\n\r\n    function convertToAssets(uint256 shares) public view virtual override ifConfigured returns (uint256) {\r\n        return _convertToAssets(shares, MathUpgradeable.Rounding.Down);\r\n    }\r\n\r\n    function maxDeposit(address) public view virtual override ifConfigured returns (uint256) {\r\n        return _isVaultHealthy() ? maxDepositAmount : 0;\r\n    }\r\n\r\n    function maxMint(address) public view virtual override ifConfigured returns (uint256) {\r\n        return _maxSupply;\r\n    }\r\n\r\n    function maxWithdraw(address holderAddr) public view virtual override ifConfigured returns (uint256) {\r\n        return _convertToAssets(_balances[holderAddr], MathUpgradeable.Rounding.Down);\r\n    }\r\n\r\n    function maxRedeem(address holderAddr) public view virtual override ifConfigured returns (uint256) {\r\n        return _balances[holderAddr];\r\n    }\r\n\r\n    // --------------------------------------------------------------------------\r\n    // Implementation functions\r\n    // --------------------------------------------------------------------------\r\n    function _deposit(\r\n        address callerAddr,\r\n        address receiverAddr,\r\n        uint256 assets,\r\n        uint256 shares\r\n    ) internal virtual {\r\n        // If _asset is ERC777, `transferFrom` can trigger a reenterancy BEFORE the transfer happens through the\r\n        // `tokensToSend` hook. On the other hand, the `tokenReceived` hook, that is triggered after the transfer,\r\n        // calls the vault, which is assumed not malicious.\r\n        //\r\n        // Conclusion: we need to do the transfer before we mint so that any reentrancy would happen before the\r\n        // assets are transferred and before the shares are minted, which is a valid state.\r\n        // slither-disable-next-line reentrancy-no-eth\r\n        uint256 expectedBalanceAfterTransfer = assets + _underlyingAsset.balanceOf(address(this));\r\n        SafeERC20.safeTransferFrom(_underlyingAsset, callerAddr, address(this), assets);\r\n        require(_underlyingAsset.balanceOf(address(this)) == expectedBalanceAfterTransfer, \"Balance check failed\");\r\n\r\n        // Issue (mint) LP tokens to the receiver\r\n        _mintErc20(receiverAddr, shares);\r\n\r\n        // Log the ERC-4626 event\r\n        emit Deposit(callerAddr, receiverAddr, assets, shares);\r\n    }\r\n\r\n    function _updateIssuanceLimits(\r\n        uint256 newMaxDepositAmount, \r\n        uint256 newMaxWithdrawalAmount, \r\n        uint256 newMaxTokenSupply\r\n    ) internal virtual {\r\n        require(newMaxDepositAmount > 0, \"Invalid deposit limit\");\r\n        require(newMaxWithdrawalAmount > 0, \"Invalid withdrawal limit\");\r\n        \r\n        _setMaxSupply(newMaxTokenSupply);\r\n\r\n        maxDepositAmount = newMaxDepositAmount;\r\n        maxWithdrawalAmount = newMaxWithdrawalAmount;\r\n    }\r\n\r\n    function _setPause(bool bPauseDeposits, bool bPauseWithdrawals) internal virtual {\r\n        depositsPaused = bPauseDeposits;\r\n        withdrawalsPaused = bPauseWithdrawals;\r\n        \r\n        emit DepositWithdrawalStatusChanged(depositsPaused, withdrawalsPaused);\r\n    }\r\n\r\n    // --------------------------------------------------------------------------\r\n    // Inner views\r\n    // --------------------------------------------------------------------------\r\n    function _getTotalAssets() internal view virtual returns (uint256);\r\n\r\n    function _isVaultHealthy() internal view virtual returns (bool) {\r\n        return _totalSupply == 0 || _getTotalAssets() > 0;\r\n    }\r\n\r\n    // Internal conversion function (from assets to shares) to apply when the vault is empty.\r\n    function _initialConvertToShares(uint256 assets, MathUpgradeable.Rounding) internal view virtual returns (uint256 shares) {\r\n        return assets;\r\n    }\r\n\r\n    // Internal conversion function (from shares to assets) to apply when the vault is empty.\r\n    function _initialConvertToAssets(uint256 shares, MathUpgradeable.Rounding) internal view virtual returns (uint256) {\r\n        return shares;\r\n    }\r\n\r\n    // Internal conversion function (from assets to shares) with support for rounding direction.\r\n    // Will revert if assets > 0, totalSupply > 0 and totalAssets = 0. \r\n    // That corresponds to a case where any asset would represent an infinite amount of shares.\r\n    function _convertToShares(uint256 assets, MathUpgradeable.Rounding rounding) internal view virtual returns (uint256) {\r\n        return (assets == 0 || _totalSupply == 0) ? _initialConvertToShares(assets, rounding) : assets.mulDiv(_totalSupply, _getTotalAssets(), rounding);\r\n    }\r\n\r\n    // Internal conversion function (from shares to assets) with support for rounding direction.\r\n    function _convertToAssets(uint256 shares, MathUpgradeable.Rounding rounding) internal view virtual returns (uint256) {\r\n        return (_totalSupply == 0) ? _initialConvertToAssets(shares, rounding) : shares.mulDiv(_getTotalAssets(), _totalSupply, rounding);\r\n    }\r\n\r\n    function _previewRedeemWithFees(uint256 shares) internal view returns (uint256 assetsAmount, uint256 assetsAfterFee) {\r\n        assetsAmount = _convertToAssets(shares, MathUpgradeable.Rounding.Down);\r\n        assetsAfterFee = assetsAmount;\r\n        uint256 applicableFee = 0;\r\n\r\n        if (withdrawalFee > 0) {\r\n            applicableFee = withdrawalFee * assetsAmount / 1e4;\r\n            assetsAfterFee = assetsAmount - applicableFee;\r\n        }\r\n\r\n        return (assetsAmount, assetsAfterFee);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Represents a liquidity pool in which withdrawals can be time-locked or instantaneous.\r\n * @dev The liquidity pool accepts deposits in a single token only, per ERC-4626.\r\n */\r\nabstract contract TimelockedERC4626 is BaseUpgradeableERC4626 {\r\n    /// @dev A reasonable time-window for manipulating the block timestamp as a miner.\r\n    uint256 constant internal _TIMESTAMP_MANIPULATION_WINDOW = 5 minutes;\r\n\r\n    struct RedeemSummary {\r\n        uint256 shares; // The number of shares to burn.\r\n        uint256 assets; // The asset amount that was claimable at redemption time per current token price.\r\n    }\r\n\r\n    /// @notice The hour at which withdrawals are processed. It ranges from 0 to 23.\r\n    uint8 public liquidationHour;\r\n\r\n    /// @notice The duration of the time-lock for withdrawals.\r\n    uint256 public lagDuration;\r\n\r\n    /// @notice The total number of shares that need to be burned.\r\n    uint256 public globalLiabilityShares;\r\n\r\n    /// @notice The total amount of collectable fees, at any point in time.\r\n    uint256 public totalCollectableFees;\r\n\r\n    /// @dev The liability (forecast) that needs to be fulfilled at a given point in time\r\n    mapping (bytes32 => RedeemSummary) internal _dailyRequirement;\r\n\r\n    /// @dev The list of addresses that can claim funds at a given point in time\r\n    mapping (bytes32 => address[]) internal _uniqueReceiversPerCluster;\r\n\r\n    /// @dev The index of each unique receiver per cluster\r\n    mapping (bytes32 => mapping(address => uint256)) private _receiverIndexes;\r\n\r\n    /// @dev The amount of underlying tokens that can be claimed by a given address at a specific point in time\r\n    mapping (bytes32 => mapping(address => uint256)) internal _receiverAmounts;\r\n\r\n    /// @dev The number of shares that can be burned by a given address at a specific point in time\r\n    mapping (bytes32 => mapping(address => uint256)) internal _burnableAmounts;\r\n\r\n    mapping (bytes32 => mapping(address => uint256)) internal _feeAmountsByReceiver;\r\n\r\n    /**\r\n     * @notice This event is triggered when a holder requests a withdrawal.\r\n     * @param ownerAddr The address of the holder.\r\n     * @param receiverAddr The address of the receiver.\r\n     * @param shares The amount of shares (LP tokens) to burn.\r\n     * @param assets The amount of underlying assets to transfer.\r\n     * @param fee The fee applied to the withdrawal.\r\n     * @param year The year component of the scheduled date.\r\n     * @param month The month component of the scheduled date.\r\n     * @param day The day component of the scheduled date.\r\n     */\r\n    event WithdrawalRequested (address ownerAddr, address receiverAddr, uint256 shares, uint256 assets, uint256 fee, uint256 year, uint256 month, uint256 day);\r\n\r\n    // ----------------------------------------\r\n    // ERC-4626 endpoint overrides\r\n    // ----------------------------------------\r\n    function withdraw(\r\n        uint256, \r\n        address, \r\n        address\r\n    ) external override pure returns (uint256) {\r\n        // Revert the call to ERC4626.withdraw(args) in order to stay compatible with the ERC-4626 standard.\r\n        // Per ERC-4626 spec (https://eips.ethereum.org/EIPS/eip-4626):\r\n        // - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner not having enough shares, etc).\r\n        // - Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed. \r\n        //   Those methods should be performed separately.\r\n        revert(\"Withdrawal request required\");\r\n\r\n        // We could enqueue a withdrawal request from this endpoint, but it wouldn't compatible with the ERC-4626 standard.\r\n        // Likewise, we could process the funds for the receiver sppecified but -again- it wouldn't compatible with the ERC-4626 standard.\r\n        // Hence the tx revert. Provided we revert in all cases, the function becomes pure.\r\n    }\r\n\r\n    function redeem(\r\n        uint256, \r\n        address, \r\n        address\r\n    ) external override pure returns (uint256) {\r\n        // Revert the call to ERC4626.redeem(args) in order to stay compatible with the ERC-4626 standard.\r\n        // Per ERC-4626 spec (https://eips.ethereum.org/EIPS/eip-4626):\r\n        // - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner not having enough shares, etc).\r\n        // - Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed. \r\n        //   Those methods should be performed separately.\r\n        revert(\"Withdrawal request required\");\r\n\r\n        // We could enqueue a withdrawal request from this endpoint, but it wouldn't compatible with the ERC-4626 standard.\r\n        // Likewise, we could process the funds for the receiver sppecified but -again- it wouldn't compatible with the ERC-4626 standard.\r\n        // Hence the tx revert. Provided we revert in all cases, the function becomes pure.\r\n    }\r\n\r\n    // ----------------------------------------\r\n    // Timelocked ERC-4626 features\r\n    // ----------------------------------------\r\n    /**\r\n     * @notice Requests to redeem a given number of shares from the holder specified.\r\n     * @dev The respective amount of assets will be made available in X hours from now, where \"X\" is the lag defined by the owner of the pool.\r\n     * @param shares The number of shares to burn.\r\n     * @param receiverAddr The address of the receiver.\r\n     * @param holderAddr The address of the tokens holder.\r\n     * @return assets The amount of assets that can be claimed for this specific withdrawal request.\r\n     * @return claimableEpoch The date at which the assets become claimable. This is expressed as a Unix epoch.\r\n     */\r\n    function requestRedeem(\r\n        uint256 shares, \r\n        address receiverAddr, \r\n        address holderAddr\r\n    ) external nonReentrant ifConfigured ifWithdrawalsNotPaused returns (\r\n        uint256 assets, \r\n        uint256 claimableEpoch\r\n    ) {\r\n        uint256 year;\r\n        uint256 month;\r\n        uint256 day;\r\n        (claimableEpoch, year, month, day, assets) = _registerRedeemRequest(shares, holderAddr, receiverAddr, msg.sender);\r\n\r\n        // If the pool is not time-locked then transfer the funds immediately.\r\n        if (lagDuration == 0) {\r\n            claimableEpoch = block.timestamp;\r\n            _claim(year, month, day, receiverAddr);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Allows any public address to process the scheduled withdrawal requests of the receiver specified.\r\n     * @dev Throws if the receiving address is not the legitimate address you registered via \"requestRedeem()\"\r\n     * @param year The year component of the claim. It can be a past date.\r\n     * @param month The month component of the claim. It can be a past date.\r\n     * @param day The day component of the claim. It can be a past date.\r\n     * @param receiverAddr The address of the legitimate receiver of the funds.\r\n     * @return uint256 The effective number of shares (LP tokens) that were burnt from the liquidity pool.\r\n     * @return uint256 The effective amount of underlying assets that were transfered to the receiver.\r\n     */\r\n    function claim(\r\n        uint256 year, \r\n        uint256 month, \r\n        uint256 day,\r\n        address receiverAddr\r\n    ) external nonReentrant ifConfigured ifWithdrawalsNotPaused returns (uint256, uint256) {\r\n        // This function is provided as a fallback.\r\n        // If -for any reason- a third party does not process the scheduled withdrawals then the \r\n        // legitimate receiver can claim the respective funds on their own.\r\n        // Thus as a legitimate receiver you can always claim your funds, even if the processing party fails to honor their promise.\r\n        return _claim(year, month, day, receiverAddr);\r\n    }\r\n\r\n    /**\r\n     * @notice Processes all of the withdrawal requests scheduled for the date specified.\r\n     * @dev Throws if the date is earlier than the liquidation/processing hour.\r\n     * @param year The year component of the claim. It can be a past date.\r\n     * @param month The month component of the claim. It can be a past date.\r\n     * @param day The day component of the claim. It can be a past date.\r\n     * @param maxLimit The number of transactions to process. The maximum is defined by the function \"getScheduledTransactionsByDate()\"\r\n     */\r\n    function processAllClaimsByDate(\r\n        uint256 year, \r\n        uint256 month, \r\n        uint256 day,\r\n        uint256 maxLimit\r\n    ) external nonReentrant ifConfigured ifWithdrawalsNotPaused {\r\n        require(maxLimit > 0, \"Limit required\");\r\n\r\n        bytes32 dailyCluster = keccak256(abi.encode(year, month, day));\r\n\r\n        // Make sure we have pending requests to process.\r\n        require(_dailyRequirement[dailyCluster].assets > 0, \"Nothing to process\");\r\n\r\n        // Make sure withdrawals are processed at the expected epoch only.\r\n        require(block.timestamp + _TIMESTAMP_MANIPULATION_WINDOW >= DateUtils.timestampFromDateTime(year, month, day, liquidationHour, 0, 0), \"Too early\");\r\n\r\n        // This is the number of unique ERC20 transfers we will need to make in this transaction\r\n        uint256 workSize = (_uniqueReceiversPerCluster[dailyCluster].length > maxLimit) ? maxLimit : _uniqueReceiversPerCluster[dailyCluster].length;\r\n        uint256 startingPos = _uniqueReceiversPerCluster[dailyCluster].length;\r\n\r\n        address[] memory receivers = new address[](workSize);\r\n        uint256[] memory amounts = new uint256[](workSize);\r\n        uint256 totalFees;\r\n        uint256 sharesToBurn;\r\n        uint256 assetsToSend;\r\n        uint256 x = workSize;\r\n        address receiverAddr;\r\n\r\n        for (uint256 i = startingPos; i > (startingPos - workSize); i--) {\r\n            receiverAddr = _uniqueReceiversPerCluster[dailyCluster][i - 1];\r\n            x--;\r\n            receivers[x] = receiverAddr;\r\n            amounts[x] = _receiverAmounts[dailyCluster][receiverAddr];\r\n            assetsToSend += amounts[x];\r\n            sharesToBurn += _burnableAmounts[dailyCluster][receiverAddr];\r\n            totalFees += _feeAmountsByReceiver[dailyCluster][receiverAddr];\r\n            _receiverAmounts[dailyCluster][receiverAddr] = 0;\r\n            _burnableAmounts[dailyCluster][receiverAddr] = 0;\r\n            _feeAmountsByReceiver[dailyCluster][receiverAddr] = 0;\r\n            _uniqueReceiversPerCluster[dailyCluster].pop();\r\n            _receiverIndexes[dailyCluster][receiverAddr] = 0;\r\n        }\r\n\r\n        globalLiabilityShares -= sharesToBurn;\r\n        totalCollectableFees += totalFees;\r\n        _dailyRequirement[dailyCluster].assets -= assetsToSend;\r\n        _dailyRequirement[dailyCluster].shares -= sharesToBurn;\r\n\r\n        // Make sure the pool has enough balance to cover withdrawals.\r\n        uint256 balanceBefore = IERC20(_underlyingAsset).balanceOf(address(this));\r\n        require(balanceBefore >= assetsToSend, \"Insufficient balance\");\r\n\r\n        _burnErc20(address(this), sharesToBurn);\r\n\r\n        // Untrusted external calls        \r\n        for (uint256 i; i < receivers.length; i++) {\r\n            SafeERC20.safeTransfer(_underlyingAsset, receivers[i], amounts[i]);\r\n        }\r\n\r\n        // Balance check, provided the external asset is untrusted\r\n        require(IERC20(_underlyingAsset).balanceOf(address(this)) == balanceBefore - assetsToSend, \"Balance check failed\");\r\n    }\r\n\r\n    // ----------------------------------------\r\n    // Views\r\n    // ----------------------------------------\r\n    /**\r\n     * @notice Gets the date at which your withdrawal request can be claimed.\r\n     * @return year The year.\r\n     * @return month The month.\r\n     * @return day The day.\r\n     * @return claimableEpoch The Unix epoch at which your withdrawal request can be claimed.\r\n     */\r\n    function getWithdrawalEpoch() external view ifConfigured returns (\r\n        uint256 year, \r\n        uint256 month, \r\n        uint256 day,\r\n        uint256 claimableEpoch\r\n    ) {\r\n        (year, month, day) = DateUtils.timestampToDate(block.timestamp + _TIMESTAMP_MANIPULATION_WINDOW + lagDuration);\r\n        claimableEpoch = DateUtils.timestampFromDateTime(year, month, day, liquidationHour, 0, 0);\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the funding requirement of the date specified.\r\n     * @dev This is a forecast on the amount of assets that need to be available at the pool on the date specified.\r\n     * @param year The year.\r\n     * @param month The month.\r\n     * @param day The day.\r\n     * @return shares The number of shares (LP tokens) that will be burned on the date specified.\r\n     * @return assets The amount of assets that will be transferred on the date specified.\r\n     */\r\n    function getRequirementByDate(\r\n        uint256 year, \r\n        uint256 month, \r\n        uint256 day\r\n    ) external view onlyIfInitialized returns (uint256 shares, uint256 assets) {\r\n        bytes32 dailyCluster = keccak256(abi.encode(year, month, day));        \r\n        shares = _dailyRequirement[dailyCluster].shares;\r\n        assets = _dailyRequirement[dailyCluster].assets;\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the asset amount that can be claimed by a receiver at the date specified.\r\n     * @dev This is a forecast on the amount of assets that can be claimed by a given party on the date specified.\r\n     * @param year The year.\r\n     * @param month The month.\r\n     * @param day The day.\r\n     * @param receiverAddr The address of the receiver.\r\n     * @return uint256 The total amount of assets that can be claimed at a the date specified.\r\n     */\r\n    function getClaimableAmountByReceiver(\r\n        uint256 year, \r\n        uint256 month, \r\n        uint256 day,\r\n        address receiverAddr\r\n    ) external view onlyIfInitialized returns (uint256) {\r\n        bytes32 dailyCluster = keccak256(abi.encode(year, month, day));\r\n        return _receiverAmounts[dailyCluster][receiverAddr];\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the total number of shares to burn at the date specified for a given receiver.\r\n     * @dev This is a forecast on the amount of assets that can be claimed by a given party on the date specified.\r\n     * @param year The year.\r\n     * @param month The month.\r\n     * @param day The day.\r\n     * @param receiverAddr The address of the receiver.\r\n     * @return uint256 The total number of shares to burn at the date specified for a given receiver.\r\n     */\r\n    function getBurnableAmountByReceiver(\r\n        uint256 year, \r\n        uint256 month, \r\n        uint256 day,\r\n        address receiverAddr\r\n    ) external view onlyIfInitialized returns (uint256) {\r\n        bytes32 dailyCluster = keccak256(abi.encode(year, month, day));\r\n\r\n        return _burnableAmounts[dailyCluster][receiverAddr];\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the total number of transactions to run at a given date.\r\n     * @param year The year.\r\n     * @param month The month.\r\n     * @param day The day.\r\n     * @return totalTransactions The number of transactions to execute.\r\n     * @return executionEpoch The Unix epoch at which these transactions should be submitted to the blockchain.\r\n     */\r\n    function getScheduledTransactionsByDate(\r\n        uint256 year, \r\n        uint256 month, \r\n        uint256 day\r\n    ) external view ifConfigured returns (uint256 totalTransactions, uint256 executionEpoch) {\r\n        bytes32 dailyCluster = keccak256(abi.encode(year, month, day));\r\n\r\n        totalTransactions = _uniqueReceiversPerCluster[dailyCluster].length;\r\n        executionEpoch = DateUtils.timestampFromDateTime(year, month, day, liquidationHour, 0, 0);\r\n    }\r\n\r\n    // ----------------------------------------\r\n    // Inner functions\r\n    // ----------------------------------------\r\n    function _registerRedeemRequest(\r\n        uint256 shares, \r\n        address holderAddr, \r\n        address receiverAddr,\r\n        address callerAddr\r\n    ) internal returns (\r\n        uint256 claimableEpoch, \r\n        uint256 year, \r\n        uint256 month, \r\n        uint256 day, \r\n        uint256 effectiveAssetsAmount\r\n    ) {\r\n        require(receiverAddr != address(0) && receiverAddr != address(this), \"Invalid receiver\");\r\n        require(holderAddr != address(0) && holderAddr != address(this), \"Invalid holder\");\r\n        require(shares > 0, \"Shares amount required\");\r\n        require(_balances[holderAddr] >= shares, \"Insufficient shares\");\r\n\r\n        // The number of assets the receiver will get at the current price/ratio, per ERC-4626.\r\n        (uint256 assetsAmount, uint256 assetsAfterFee) = _previewRedeemWithFees(shares);\r\n        require(assetsAmount <= maxWithdraw(holderAddr), \"Withdrawal limit reached\");\r\n        require(assetsAfterFee > 0, \"Amount too low\");\r\n\r\n        // The withdrawal fee to apply\r\n        uint256 applicableFee = assetsAmount - assetsAfterFee;\r\n        effectiveAssetsAmount = assetsAfterFee;\r\n\r\n        // The time slot (cluster) of the lagged withdrawal\r\n        (year, month, day) = DateUtils.timestampToDate(block.timestamp + _TIMESTAMP_MANIPULATION_WINDOW + lagDuration);\r\n\r\n        // The hash of the cluster\r\n        bytes32 dailyCluster = keccak256(abi.encode(year, month, day));\r\n\r\n        // The withdrawal will be processed at the following epoch\r\n        claimableEpoch = DateUtils.timestampFromDateTime(year, month, day, liquidationHour, 0, 0);\r\n\r\n        // ERC20 allowance scenario\r\n        if (callerAddr != holderAddr) _spendAllowance(holderAddr, callerAddr, shares);\r\n\r\n        // Transfer the shares from the token holder to this contract.\r\n        // We transfer the shares to the liquidity pool in order to avoid fluctuations on the token price.\r\n        // Otherwise, burning shares at this point in time would affect the number of assets (liability) \r\n        // of future withdrawal requests because the token price would increase.\r\n        _executeErc20Transfer(holderAddr, address(this), shares);\r\n\r\n        // Global metrics\r\n        _dailyRequirement[dailyCluster].assets += assetsAmount;\r\n        _dailyRequirement[dailyCluster].shares += shares;\r\n        globalLiabilityShares += shares;\r\n\r\n        // Unique receivers by date. We will transfer underlying tokens to this receiver shortly.\r\n        if (_receiverAmounts[dailyCluster][receiverAddr] == 0) {\r\n            _uniqueReceiversPerCluster[dailyCluster].push(receiverAddr);\r\n            _receiverIndexes[dailyCluster][receiverAddr] = _uniqueReceiversPerCluster[dailyCluster].length;\r\n        }\r\n\r\n        // Track the amount of underlying assets we are required to transfer to the receiver address specified.\r\n        _receiverAmounts[dailyCluster][receiverAddr] += assetsAfterFee;\r\n        _burnableAmounts[dailyCluster][receiverAddr] += shares;\r\n        _feeAmountsByReceiver[dailyCluster][receiverAddr] += applicableFee;\r\n\r\n        emit WithdrawalRequested(holderAddr, receiverAddr, shares, assetsAmount, applicableFee, year, month, day);\r\n    }\r\n\r\n    function _claim(\r\n        uint256 year, \r\n        uint256 month, \r\n        uint256 day,\r\n        address receiverAddr\r\n    ) internal returns (uint256, uint256) {\r\n        require(receiverAddr != address(0), \"Invalid receiver\");\r\n\r\n        bytes32 dailyCluster = keccak256(abi.encode(year, month, day));\r\n\r\n        uint256 shares = _burnableAmounts[dailyCluster][receiverAddr];\r\n        require(shares > 0, \"No shares for receiver\");\r\n\r\n        uint256 receiverIndex = _receiverIndexes[dailyCluster][receiverAddr];\r\n        require(receiverIndex > 0, \"Invalid receiver index\");\r\n\r\n        uint256 claimableAssets = _receiverAmounts[dailyCluster][receiverAddr];\r\n        uint256 assetFee = _feeAmountsByReceiver[dailyCluster][receiverAddr];\r\n\r\n        if (lagDuration > 0) {\r\n            // Make sure withdrawals are processed at the expected epoch only.\r\n            require(block.timestamp + _TIMESTAMP_MANIPULATION_WINDOW >= DateUtils.timestampFromDateTime(year, month, day, liquidationHour, 0, 0), \"Too early\");\r\n        }\r\n\r\n        // Internal state changes (trusted)\r\n        _receiverAmounts[dailyCluster][receiverAddr] = 0;\r\n        _burnableAmounts[dailyCluster][receiverAddr] = 0;\r\n        _feeAmountsByReceiver[dailyCluster][receiverAddr] = 0;\r\n        _dailyRequirement[dailyCluster].shares -= shares;\r\n        _dailyRequirement[dailyCluster].assets -= (claimableAssets + assetFee);\r\n        globalLiabilityShares -= shares;\r\n        totalCollectableFees += assetFee;\r\n\r\n        _deleteReceiver(dailyCluster, receiverAddr);\r\n\r\n        _burnErc20(address(this), shares);\r\n\r\n        // Make sure the pool has enough balance to cover withdrawals.\r\n        uint256 balanceBefore = IERC20(_underlyingAsset).balanceOf(address(this));\r\n        SafeERC20.safeTransfer(_underlyingAsset, receiverAddr, claimableAssets);\r\n\r\n        // Balance check, provided the external asset is untrusted\r\n        require(IERC20(_underlyingAsset).balanceOf(address(this)) >= balanceBefore - claimableAssets, \"Balance check failed\");\r\n\r\n        return (shares, claimableAssets);\r\n    }\r\n\r\n    function _deleteReceiver(bytes32 dailyCluster, address addr) private {\r\n        uint256 idx = _receiverIndexes[dailyCluster][addr] - 1;\r\n        uint256 totalReceiversByDate = _uniqueReceiversPerCluster[dailyCluster].length;\r\n        address lastItem = _uniqueReceiversPerCluster[dailyCluster][totalReceiversByDate - 1];\r\n\r\n        if (addr != lastItem) {\r\n            _uniqueReceiversPerCluster[dailyCluster][totalReceiversByDate - 1] = _uniqueReceiversPerCluster[dailyCluster][idx];\r\n            _uniqueReceiversPerCluster[dailyCluster][idx] = lastItem;\r\n            _receiverIndexes[dailyCluster][lastItem] = idx + 1;\r\n        }\r\n        \r\n        _uniqueReceiversPerCluster[dailyCluster].pop();\r\n        _receiverIndexes[dailyCluster][addr] = 0;\r\n    }\r\n\r\n    /*\r\n    function _deleteReceiver(bytes32 dailyCluster, address addr) private {\r\n        uint256 idx = _receiverIndexes[dailyCluster][addr] - 1;\r\n        //require(idx < _uniqueReceiversPerCluster[dailyCluster].length, \"Invalid receiver index\");\r\n        require(_uniqueReceiversPerCluster[dailyCluster][idx] == addr, \"Address/index mismatch\");\r\n\r\n        uint256 totalReceiversByDate = _uniqueReceiversPerCluster[dailyCluster].length;\r\n        address lastItem = _uniqueReceiversPerCluster[dailyCluster][totalReceiversByDate - 1];\r\n\r\n        if (addr != lastItem) {\r\n            _uniqueReceiversPerCluster[dailyCluster][totalReceiversByDate - 1] = _uniqueReceiversPerCluster[dailyCluster][idx];\r\n            _uniqueReceiversPerCluster[dailyCluster][idx] = lastItem;\r\n        }\r\n        \r\n        _uniqueReceiversPerCluster[dailyCluster].pop();\r\n        _receiverIndexes[dailyCluster][addr] = 0;\r\n    }\r\n    */\r\n}\r\n\r\n\r\n/**\r\n * @title Represents an ownable liquidity pool. The pool is compliant with the ERC-4626 standard.\r\n */\r\nabstract contract OwnableLiquidityPool is TimelockedERC4626, BaseOwnable {\r\n    /**\r\n     * @notice This event is triggered when the owner runs an emergency withdrawal.\r\n     * @param withdrawalAmount The withdrawal amount.\r\n     * @param tokenAddr The token address.\r\n     * @param destinationAddr The destination address.\r\n     */\r\n    event OnEmergencyWithdraw (uint256 withdrawalAmount, address tokenAddr, address destinationAddr);\r\n\r\n    /**\r\n     * @notice Allows the owner of the pool to withdraw the full balance of the token specified.\r\n     * @dev Throws if the caller is not the current owner of the pool. If the asset to withdraw is the underlying asset of the pool then this function pauses deposits and withdrawals automatically.\r\n     * @param token The token to transfer.\r\n     * @param destinationAddr The destination address of the ERC20 transfer.\r\n     */\r\n    function emergencyWithdraw(\r\n        IERC20 token,\r\n        address destinationAddr\r\n    ) external virtual nonReentrant ifConfigured onlyOwner {\r\n        //require(destinationAddr != address(0) && destinationAddr != address(this), \"Invalid address\");\r\n\r\n        uint256 currentBalance = token.balanceOf(address(this));\r\n        //require(currentBalance > 0, \"Insufficient balance\");\r\n\r\n        if (address(token) == address(_underlyingAsset)) {\r\n            // Automatically pause deposits and withdrawals in order to prevent fluctuations on the price of the LP token\r\n            _setPause(true, true);\r\n        }\r\n\r\n        SafeERC20.safeTransfer(token, destinationAddr, currentBalance);\r\n\r\n        emit OnEmergencyWithdraw(currentBalance, address(token), destinationAddr);\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the owner of the pool.\r\n     * @return address The address who owns the pool.\r\n     */\r\n    function owner() external view onlyIfInitialized returns (address) {\r\n        return _owner;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Represents an ERC-4626 compliant liquidity pool capable of lending funds on their own.\r\n * @dev This liquidity pool is ownable by definition.\r\n */\r\nabstract contract AbstractLender is OwnableLiquidityPool {\r\n    /// @notice The address of the Loans Operator\r\n    address public loansOperator;\r\n\r\n    // ---------------------------------------------------------------\r\n    // Modifiers\r\n    // ---------------------------------------------------------------\r\n    modifier onlyLoansOperator() {\r\n        require(msg.sender == loansOperator, \"Loans Operator only\");\r\n        _;\r\n    }\r\n\r\n    // ---------------------------------------------------------------\r\n    // Implementation functions\r\n    // ---------------------------------------------------------------\r\n    /**\r\n     * @notice As a lender, this pool proposes a new APR to the borrower of the loan address specified.\r\n     * @param loanAddr The address of the loan.\r\n     * @param newAprWithTwoDecimals The APR proposed by this pool, expressed with 2 decimal places.\r\n     */\r\n    function proposeNewApr(\r\n        address loanAddr, \r\n        uint256 newAprWithTwoDecimals\r\n    ) external nonReentrant ifConfigured onlyLoansOperator {\r\n        _ensureValidLoan(loanAddr);\r\n        IPeerToPeerOpenTermLoan(loanAddr).proposeNewApr(newAprWithTwoDecimals);\r\n    }\r\n\r\n    /**\r\n     * @notice Updates the late fees of the loan specified.\r\n     * @param loanAddr The address of the loan.\r\n     * @param lateInterestFeeWithTwoDecimals The late interest fee (percentage) with 2 decimal places.\r\n     * @param latePrincipalFeeWithTwoDecimals The late principal fee (percentage) with 2 decimal places.\r\n     */\r\n    function changeLateFees(\r\n        address loanAddr, \r\n        uint256 lateInterestFeeWithTwoDecimals, \r\n        uint256 latePrincipalFeeWithTwoDecimals\r\n    ) external nonReentrant ifConfigured onlyLoansOperator {\r\n        _ensureValidLoan(loanAddr);\r\n        IPeerToPeerOpenTermLoan(loanAddr).changeLateFees(lateInterestFeeWithTwoDecimals, latePrincipalFeeWithTwoDecimals);\r\n    }\r\n\r\n    /**\r\n     * @notice Updates the maintenance collateral ratio\r\n     * @param loanAddr The address of the loan.\r\n     * @param maintenanceCollateralRatioWith2Decimals The maintenance collateral ratio, if applicable.\r\n     */\r\n    function changeMaintenanceCollateralRatio(\r\n        address loanAddr, \r\n        uint256 maintenanceCollateralRatioWith2Decimals\r\n    ) external nonReentrant ifConfigured onlyLoansOperator {\r\n        _ensureValidLoan(loanAddr);\r\n        IPeerToPeerOpenTermLoan(loanAddr).changeMaintenanceCollateralRatio(maintenanceCollateralRatioWith2Decimals);\r\n    }\r\n\r\n    /**\r\n     * @notice Calls the loan specified.\r\n     * @param loanAddr The address of the loan.\r\n     * @param callbackPeriodInHours The callback period, measured in hours.\r\n     * @param gracePeriodInHours The grace period, measured in hours.\r\n     */\r\n    function callLoan(\r\n        address loanAddr, \r\n        uint256 callbackPeriodInHours, \r\n        uint256 gracePeriodInHours\r\n    ) external nonReentrant ifConfigured onlyLoansOperator {\r\n        _ensureValidLoan(loanAddr);\r\n        IPeerToPeerOpenTermLoan(loanAddr).callLoan(callbackPeriodInHours, gracePeriodInHours);\r\n    }\r\n\r\n    /**\r\n     * @notice Liquidates the loan specified.\r\n     * @param loanAddr The address of the loan.\r\n     */\r\n    function liquidate(address loanAddr) external ifConfigured onlyLoansOperator {\r\n        _ensureValidLoan(loanAddr);\r\n        IPeerToPeerOpenTermLoan(loanAddr).liquidate();\r\n    }\r\n\r\n    // ---------------------------------------------------------------\r\n    // Virtuals\r\n    // ---------------------------------------------------------------\r\n    function fundLoan(address loanAddr) external virtual;\r\n    function _ensureValidLoan(address loanAddr) internal view virtual;\r\n}\r\n\r\n\r\n/**\r\n * @title Represents an ERC-4626 lending pool capable of processing hooks on-chain.\r\n * @dev This contract overrides ERC4626.totalAssets() in order to reflect the risk exposure to loans.\r\n */\r\nabstract contract HookableLender is IHookableLender, AbstractLender {\r\n    struct LoanDeploymentRecord {\r\n        uint256 effectiveLoanAmount;\r\n        uint256 activeDelta;\r\n        bool isWhitelisted;\r\n    }\r\n\r\n    // ---------------------------------------------------------------\r\n    // Storage layout\r\n    // ---------------------------------------------------------------\r\n    /// @notice The current risk exposure to loans\r\n    uint256 public globalLoansAmount;\r\n\r\n    /// @dev The current delta of a loan\r\n    mapping (address => LoanDeploymentRecord) internal _deployedLoans;\r\n\r\n    // ---------------------------------------------------------------\r\n    // Modifiers\r\n    // ---------------------------------------------------------------\r\n    modifier onlyKnownLoanContract() {\r\n        require(_deployedLoans[msg.sender].isWhitelisted, \"Unknown loan\");\r\n        _;\r\n    }\r\n\r\n    // ---------------------------------------------------------------\r\n    // Hooks implementation\r\n    // ---------------------------------------------------------------\r\n    function notifyLoanMatured() external override nonReentrant ifConfigured onlyKnownLoanContract {\r\n        if (_deployedLoans[msg.sender].activeDelta > 0) globalLoansAmount -= _deployedLoans[msg.sender].activeDelta;\r\n        _deployedLoans[msg.sender].activeDelta = 0;\r\n    }\r\n\r\n    function notifyLoanClosed() external override nonReentrant ifConfigured onlyKnownLoanContract {\r\n        if (_deployedLoans[msg.sender].activeDelta > 0) globalLoansAmount -= _deployedLoans[msg.sender].activeDelta;\r\n        _deployedLoans[msg.sender].activeDelta = 0;\r\n    }\r\n\r\n    function notifyPrincipalRepayment(\r\n        uint256 effectiveLoanAmount, \r\n        uint256 principalRepaid\r\n    ) external override nonReentrant ifConfigured onlyKnownLoanContract {\r\n        uint256 newDelta = (principalRepaid < effectiveLoanAmount) ? effectiveLoanAmount - principalRepaid : 0;\r\n\r\n        if (_deployedLoans[msg.sender].activeDelta > 0) globalLoansAmount -= _deployedLoans[msg.sender].activeDelta;\r\n        _deployedLoans[msg.sender].activeDelta = newDelta;\r\n\r\n        if (newDelta > 0) globalLoansAmount += newDelta;\r\n    }\r\n\r\n    function _ensureValidLoan(address loanAddr) internal view override {\r\n        require(_deployedLoans[loanAddr].isWhitelisted, \"Invalid loan contract\");\r\n    }\r\n\r\n    // ---------------------------------------------------------------\r\n    // ERC-4626 overrides\r\n    // ---------------------------------------------------------------\r\n    function _getTotalAssets() internal view virtual override returns (uint256) {\r\n        // [Liquidity] + [the delta of all ACTIVE loans managed by this pool]\r\n        return globalLoansAmount + _underlyingAsset.balanceOf(address(this));\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Represents a base lending pool.\r\n * @dev The pool is capable of deploying and funding loans on their own. It is also capable of receiving hooks on-chain.\r\n */\r\nabstract contract BaseLendingPool is HookableLender {\r\n    /// @notice The address of the contract that deploys loans.\r\n    address public loansDeployerAddress;\r\n\r\n    /// @notice The list of all loans deployed by the lending pool\r\n    address[] public loansDeployed;\r\n\r\n    /// @notice Triggers when the lending pool deploys a new loan.\r\n    event NewLoanDeployedByPool(address loanAddr, uint256 aprWithTwoDecimals);\r\n\r\n    /**\r\n     * @notice Deploys a new loan on behalf of the Credit Pool. This contract acts as a lender.\r\n     * @param loanParams The parameters of the loan to deploy.\r\n     * @return address The address of the newly deployed loan.\r\n     */\r\n    function deployLoan(\r\n        LoanDeploymentParams memory loanParams\r\n    ) external nonReentrant ifConfigured onlyLoansOperator returns (address) {\r\n        loanParams.lenderAddr = address(this);\r\n\r\n        address loanAddr = IPermissionlessLoansDeployer(loansDeployerAddress).deployLoan(loanParams);\r\n\r\n        // This should never happen because the loan was deployed via CREATE rather than CREATE2\r\n        require(!_deployedLoans[loanAddr].isWhitelisted, \"Invalid deployment address\");\r\n\r\n        uint256 effectiveLoanAmount = IPeerToPeerOpenTermLoan(loanAddr).effectiveLoanAmount();\r\n\r\n        _deployedLoans[loanAddr] = LoanDeploymentRecord({\r\n            effectiveLoanAmount: effectiveLoanAmount,\r\n            activeDelta: 0,\r\n            isWhitelisted: true\r\n        });\r\n\r\n        loansDeployed.push(loanAddr);\r\n\r\n        emit NewLoanDeployedByPool(loanAddr, loanParams.newAprWithTwoDecimals);\r\n\r\n        return loanAddr;\r\n    }\r\n\r\n    /**\r\n     * @notice Funds the loan deployed at the address specified.\r\n     * @dev Throws if the loan was not deployed by this pool.\r\n     * @param loanAddr The address of the loan.\r\n     */\r\n    function fundLoan(address loanAddr) external override nonReentrant ifConfigured onlyLoansOperator {\r\n        // Trusted queries\r\n        _ensureValidLoan(loanAddr);\r\n        uint256 effectiveLoanAmount = _deployedLoans[loanAddr].effectiveLoanAmount;\r\n\r\n        // Trusted changes\r\n        _deployedLoans[loanAddr].activeDelta = effectiveLoanAmount; // The principal repaid at this point in time is zero\r\n        globalLoansAmount += effectiveLoanAmount; // which is \"_deployedLoans[loanAddr].activeDelta\"\r\n\r\n        require(IPeerToPeerOpenTermLoan(loanAddr).loanState() == LOAN_FUNDING_REQUIRED, \"Invalid loan state\");\r\n\r\n        // Untrusted changes\r\n        SafeERC20.safeApprove(_underlyingAsset, loanAddr, effectiveLoanAmount);\r\n        IPeerToPeerOpenTermLoan(loanAddr).fundLoan();\r\n        SafeERC20.safeApprove(_underlyingAsset, loanAddr, uint256(0));\r\n\r\n        // Late checks\r\n        require(IPeerToPeerOpenTermLoan(loanAddr).loanState() == LOAN_ACTIVE, \"Funding check failed\");\r\n        require(_underlyingAsset.allowance(address(this), loanAddr) == uint256(0), \"Allowance check failed\");\r\n    }\r\n\r\n    /**\r\n     * @notice Collects the fees available in the pool. Fees are sent to the fee collector address.\r\n     */\r\n    function collectFees() external nonReentrant ifConfigured onlyOwner {\r\n        //require(totalCollectableFees > 0, \"No fees to collect\");\r\n        \r\n        uint256 feesAmount = totalCollectableFees;\r\n\r\n        totalCollectableFees = 0;\r\n        SafeERC20.safeTransfer(_underlyingAsset, feesCollector, feesAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the total number of loans deployed by the pool.\r\n     * @return uint256 The total number of loans deployed by the pool.\r\n     */\r\n    function getTotalLoansDeployed() external view returns (uint256) {\r\n        return loansDeployed.length;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Represents a lending pool that is fully compliant with the ERC-4626 standard.\r\n * @dev The lending pool is an address-preserving transparent proxy.\r\n */\r\ncontract LendingPool is BaseLendingPool {\r\n    constructor() {\r\n        _disableInitializers();\r\n    }\r\n\r\n    /**\r\n     * @notice Proxy initialization function.\r\n     * @param newOwner The owner of the lending pool.\r\n     * @param erc20Decimals The number of decimals of the LP token issued by this pool, per ERC20.\r\n     * @param erc20Symbol The token symbol of this pool, per ERC20.\r\n     * @param erc20Name The token name of this pool, per ERC20.\r\n     */\r\n    function initialize(\r\n        address newOwner,\r\n        uint8 erc20Decimals,\r\n        string memory erc20Symbol,\r\n        string memory erc20Name\r\n    ) external initializer {\r\n        require(newOwner != address(0), \"Owner required\");\r\n\r\n        // ERC-20 settings\r\n        decimals = erc20Decimals;\r\n        symbol = erc20Symbol;\r\n        name = erc20Name;\r\n\r\n        // Pause deposits and withdrawals until the pool gets configured by the authorized party.\r\n        depositsPaused = true;\r\n        withdrawalsPaused = true;\r\n\r\n        _owner = newOwner;\r\n    }\r\n\r\n    /**\r\n     * @notice Configures the lending pool.\r\n     * @dev Throws if the caller is not the owner. Deposits and withdrawals are paused until the pool is configured.\r\n     * @param newLagDuration The duration of the timelock. Pass zero if the pool is not time-locked.\r\n     * @param newMaxDepositAmount The maximum deposit amount of assets (say USDC) investors are allowed to deposit in the pool.\r\n     * @param newMaxWithdrawalAmount The maximum withdrawal amount of the pool, expressed in underlying assets (for example: USDC)\r\n     * @param newMaxTokenSupply The maximum supply of LP tokens (liquidity pool tokens)\r\n     * @param newUnderlyingAsset The underlying asset of the liquidity pool (for example: USDC).\r\n     * @param newLoansOperator The address responsible for managing the loans of the pool.\r\n     * @param newLoansDeployerAddress The address of the smart contract you will use for deploying loans on behalf of this pool.\r\n     * @param newFeesCollectorAddr The address of the fees collector.\r\n     * @param newProcessingHour The hour (UTC) at which all withdrawal requests will be processed. The value ranges from [0..23]\r\n     */\r\n    function configurePool(\r\n        uint256 newLagDuration,\r\n        uint256 newMaxDepositAmount, \r\n        uint256 newMaxWithdrawalAmount, \r\n        uint256 newMaxTokenSupply,\r\n        address newUnderlyingAsset,\r\n        address newLoansOperator,\r\n        address newLoansDeployerAddress,\r\n        address newFeesCollectorAddr,\r\n        uint8 newProcessingHour\r\n    ) external onlyIfInitialized nonReentrant ifNotConfigured onlyOwner {\r\n        require(newLoansOperator != address(0), \"Operator required\");\r\n        require(newLoansDeployerAddress != address(0), \"Deployer required\");\r\n        require(newFeesCollectorAddr != address(0), \"Collector required\");\r\n        require(newProcessingHour < 24, \"Invalid processing hour\"); // Min: 0, Max: 23  (eg: 13 = 1PM)\r\n\r\n        _underlyingAsset = IERC20(newUnderlyingAsset);\r\n        _updateIssuanceLimits(newMaxDepositAmount, newMaxWithdrawalAmount, newMaxTokenSupply);\r\n\r\n        // Loan management actors\r\n        loansOperator = newLoansOperator;\r\n        loansDeployerAddress = newLoansDeployerAddress;\r\n        feesCollector = newFeesCollectorAddr;\r\n\r\n        // Timelock settings\r\n        lagDuration = newLagDuration;\r\n        liquidationHour = newProcessingHour;\r\n\r\n        // Resume deposits and withdrawals\r\n        depositsPaused = false;\r\n        withdrawalsPaused = false;\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers ownership of the contract to a new account.\r\n     * @dev Throws if the caller is not the current owner. Additional constraints apply.\r\n     * @param newOwner The new owner of this contract.\r\n     */\r\n    function transferOwnership(address newOwner) external onlyIfInitialized nonReentrant onlyOwner {\r\n        require(newOwner != address(0) && newOwner != address(this), \"Invalid owner\");\r\n        require(newOwner != loansOperator, \"Owner cannot be operator\");\r\n        require(newOwner != loansDeployerAddress, \"Owner cannot be deployer\");\r\n\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @notice Updates the issuance and redemption settings of the pool.\r\n     * @dev Throws if the caller is not the owner of the pool. Throws if the pool was not configured.\r\n     * @param newMaxDepositAmount The maximum deposit amount of assets (say USDC) investors are allowed to deposit in the pool.\r\n     * @param newMaxWithdrawalAmount The maximum withdrawal amount of the pool, expressed in underlying assets (for example: USDC)\r\n     * @param newMaxTokenSupply The maximum supply of LP tokens (liquidity pool tokens)\r\n     */\r\n    function updateIssuanceLimits(\r\n        uint256 newMaxDepositAmount, \r\n        uint256 newMaxWithdrawalAmount, \r\n        uint256 newMaxTokenSupply\r\n    ) external nonReentrant ifConfigured onlyOwner {\r\n        _updateIssuanceLimits(newMaxDepositAmount, newMaxWithdrawalAmount, newMaxTokenSupply);\r\n    }\r\n\r\n    /**\r\n     * @notice Pauses/Resumes deposits and/or withdrawals.\r\n     * @dev Throws if the caller is not the owner of the pool.\r\n     * @param bPauseDeposits Pass \"true\" to pause deposits. Pass \"false\" to resume deposits.\r\n     * @param bPauseWithdrawals Pass \"true\" to pause withdrawals. Pass \"false\" to resume withdrawals.\r\n     */\r\n    function pauseDepositsAndWithdrawals(bool bPauseDeposits, bool bPauseWithdrawals) external nonReentrant ifConfigured onlyOwner {\r\n        _setPause(bPauseDeposits, bPauseWithdrawals);\r\n    }\r\n\r\n    /**\r\n     * @notice Updates the duration of the timelock.\r\n     * @dev Setting the timelock to zero will allow to withdraw funds immediately from the pool.\r\n     * @param newDuration The duration of the timelock, expressed in seconds. It can be zero.\r\n     */\r\n    function updateTimelockDuration(uint256 newDuration) external nonReentrant ifConfigured onlyOwner {\r\n        if (newDuration <= lagDuration) require(globalLiabilityShares == 0, \"Process claims first\");\r\n        lagDuration = newDuration;\r\n    }\r\n\r\n    /**\r\n     * @notice Updates the fee for withdrawals.\r\n     * @param newWithdrawalFee The new fee, expressed with 2 decimal places.\r\n     */\r\n    function updateWithdrawalFee(uint256 newWithdrawalFee) external nonReentrant ifConfigured onlyOwner {\r\n        require(newWithdrawalFee < 9900, \"Fee too high\");\r\n        require(withdrawalFee != newWithdrawalFee, \"Fee already set\");\r\n\r\n        withdrawalFee = newWithdrawalFee;\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"bDepositsPaused\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"bWithdrawalsPaused\",\"type\":\"bool\"}],\"name\":\"DepositWithdrawalStatusChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"loanAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"aprWithTwoDecimals\",\"type\":\"uint256\"}],\"name\":\"NewLoanDeployedByPool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawalAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"destinationAddr\",\"type\":\"address\"}],\"name\":\"OnEmergencyWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"prevValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"OnMaxSupplyChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"ownerAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiverAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"year\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"month\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"}],\"name\":\"WithdrawalRequested\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ownerAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spenderAddr\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"asset\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"loanAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"callbackPeriodInHours\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gracePeriodInHours\",\"type\":\"uint256\"}],\"name\":\"callLoan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"loanAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lateInterestFeeWithTwoDecimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"latePrincipalFeeWithTwoDecimals\",\"type\":\"uint256\"}],\"name\":\"changeLateFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"loanAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maintenanceCollateralRatioWith2Decimals\",\"type\":\"uint256\"}],\"name\":\"changeMaintenanceCollateralRatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"year\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"month\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiverAddr\",\"type\":\"address\"}],\"name\":\"claim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collectFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newLagDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newMaxDepositAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newMaxWithdrawalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newMaxTokenSupply\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"newUnderlyingAsset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newLoansOperator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newLoansDeployerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newFeesCollectorAddr\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"newProcessingHour\",\"type\":\"uint8\"}],\"name\":\"configurePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"convertToAssets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"name\":\"convertToShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"fundingPeriodInSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newPaymentIntervalInSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newLoanAmountInPrincipalTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"originationFeePercent2Decimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newAprWithTwoDecimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialCollateralRatioWith2Decimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maintenanceCollateralRatioWith2Decimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lateInterestFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"latePrincipalFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiryInfo\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"loanTypeInfo\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"lenderAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrowerAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newCollateralToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newPrincipalToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"feesManagerAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"priceOracleAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"feesCollectorAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"categoryFeesAdress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"allowSeizeCollateral\",\"type\":\"bool\"}],\"internalType\":\"struct LoanDeploymentParams\",\"name\":\"loanParams\",\"type\":\"tuple\"}],\"name\":\"deployLoan\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositsPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destinationAddr\",\"type\":\"address\"}],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feesCollector\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"loanAddr\",\"type\":\"address\"}],\"name\":\"fundLoan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"year\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"month\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiverAddr\",\"type\":\"address\"}],\"name\":\"getBurnableAmountByReceiver\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"year\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"month\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiverAddr\",\"type\":\"address\"}],\"name\":\"getClaimableAmountByReceiver\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getInitializedVersion\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"year\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"month\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"}],\"name\":\"getRequirementByDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"year\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"month\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"}],\"name\":\"getScheduledTransactionsByDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalTransactions\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"executionEpoch\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalLoansDeployed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWithdrawalEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"year\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"month\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimableEpoch\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"globalLiabilityShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"globalLoansAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"erc20Decimals\",\"type\":\"uint8\"},{\"internalType\":\"string\",\"name\":\"erc20Symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"erc20Name\",\"type\":\"string\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lagDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"loanAddr\",\"type\":\"address\"}],\"name\":\"liquidate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidationHour\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"loansDeployed\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"loansDeployerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"loansOperator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"maxDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxDepositAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"maxMint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holderAddr\",\"type\":\"address\"}],\"name\":\"maxRedeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holderAddr\",\"type\":\"address\"}],\"name\":\"maxWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWithdrawalAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"notifyLoanClosed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"notifyLoanMatured\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"effectiveLoanAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"principalRepaid\",\"type\":\"uint256\"}],\"name\":\"notifyPrincipalRepayment\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"bPauseDeposits\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"bPauseWithdrawals\",\"type\":\"bool\"}],\"name\":\"pauseDepositsAndWithdrawals\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"name\":\"previewDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"previewMint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"previewRedeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"name\":\"previewWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"year\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"month\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxLimit\",\"type\":\"uint256\"}],\"name\":\"processAllClaimsByDate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"loanAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"newAprWithTwoDecimals\",\"type\":\"uint256\"}],\"name\":\"proposeNewApr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"redeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiverAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"holderAddr\",\"type\":\"address\"}],\"name\":\"requestRedeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimableEpoch\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalAssets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalCollectableFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMaxDepositAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newMaxWithdrawalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newMaxTokenSupply\",\"type\":\"uint256\"}],\"name\":\"updateIssuanceLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newDuration\",\"type\":\"uint256\"}],\"name\":\"updateTimelockDuration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newWithdrawalFee\",\"type\":\"uint256\"}],\"name\":\"updateWithdrawalFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawalFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawalsPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"LendingPool","CompilerVersion":"v0.8.26+commit.8a97fa7a","OptimizationUsed":1,"Runs":200,"ConstructorArguments":"0x","EVMVersion":"Default","Library":"","LicenseType":"BSL 1.1","Proxy":0,"SwarmSource":"ipfs://0698068d3c095459d84bbf417d655cfff30f9037d2fdddc0ac770f93df5eceaf"}]}